'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var coreClient = require('@azure/core-client');
var tslib = require('tslib');
var coreLro = require('@azure/core-lro');

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
(function (KnownAzureADOnlyAuthenticationName) {
    KnownAzureADOnlyAuthenticationName["Default"] = "default";
})(exports.KnownAzureADOnlyAuthenticationName || (exports.KnownAzureADOnlyAuthenticationName = {}));
(function (KnownStateValue) {
    KnownStateValue["Consistent"] = "Consistent";
    KnownStateValue["InConsistent"] = "InConsistent";
    KnownStateValue["Updating"] = "Updating";
})(exports.KnownStateValue || (exports.KnownStateValue = {}));
(function (KnownProvisioningState) {
    KnownProvisioningState["Provisioning"] = "Provisioning";
    KnownProvisioningState["Succeeded"] = "Succeeded";
    KnownProvisioningState["Deleting"] = "Deleting";
    KnownProvisioningState["Failed"] = "Failed";
    KnownProvisioningState["DeleteError"] = "DeleteError";
})(exports.KnownProvisioningState || (exports.KnownProvisioningState = {}));
(function (KnownOperationStatus) {
    KnownOperationStatus["InProgress"] = "InProgress";
    KnownOperationStatus["Succeeded"] = "Succeeded";
    KnownOperationStatus["Failed"] = "Failed";
    KnownOperationStatus["Canceled"] = "Canceled";
})(exports.KnownOperationStatus || (exports.KnownOperationStatus = {}));
(function (KnownCreateMode) {
    KnownCreateMode["Default"] = "Default";
    KnownCreateMode["PointInTimeRestore"] = "PointInTimeRestore";
    KnownCreateMode["Recovery"] = "Recovery";
    KnownCreateMode["Restore"] = "Restore";
})(exports.KnownCreateMode || (exports.KnownCreateMode = {}));
(function (KnownStorageAccountType) {
    KnownStorageAccountType["GRS"] = "GRS";
    KnownStorageAccountType["LRS"] = "LRS";
})(exports.KnownStorageAccountType || (exports.KnownStorageAccountType = {}));
(function (KnownGeoBackupPolicyName) {
    KnownGeoBackupPolicyName["Default"] = "Default";
})(exports.KnownGeoBackupPolicyName || (exports.KnownGeoBackupPolicyName = {}));
(function (KnownDataWarehouseUserActivityName) {
    KnownDataWarehouseUserActivityName["Current"] = "current";
})(exports.KnownDataWarehouseUserActivityName || (exports.KnownDataWarehouseUserActivityName = {}));
(function (KnownReplicationState) {
    KnownReplicationState["Pending"] = "PENDING";
    KnownReplicationState["Seeding"] = "SEEDING";
    KnownReplicationState["CatchUP"] = "CATCH_UP";
    KnownReplicationState["Suspended"] = "SUSPENDED";
})(exports.KnownReplicationState || (exports.KnownReplicationState = {}));
(function (KnownDayOfWeek) {
    KnownDayOfWeek["Sunday"] = "Sunday";
    KnownDayOfWeek["Monday"] = "Monday";
    KnownDayOfWeek["Tuesday"] = "Tuesday";
    KnownDayOfWeek["Wednesday"] = "Wednesday";
    KnownDayOfWeek["Thursday"] = "Thursday";
    KnownDayOfWeek["Friday"] = "Friday";
    KnownDayOfWeek["Saturday"] = "Saturday";
})(exports.KnownDayOfWeek || (exports.KnownDayOfWeek = {}));
(function (KnownTransparentDataEncryptionName) {
    KnownTransparentDataEncryptionName["Current"] = "current";
})(exports.KnownTransparentDataEncryptionName || (exports.KnownTransparentDataEncryptionName = {}));
(function (KnownManagementOperationState) {
    KnownManagementOperationState["Pending"] = "Pending";
    KnownManagementOperationState["InProgress"] = "InProgress";
    KnownManagementOperationState["Succeeded"] = "Succeeded";
    KnownManagementOperationState["Failed"] = "Failed";
    KnownManagementOperationState["CancelInProgress"] = "CancelInProgress";
    KnownManagementOperationState["Cancelled"] = "Cancelled";
})(exports.KnownManagementOperationState || (exports.KnownManagementOperationState = {}));
(function (KnownColumnDataType) {
    KnownColumnDataType["Image"] = "image";
    KnownColumnDataType["Text"] = "text";
    KnownColumnDataType["Uniqueidentifier"] = "uniqueidentifier";
    KnownColumnDataType["Date"] = "date";
    KnownColumnDataType["Time"] = "time";
    KnownColumnDataType["Datetime2"] = "datetime2";
    KnownColumnDataType["Datetimeoffset"] = "datetimeoffset";
    KnownColumnDataType["Tinyint"] = "tinyint";
    KnownColumnDataType["Smallint"] = "smallint";
    KnownColumnDataType["Int"] = "int";
    KnownColumnDataType["Smalldatetime"] = "smalldatetime";
    KnownColumnDataType["Real"] = "real";
    KnownColumnDataType["Money"] = "money";
    KnownColumnDataType["Datetime"] = "datetime";
    KnownColumnDataType["Float"] = "float";
    KnownColumnDataType["SqlVariant"] = "sql_variant";
    KnownColumnDataType["Ntext"] = "ntext";
    KnownColumnDataType["Bit"] = "bit";
    KnownColumnDataType["Decimal"] = "decimal";
    KnownColumnDataType["Numeric"] = "numeric";
    KnownColumnDataType["Smallmoney"] = "smallmoney";
    KnownColumnDataType["Bigint"] = "bigint";
    KnownColumnDataType["Hierarchyid"] = "hierarchyid";
    KnownColumnDataType["Geometry"] = "geometry";
    KnownColumnDataType["Geography"] = "geography";
    KnownColumnDataType["Varbinary"] = "varbinary";
    KnownColumnDataType["Varchar"] = "varchar";
    KnownColumnDataType["Binary"] = "binary";
    KnownColumnDataType["Char"] = "char";
    KnownColumnDataType["Timestamp"] = "timestamp";
    KnownColumnDataType["Nvarchar"] = "nvarchar";
    KnownColumnDataType["Nchar"] = "nchar";
    KnownColumnDataType["Xml"] = "xml";
    KnownColumnDataType["Sysname"] = "sysname";
})(exports.KnownColumnDataType || (exports.KnownColumnDataType = {}));
(function (KnownConnectionPolicyName) {
    KnownConnectionPolicyName["Default"] = "default";
})(exports.KnownConnectionPolicyName || (exports.KnownConnectionPolicyName = {}));
(function (KnownVulnerabilityAssessmentName) {
    KnownVulnerabilityAssessmentName["Default"] = "default";
})(exports.KnownVulnerabilityAssessmentName || (exports.KnownVulnerabilityAssessmentName = {}));
(function (KnownVulnerabilityAssessmentScanTriggerType) {
    KnownVulnerabilityAssessmentScanTriggerType["OnDemand"] = "OnDemand";
    KnownVulnerabilityAssessmentScanTriggerType["Recurring"] = "Recurring";
})(exports.KnownVulnerabilityAssessmentScanTriggerType || (exports.KnownVulnerabilityAssessmentScanTriggerType = {}));
(function (KnownVulnerabilityAssessmentScanState) {
    KnownVulnerabilityAssessmentScanState["Passed"] = "Passed";
    KnownVulnerabilityAssessmentScanState["Failed"] = "Failed";
    KnownVulnerabilityAssessmentScanState["FailedToRun"] = "FailedToRun";
    KnownVulnerabilityAssessmentScanState["InProgress"] = "InProgress";
})(exports.KnownVulnerabilityAssessmentScanState || (exports.KnownVulnerabilityAssessmentScanState = {}));
(function (KnownSecurityAlertPolicyName) {
    KnownSecurityAlertPolicyName["Default"] = "default";
})(exports.KnownSecurityAlertPolicyName || (exports.KnownSecurityAlertPolicyName = {}));
(function (KnownBlobAuditingPolicyName) {
    KnownBlobAuditingPolicyName["Default"] = "default";
})(exports.KnownBlobAuditingPolicyName || (exports.KnownBlobAuditingPolicyName = {}));
(function (KnownSecurityAlertPolicyNameAutoGenerated) {
    KnownSecurityAlertPolicyNameAutoGenerated["Default"] = "Default";
})(exports.KnownSecurityAlertPolicyNameAutoGenerated || (exports.KnownSecurityAlertPolicyNameAutoGenerated = {}));
(function (KnownEncryptionProtectorName) {
    KnownEncryptionProtectorName["Current"] = "current";
})(exports.KnownEncryptionProtectorName || (exports.KnownEncryptionProtectorName = {}));
(function (KnownServerKeyType) {
    KnownServerKeyType["ServiceManaged"] = "ServiceManaged";
    KnownServerKeyType["AzureKeyVault"] = "AzureKeyVault";
})(exports.KnownServerKeyType || (exports.KnownServerKeyType = {}));
(function (KnownWorkspacePublicNetworkAccess) {
    KnownWorkspacePublicNetworkAccess["Enabled"] = "Enabled";
    KnownWorkspacePublicNetworkAccess["Disabled"] = "Disabled";
})(exports.KnownWorkspacePublicNetworkAccess || (exports.KnownWorkspacePublicNetworkAccess = {}));
(function (KnownManagedIdentitySqlControlSettingsModelPropertiesGrantSqlControlToManagedIdentityDesiredState) {
    KnownManagedIdentitySqlControlSettingsModelPropertiesGrantSqlControlToManagedIdentityDesiredState["Enabled"] = "Enabled";
    KnownManagedIdentitySqlControlSettingsModelPropertiesGrantSqlControlToManagedIdentityDesiredState["Disabled"] = "Disabled";
})(exports.KnownManagedIdentitySqlControlSettingsModelPropertiesGrantSqlControlToManagedIdentityDesiredState || (exports.KnownManagedIdentitySqlControlSettingsModelPropertiesGrantSqlControlToManagedIdentityDesiredState = {}));
(function (KnownManagedIdentitySqlControlSettingsModelPropertiesGrantSqlControlToManagedIdentityActualState) {
    KnownManagedIdentitySqlControlSettingsModelPropertiesGrantSqlControlToManagedIdentityActualState["Enabling"] = "Enabling";
    KnownManagedIdentitySqlControlSettingsModelPropertiesGrantSqlControlToManagedIdentityActualState["Enabled"] = "Enabled";
    KnownManagedIdentitySqlControlSettingsModelPropertiesGrantSqlControlToManagedIdentityActualState["Disabling"] = "Disabling";
    KnownManagedIdentitySqlControlSettingsModelPropertiesGrantSqlControlToManagedIdentityActualState["Disabled"] = "Disabled";
    KnownManagedIdentitySqlControlSettingsModelPropertiesGrantSqlControlToManagedIdentityActualState["Unknown"] = "Unknown";
})(exports.KnownManagedIdentitySqlControlSettingsModelPropertiesGrantSqlControlToManagedIdentityActualState || (exports.KnownManagedIdentitySqlControlSettingsModelPropertiesGrantSqlControlToManagedIdentityActualState = {}));
(function (KnownConfigurationType) {
    KnownConfigurationType["File"] = "File";
    KnownConfigurationType["Artifact"] = "Artifact";
})(exports.KnownConfigurationType || (exports.KnownConfigurationType = {}));
(function (KnownNodeSize) {
    KnownNodeSize["None"] = "None";
    KnownNodeSize["Small"] = "Small";
    KnownNodeSize["Medium"] = "Medium";
    KnownNodeSize["Large"] = "Large";
    KnownNodeSize["XLarge"] = "XLarge";
    KnownNodeSize["XXLarge"] = "XXLarge";
    KnownNodeSize["XXXLarge"] = "XXXLarge";
})(exports.KnownNodeSize || (exports.KnownNodeSize = {}));
(function (KnownNodeSizeFamily) {
    KnownNodeSizeFamily["None"] = "None";
    KnownNodeSizeFamily["MemoryOptimized"] = "MemoryOptimized";
    KnownNodeSizeFamily["HardwareAcceleratedFpga"] = "HardwareAcceleratedFPGA";
    KnownNodeSizeFamily["HardwareAcceleratedGPU"] = "HardwareAcceleratedGPU";
})(exports.KnownNodeSizeFamily || (exports.KnownNodeSizeFamily = {}));
(function (KnownIntegrationRuntimeAutoUpdate) {
    KnownIntegrationRuntimeAutoUpdate["On"] = "On";
    KnownIntegrationRuntimeAutoUpdate["Off"] = "Off";
})(exports.KnownIntegrationRuntimeAutoUpdate || (exports.KnownIntegrationRuntimeAutoUpdate = {}));
(function (KnownIntegrationRuntimeType) {
    KnownIntegrationRuntimeType["Managed"] = "Managed";
    KnownIntegrationRuntimeType["SelfHosted"] = "SelfHosted";
})(exports.KnownIntegrationRuntimeType || (exports.KnownIntegrationRuntimeType = {}));
(function (KnownSsisObjectMetadataType) {
    KnownSsisObjectMetadataType["Folder"] = "Folder";
    KnownSsisObjectMetadataType["Project"] = "Project";
    KnownSsisObjectMetadataType["Package"] = "Package";
    KnownSsisObjectMetadataType["Environment"] = "Environment";
})(exports.KnownSsisObjectMetadataType || (exports.KnownSsisObjectMetadataType = {}));
(function (KnownSelfHostedIntegrationRuntimeNodeStatus) {
    KnownSelfHostedIntegrationRuntimeNodeStatus["NeedRegistration"] = "NeedRegistration";
    KnownSelfHostedIntegrationRuntimeNodeStatus["Online"] = "Online";
    KnownSelfHostedIntegrationRuntimeNodeStatus["Limited"] = "Limited";
    KnownSelfHostedIntegrationRuntimeNodeStatus["Offline"] = "Offline";
    KnownSelfHostedIntegrationRuntimeNodeStatus["Upgrading"] = "Upgrading";
    KnownSelfHostedIntegrationRuntimeNodeStatus["Initializing"] = "Initializing";
    KnownSelfHostedIntegrationRuntimeNodeStatus["InitializeFailed"] = "InitializeFailed";
})(exports.KnownSelfHostedIntegrationRuntimeNodeStatus || (exports.KnownSelfHostedIntegrationRuntimeNodeStatus = {}));
(function (KnownIntegrationRuntimeUpdateResult) {
    KnownIntegrationRuntimeUpdateResult["None"] = "None";
    KnownIntegrationRuntimeUpdateResult["Succeed"] = "Succeed";
    KnownIntegrationRuntimeUpdateResult["Fail"] = "Fail";
})(exports.KnownIntegrationRuntimeUpdateResult || (exports.KnownIntegrationRuntimeUpdateResult = {}));
(function (KnownIntegrationRuntimeState) {
    KnownIntegrationRuntimeState["Initial"] = "Initial";
    KnownIntegrationRuntimeState["Stopped"] = "Stopped";
    KnownIntegrationRuntimeState["Started"] = "Started";
    KnownIntegrationRuntimeState["Starting"] = "Starting";
    KnownIntegrationRuntimeState["Stopping"] = "Stopping";
    KnownIntegrationRuntimeState["NeedRegistration"] = "NeedRegistration";
    KnownIntegrationRuntimeState["Online"] = "Online";
    KnownIntegrationRuntimeState["Limited"] = "Limited";
    KnownIntegrationRuntimeState["Offline"] = "Offline";
    KnownIntegrationRuntimeState["AccessDenied"] = "AccessDenied";
})(exports.KnownIntegrationRuntimeState || (exports.KnownIntegrationRuntimeState = {}));
(function (KnownIntegrationRuntimeAuthKeyName) {
    KnownIntegrationRuntimeAuthKeyName["AuthKey1"] = "authKey1";
    KnownIntegrationRuntimeAuthKeyName["AuthKey2"] = "authKey2";
})(exports.KnownIntegrationRuntimeAuthKeyName || (exports.KnownIntegrationRuntimeAuthKeyName = {}));
(function (KnownReason) {
    KnownReason["Invalid"] = "Invalid";
    KnownReason["AlreadyExists"] = "AlreadyExists";
})(exports.KnownReason || (exports.KnownReason = {}));
(function (KnownSkuName) {
    KnownSkuName["ComputeOptimized"] = "Compute optimized";
    KnownSkuName["StorageOptimized"] = "Storage optimized";
})(exports.KnownSkuName || (exports.KnownSkuName = {}));
(function (KnownSkuSize) {
    KnownSkuSize["ExtraSmall"] = "Extra small";
    KnownSkuSize["Small"] = "Small";
    KnownSkuSize["Medium"] = "Medium";
    KnownSkuSize["Large"] = "Large";
})(exports.KnownSkuSize || (exports.KnownSkuSize = {}));
(function (KnownState) {
    KnownState["Creating"] = "Creating";
    KnownState["Unavailable"] = "Unavailable";
    KnownState["Running"] = "Running";
    KnownState["Deleting"] = "Deleting";
    KnownState["Deleted"] = "Deleted";
    KnownState["Stopping"] = "Stopping";
    KnownState["Stopped"] = "Stopped";
    KnownState["Starting"] = "Starting";
    KnownState["Updating"] = "Updating";
})(exports.KnownState || (exports.KnownState = {}));
(function (KnownResourceProvisioningState) {
    KnownResourceProvisioningState["Running"] = "Running";
    KnownResourceProvisioningState["Creating"] = "Creating";
    KnownResourceProvisioningState["Deleting"] = "Deleting";
    KnownResourceProvisioningState["Succeeded"] = "Succeeded";
    KnownResourceProvisioningState["Failed"] = "Failed";
    KnownResourceProvisioningState["Moving"] = "Moving";
    KnownResourceProvisioningState["Canceled"] = "Canceled";
})(exports.KnownResourceProvisioningState || (exports.KnownResourceProvisioningState = {}));
(function (KnownLanguageExtensionName) {
    KnownLanguageExtensionName["Python"] = "PYTHON";
    KnownLanguageExtensionName["R"] = "R";
})(exports.KnownLanguageExtensionName || (exports.KnownLanguageExtensionName = {}));
(function (KnownCreatedByType) {
    KnownCreatedByType["User"] = "User";
    KnownCreatedByType["Application"] = "Application";
    KnownCreatedByType["ManagedIdentity"] = "ManagedIdentity";
    KnownCreatedByType["Key"] = "Key";
})(exports.KnownCreatedByType || (exports.KnownCreatedByType = {}));
(function (KnownAzureScaleType) {
    KnownAzureScaleType["Automatic"] = "automatic";
    KnownAzureScaleType["Manual"] = "manual";
    KnownAzureScaleType["None"] = "none";
})(exports.KnownAzureScaleType || (exports.KnownAzureScaleType = {}));
(function (KnownDefaultPrincipalsModificationKind) {
    KnownDefaultPrincipalsModificationKind["Union"] = "Union";
    KnownDefaultPrincipalsModificationKind["Replace"] = "Replace";
    KnownDefaultPrincipalsModificationKind["None"] = "None";
})(exports.KnownDefaultPrincipalsModificationKind || (exports.KnownDefaultPrincipalsModificationKind = {}));
(function (KnownKind) {
    KnownKind["ReadWrite"] = "ReadWrite";
    KnownKind["ReadOnlyFollowing"] = "ReadOnlyFollowing";
})(exports.KnownKind || (exports.KnownKind = {}));
(function (KnownDataConnectionKind) {
    KnownDataConnectionKind["EventHub"] = "EventHub";
    KnownDataConnectionKind["EventGrid"] = "EventGrid";
    KnownDataConnectionKind["IotHub"] = "IotHub";
})(exports.KnownDataConnectionKind || (exports.KnownDataConnectionKind = {}));
(function (KnownClusterPrincipalRole) {
    KnownClusterPrincipalRole["AllDatabasesAdmin"] = "AllDatabasesAdmin";
    KnownClusterPrincipalRole["AllDatabasesViewer"] = "AllDatabasesViewer";
})(exports.KnownClusterPrincipalRole || (exports.KnownClusterPrincipalRole = {}));
(function (KnownPrincipalType) {
    KnownPrincipalType["App"] = "App";
    KnownPrincipalType["Group"] = "Group";
    KnownPrincipalType["User"] = "User";
})(exports.KnownPrincipalType || (exports.KnownPrincipalType = {}));
(function (KnownDatabasePrincipalRole) {
    KnownDatabasePrincipalRole["Admin"] = "Admin";
    KnownDatabasePrincipalRole["Ingestor"] = "Ingestor";
    KnownDatabasePrincipalRole["Monitor"] = "Monitor";
    KnownDatabasePrincipalRole["User"] = "User";
    KnownDatabasePrincipalRole["UnrestrictedViewer"] = "UnrestrictedViewer";
    KnownDatabasePrincipalRole["Viewer"] = "Viewer";
})(exports.KnownDatabasePrincipalRole || (exports.KnownDatabasePrincipalRole = {}));
(function (KnownDataFlowComputeType) {
    KnownDataFlowComputeType["General"] = "General";
    KnownDataFlowComputeType["MemoryOptimized"] = "MemoryOptimized";
    KnownDataFlowComputeType["ComputeOptimized"] = "ComputeOptimized";
})(exports.KnownDataFlowComputeType || (exports.KnownDataFlowComputeType = {}));
(function (KnownIntegrationRuntimeSsisCatalogPricingTier) {
    KnownIntegrationRuntimeSsisCatalogPricingTier["Basic"] = "Basic";
    KnownIntegrationRuntimeSsisCatalogPricingTier["Standard"] = "Standard";
    KnownIntegrationRuntimeSsisCatalogPricingTier["Premium"] = "Premium";
    KnownIntegrationRuntimeSsisCatalogPricingTier["PremiumRS"] = "PremiumRS";
})(exports.KnownIntegrationRuntimeSsisCatalogPricingTier || (exports.KnownIntegrationRuntimeSsisCatalogPricingTier = {}));
(function (KnownIntegrationRuntimeLicenseType) {
    KnownIntegrationRuntimeLicenseType["BasePrice"] = "BasePrice";
    KnownIntegrationRuntimeLicenseType["LicenseIncluded"] = "LicenseIncluded";
})(exports.KnownIntegrationRuntimeLicenseType || (exports.KnownIntegrationRuntimeLicenseType = {}));
(function (KnownIntegrationRuntimeEntityReferenceType) {
    KnownIntegrationRuntimeEntityReferenceType["IntegrationRuntimeReference"] = "IntegrationRuntimeReference";
    KnownIntegrationRuntimeEntityReferenceType["LinkedServiceReference"] = "LinkedServiceReference";
})(exports.KnownIntegrationRuntimeEntityReferenceType || (exports.KnownIntegrationRuntimeEntityReferenceType = {}));
(function (KnownIntegrationRuntimeEdition) {
    KnownIntegrationRuntimeEdition["Standard"] = "Standard";
    KnownIntegrationRuntimeEdition["Enterprise"] = "Enterprise";
})(exports.KnownIntegrationRuntimeEdition || (exports.KnownIntegrationRuntimeEdition = {}));
(function (KnownManagedIntegrationRuntimeNodeStatus) {
    KnownManagedIntegrationRuntimeNodeStatus["Starting"] = "Starting";
    KnownManagedIntegrationRuntimeNodeStatus["Available"] = "Available";
    KnownManagedIntegrationRuntimeNodeStatus["Recycling"] = "Recycling";
    KnownManagedIntegrationRuntimeNodeStatus["Unavailable"] = "Unavailable";
})(exports.KnownManagedIntegrationRuntimeNodeStatus || (exports.KnownManagedIntegrationRuntimeNodeStatus = {}));
(function (KnownIntegrationRuntimeInternalChannelEncryptionMode) {
    KnownIntegrationRuntimeInternalChannelEncryptionMode["NotSet"] = "NotSet";
    KnownIntegrationRuntimeInternalChannelEncryptionMode["SslEncrypted"] = "SslEncrypted";
    KnownIntegrationRuntimeInternalChannelEncryptionMode["NotEncrypted"] = "NotEncrypted";
})(exports.KnownIntegrationRuntimeInternalChannelEncryptionMode || (exports.KnownIntegrationRuntimeInternalChannelEncryptionMode = {}));
(function (KnownPrincipalsModificationKind) {
    KnownPrincipalsModificationKind["Union"] = "Union";
    KnownPrincipalsModificationKind["Replace"] = "Replace";
    KnownPrincipalsModificationKind["None"] = "None";
})(exports.KnownPrincipalsModificationKind || (exports.KnownPrincipalsModificationKind = {}));
(function (KnownEventHubDataFormat) {
    KnownEventHubDataFormat["Multijson"] = "MULTIJSON";
    KnownEventHubDataFormat["Json"] = "JSON";
    KnownEventHubDataFormat["CSV"] = "CSV";
    KnownEventHubDataFormat["TSV"] = "TSV";
    KnownEventHubDataFormat["Scsv"] = "SCSV";
    KnownEventHubDataFormat["Sohsv"] = "SOHSV";
    KnownEventHubDataFormat["PSV"] = "PSV";
    KnownEventHubDataFormat["TXT"] = "TXT";
    KnownEventHubDataFormat["RAW"] = "RAW";
    KnownEventHubDataFormat["Singlejson"] = "SINGLEJSON";
    KnownEventHubDataFormat["Avro"] = "AVRO";
    KnownEventHubDataFormat["Tsve"] = "TSVE";
    KnownEventHubDataFormat["Parquet"] = "PARQUET";
    KnownEventHubDataFormat["ORC"] = "ORC";
    KnownEventHubDataFormat["Apacheavro"] = "APACHEAVRO";
    KnownEventHubDataFormat["W3Clogfile"] = "W3CLOGFILE";
})(exports.KnownEventHubDataFormat || (exports.KnownEventHubDataFormat = {}));
(function (KnownCompression) {
    KnownCompression["None"] = "None";
    KnownCompression["GZip"] = "GZip";
})(exports.KnownCompression || (exports.KnownCompression = {}));
(function (KnownIotHubDataFormat) {
    KnownIotHubDataFormat["Multijson"] = "MULTIJSON";
    KnownIotHubDataFormat["Json"] = "JSON";
    KnownIotHubDataFormat["CSV"] = "CSV";
    KnownIotHubDataFormat["TSV"] = "TSV";
    KnownIotHubDataFormat["Scsv"] = "SCSV";
    KnownIotHubDataFormat["Sohsv"] = "SOHSV";
    KnownIotHubDataFormat["PSV"] = "PSV";
    KnownIotHubDataFormat["TXT"] = "TXT";
    KnownIotHubDataFormat["RAW"] = "RAW";
    KnownIotHubDataFormat["Singlejson"] = "SINGLEJSON";
    KnownIotHubDataFormat["Avro"] = "AVRO";
    KnownIotHubDataFormat["Tsve"] = "TSVE";
    KnownIotHubDataFormat["Parquet"] = "PARQUET";
    KnownIotHubDataFormat["ORC"] = "ORC";
    KnownIotHubDataFormat["Apacheavro"] = "APACHEAVRO";
    KnownIotHubDataFormat["W3Clogfile"] = "W3CLOGFILE";
})(exports.KnownIotHubDataFormat || (exports.KnownIotHubDataFormat = {}));
(function (KnownEventGridDataFormat) {
    KnownEventGridDataFormat["Multijson"] = "MULTIJSON";
    KnownEventGridDataFormat["Json"] = "JSON";
    KnownEventGridDataFormat["CSV"] = "CSV";
    KnownEventGridDataFormat["TSV"] = "TSV";
    KnownEventGridDataFormat["Scsv"] = "SCSV";
    KnownEventGridDataFormat["Sohsv"] = "SOHSV";
    KnownEventGridDataFormat["PSV"] = "PSV";
    KnownEventGridDataFormat["TXT"] = "TXT";
    KnownEventGridDataFormat["RAW"] = "RAW";
    KnownEventGridDataFormat["Singlejson"] = "SINGLEJSON";
    KnownEventGridDataFormat["Avro"] = "AVRO";
    KnownEventGridDataFormat["Tsve"] = "TSVE";
    KnownEventGridDataFormat["Parquet"] = "PARQUET";
    KnownEventGridDataFormat["ORC"] = "ORC";
    KnownEventGridDataFormat["Apacheavro"] = "APACHEAVRO";
    KnownEventGridDataFormat["W3Clogfile"] = "W3CLOGFILE";
})(exports.KnownEventGridDataFormat || (exports.KnownEventGridDataFormat = {}));
(function (KnownBlobStorageEventType) {
    KnownBlobStorageEventType["MicrosoftStorageBlobCreated"] = "Microsoft.Storage.BlobCreated";
    KnownBlobStorageEventType["MicrosoftStorageBlobRenamed"] = "Microsoft.Storage.BlobRenamed";
})(exports.KnownBlobStorageEventType || (exports.KnownBlobStorageEventType = {}));

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const Resource = {
    type: {
        name: "Composite",
        className: "Resource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ErrorResponse = {
    type: {
        name: "Composite",
        className: "ErrorResponse",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorDetail"
                }
            }
        }
    }
};
const ErrorDetail = {
    type: {
        name: "Composite",
        className: "ErrorDetail",
        modelProperties: {
            code: {
                serializedName: "code",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorDetail"
                        }
                    }
                }
            },
            additionalInfo: {
                serializedName: "additionalInfo",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorAdditionalInfo"
                        }
                    }
                }
            }
        }
    }
};
const ErrorAdditionalInfo = {
    type: {
        name: "Composite",
        className: "ErrorAdditionalInfo",
        modelProperties: {
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            info: {
                serializedName: "info",
                readOnly: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            }
        }
    }
};
const AzureADOnlyAuthenticationListResult = {
    type: {
        name: "Composite",
        className: "AzureADOnlyAuthenticationListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AzureADOnlyAuthentication"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CheckNameAvailabilityRequest = {
    type: {
        name: "Composite",
        className: "CheckNameAvailabilityRequest",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CheckNameAvailabilityResponse = {
    type: {
        name: "Composite",
        className: "CheckNameAvailabilityResponse",
        modelProperties: {
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            },
            available: {
                serializedName: "available",
                type: {
                    name: "Boolean"
                }
            },
            reason: {
                serializedName: "reason",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IpFirewallRuleInfoListResult = {
    type: {
        name: "Composite",
        className: "IpFirewallRuleInfoListResult",
        modelProperties: {
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IpFirewallRuleInfo"
                        }
                    }
                }
            }
        }
    }
};
const IpFirewallRuleProperties = {
    type: {
        name: "Composite",
        className: "IpFirewallRuleProperties",
        modelProperties: {
            endIpAddress: {
                serializedName: "endIpAddress",
                type: {
                    name: "String"
                }
            },
            provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            startIpAddress: {
                serializedName: "startIpAddress",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ReplaceAllIpFirewallRulesRequest = {
    type: {
        name: "Composite",
        className: "ReplaceAllIpFirewallRulesRequest",
        modelProperties: {
            ipFirewallRules: {
                serializedName: "ipFirewallRules",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Composite", className: "IpFirewallRuleProperties" }
                    }
                }
            }
        }
    }
};
const ReplaceAllFirewallRulesOperationResponse = {
    type: {
        name: "Composite",
        className: "ReplaceAllFirewallRulesOperationResponse",
        modelProperties: {
            operationId: {
                serializedName: "operationId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const KeyInfoListResult = {
    type: {
        name: "Composite",
        className: "KeyInfoListResult",
        modelProperties: {
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Key"
                        }
                    }
                }
            }
        }
    }
};
const AvailableRpOperation = {
    type: {
        name: "Composite",
        className: "AvailableRpOperation",
        modelProperties: {
            display: {
                serializedName: "display",
                type: {
                    name: "Composite",
                    className: "AvailableRpOperationDisplayInfo"
                }
            },
            isDataAction: {
                serializedName: "isDataAction",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            origin: {
                serializedName: "origin",
                type: {
                    name: "String"
                }
            },
            serviceSpecification: {
                serializedName: "properties.serviceSpecification",
                type: {
                    name: "Composite",
                    className: "OperationMetaServiceSpecification"
                }
            }
        }
    }
};
const AvailableRpOperationDisplayInfo = {
    type: {
        name: "Composite",
        className: "AvailableRpOperationDisplayInfo",
        modelProperties: {
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            resource: {
                serializedName: "resource",
                type: {
                    name: "String"
                }
            },
            provider: {
                serializedName: "provider",
                type: {
                    name: "String"
                }
            },
            operation: {
                serializedName: "operation",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OperationMetaServiceSpecification = {
    type: {
        name: "Composite",
        className: "OperationMetaServiceSpecification",
        modelProperties: {
            metricSpecifications: {
                serializedName: "metricSpecifications",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "OperationMetaMetricSpecification"
                        }
                    }
                }
            },
            logSpecifications: {
                serializedName: "logSpecifications",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "OperationMetaLogSpecification"
                        }
                    }
                }
            }
        }
    }
};
const OperationMetaMetricSpecification = {
    type: {
        name: "Composite",
        className: "OperationMetaMetricSpecification",
        modelProperties: {
            sourceMdmNamespace: {
                serializedName: "sourceMdmNamespace",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            aggregationType: {
                serializedName: "aggregationType",
                type: {
                    name: "String"
                }
            },
            displayDescription: {
                serializedName: "displayDescription",
                type: {
                    name: "String"
                }
            },
            sourceMdmAccount: {
                serializedName: "sourceMdmAccount",
                type: {
                    name: "String"
                }
            },
            enableRegionalMdmAccount: {
                serializedName: "enableRegionalMdmAccount",
                type: {
                    name: "Boolean"
                }
            },
            unit: {
                serializedName: "unit",
                type: {
                    name: "String"
                }
            },
            dimensions: {
                serializedName: "dimensions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "OperationMetaMetricDimensionSpecification"
                        }
                    }
                }
            },
            supportsInstanceLevelAggregation: {
                serializedName: "supportsInstanceLevelAggregation",
                type: {
                    name: "Boolean"
                }
            },
            metricFilterPattern: {
                serializedName: "metricFilterPattern",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OperationMetaMetricDimensionSpecification = {
    type: {
        name: "Composite",
        className: "OperationMetaMetricDimensionSpecification",
        modelProperties: {
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            toBeExportedForShoebox: {
                serializedName: "toBeExportedForShoebox",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const OperationMetaLogSpecification = {
    type: {
        name: "Composite",
        className: "OperationMetaLogSpecification",
        modelProperties: {
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            blobDuration: {
                serializedName: "blobDuration",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OperationResource = {
    type: {
        name: "Composite",
        className: "OperationResource",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            },
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorDetail"
                }
            },
            startTime: {
                serializedName: "startTime",
                type: {
                    name: "DateTime"
                }
            },
            endTime: {
                serializedName: "endTime",
                type: {
                    name: "DateTime"
                }
            },
            percentComplete: {
                serializedName: "percentComplete",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const PrivateEndpointConnectionProperties = {
    type: {
        name: "Composite",
        className: "PrivateEndpointConnectionProperties",
        modelProperties: {
            privateEndpoint: {
                serializedName: "privateEndpoint",
                type: {
                    name: "Composite",
                    className: "PrivateEndpoint"
                }
            },
            privateLinkServiceConnectionState: {
                serializedName: "privateLinkServiceConnectionState",
                type: {
                    name: "Composite",
                    className: "PrivateLinkServiceConnectionState"
                }
            },
            provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateEndpoint = {
    type: {
        name: "Composite",
        className: "PrivateEndpoint",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateLinkServiceConnectionState = {
    type: {
        name: "Composite",
        className: "PrivateLinkServiceConnectionState",
        modelProperties: {
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            actionsRequired: {
                serializedName: "actionsRequired",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateEndpointConnectionList = {
    type: {
        name: "Composite",
        className: "PrivateEndpointConnectionList",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateEndpointConnection"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateLinkResourceListResult = {
    type: {
        name: "Composite",
        className: "PrivateLinkResourceListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateLinkResource"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateLinkResourceProperties = {
    type: {
        name: "Composite",
        className: "PrivateLinkResourceProperties",
        modelProperties: {
            groupId: {
                serializedName: "groupId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            requiredMembers: {
                serializedName: "requiredMembers",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            requiredZoneNames: {
                serializedName: "requiredZoneNames",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const PrivateLinkHubInfoListResult = {
    type: {
        name: "Composite",
        className: "PrivateLinkHubInfoListResult",
        modelProperties: {
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateLinkHub"
                        }
                    }
                }
            }
        }
    }
};
const PrivateEndpointConnectionForPrivateLinkHubBasic = {
    type: {
        name: "Composite",
        className: "PrivateEndpointConnectionForPrivateLinkHubBasic",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            privateEndpoint: {
                serializedName: "properties.privateEndpoint",
                type: {
                    name: "Composite",
                    className: "PrivateEndpoint"
                }
            },
            privateLinkServiceConnectionState: {
                serializedName: "properties.privateLinkServiceConnectionState",
                type: {
                    name: "Composite",
                    className: "PrivateLinkServiceConnectionState"
                }
            },
            provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateLinkHubPatchInfo = {
    type: {
        name: "Composite",
        className: "PrivateLinkHubPatchInfo",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const PrivateEndpointConnectionForPrivateLinkHubResourceCollectionResponse = {
    type: {
        name: "Composite",
        className: "PrivateEndpointConnectionForPrivateLinkHubResourceCollectionResponse",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateEndpointConnectionForPrivateLinkHub"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateEndpointConnectionForPrivateLinkHubBasicAutoGenerated = {
    type: {
        name: "Composite",
        className: "PrivateEndpointConnectionForPrivateLinkHubBasicAutoGenerated",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "PrivateEndpointConnectionProperties"
                }
            }
        }
    }
};
const Sku = {
    type: {
        name: "Composite",
        className: "Sku",
        modelProperties: {
            tier: {
                serializedName: "tier",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            capacity: {
                serializedName: "capacity",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const SqlPoolPatchInfo = {
    type: {
        name: "Composite",
        className: "SqlPoolPatchInfo",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "Sku"
                }
            },
            maxSizeBytes: {
                serializedName: "properties.maxSizeBytes",
                type: {
                    name: "Number"
                }
            },
            collation: {
                defaultValue: "",
                serializedName: "properties.collation",
                type: {
                    name: "String"
                }
            },
            sourceDatabaseId: {
                serializedName: "properties.sourceDatabaseId",
                type: {
                    name: "String"
                }
            },
            recoverableDatabaseId: {
                serializedName: "properties.recoverableDatabaseId",
                type: {
                    name: "String"
                }
            },
            provisioningState: {
                serializedName: "properties.provisioningState",
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "properties.status",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            restorePointInTime: {
                serializedName: "properties.restorePointInTime",
                type: {
                    name: "DateTime"
                }
            },
            createMode: {
                serializedName: "properties.createMode",
                type: {
                    name: "String"
                }
            },
            creationDate: {
                serializedName: "properties.creationDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            storageAccountType: {
                defaultValue: "GRS",
                serializedName: "properties.storageAccountType",
                type: {
                    name: "String"
                }
            },
            sourceDatabaseDeletionDate: {
                serializedName: "properties.sourceDatabaseDeletionDate",
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const SqlPoolInfoListResult = {
    type: {
        name: "Composite",
        className: "SqlPoolInfoListResult",
        modelProperties: {
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SqlPool"
                        }
                    }
                }
            }
        }
    }
};
const ResourceMoveDefinition = {
    type: {
        name: "Composite",
        className: "ResourceMoveDefinition",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GeoBackupPolicyListResult = {
    type: {
        name: "Composite",
        className: "GeoBackupPolicyListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "GeoBackupPolicy"
                        }
                    }
                }
            }
        }
    }
};
const RestorePointListResult = {
    type: {
        name: "Composite",
        className: "RestorePointListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RestorePoint"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CreateSqlPoolRestorePointDefinition = {
    type: {
        name: "Composite",
        className: "CreateSqlPoolRestorePointDefinition",
        modelProperties: {
            restorePointLabel: {
                serializedName: "restorePointLabel",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ReplicationLinkListResult = {
    type: {
        name: "Composite",
        className: "ReplicationLinkListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ReplicationLink"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MaintenanceWindowTimeRange = {
    type: {
        name: "Composite",
        className: "MaintenanceWindowTimeRange",
        modelProperties: {
            dayOfWeek: {
                serializedName: "dayOfWeek",
                type: {
                    name: "String"
                }
            },
            startTime: {
                serializedName: "startTime",
                type: {
                    name: "String"
                }
            },
            duration: {
                serializedName: "duration",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TransparentDataEncryptionListResult = {
    type: {
        name: "Composite",
        className: "TransparentDataEncryptionListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TransparentDataEncryption"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SqlPoolBlobAuditingPolicySqlPoolOperationListResult = {
    type: {
        name: "Composite",
        className: "SqlPoolBlobAuditingPolicySqlPoolOperationListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SqlPoolOperation"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SqlPoolUsageListResult = {
    type: {
        name: "Composite",
        className: "SqlPoolUsageListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SqlPoolUsage"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SqlPoolUsage = {
    type: {
        name: "Composite",
        className: "SqlPoolUsage",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            resourceName: {
                serializedName: "resourceName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            currentValue: {
                serializedName: "currentValue",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            limit: {
                serializedName: "limit",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            unit: {
                serializedName: "unit",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            nextResetTime: {
                serializedName: "nextResetTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const SensitivityLabelListResult = {
    type: {
        name: "Composite",
        className: "SensitivityLabelListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SensitivityLabel"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SensitivityLabelUpdateList = {
    type: {
        name: "Composite",
        className: "SensitivityLabelUpdateList",
        modelProperties: {
            operations: {
                serializedName: "operations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SensitivityLabelUpdate"
                        }
                    }
                }
            }
        }
    }
};
const RecommendedSensitivityLabelUpdateList = {
    type: {
        name: "Composite",
        className: "RecommendedSensitivityLabelUpdateList",
        modelProperties: {
            operations: {
                serializedName: "operations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RecommendedSensitivityLabelUpdate"
                        }
                    }
                }
            }
        }
    }
};
const SqlPoolSchemaListResult = {
    type: {
        name: "Composite",
        className: "SqlPoolSchemaListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SqlPoolSchema"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SqlPoolTableListResult = {
    type: {
        name: "Composite",
        className: "SqlPoolTableListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SqlPoolTable"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SqlPoolColumnListResult = {
    type: {
        name: "Composite",
        className: "SqlPoolColumnListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SqlPoolColumn"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SqlPoolVulnerabilityAssessmentListResult = {
    type: {
        name: "Composite",
        className: "SqlPoolVulnerabilityAssessmentListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SqlPoolVulnerabilityAssessment"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VulnerabilityAssessmentRecurringScansProperties = {
    type: {
        name: "Composite",
        className: "VulnerabilityAssessmentRecurringScansProperties",
        modelProperties: {
            isEnabled: {
                serializedName: "isEnabled",
                type: {
                    name: "Boolean"
                }
            },
            emailSubscriptionAdmins: {
                defaultValue: true,
                serializedName: "emailSubscriptionAdmins",
                type: {
                    name: "Boolean"
                }
            },
            emails: {
                serializedName: "emails",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const VulnerabilityAssessmentScanRecordListResult = {
    type: {
        name: "Composite",
        className: "VulnerabilityAssessmentScanRecordListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VulnerabilityAssessmentScanRecord"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VulnerabilityAssessmentScanError = {
    type: {
        name: "Composite",
        className: "VulnerabilityAssessmentScanError",
        modelProperties: {
            code: {
                serializedName: "code",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ListSqlPoolSecurityAlertPolicies = {
    type: {
        name: "Composite",
        className: "ListSqlPoolSecurityAlertPolicies",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SqlPoolSecurityAlertPolicy"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SqlPoolVulnerabilityAssessmentRuleBaselineItem = {
    type: {
        name: "Composite",
        className: "SqlPoolVulnerabilityAssessmentRuleBaselineItem",
        modelProperties: {
            result: {
                serializedName: "result",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const ExtendedSqlPoolBlobAuditingPolicyListResult = {
    type: {
        name: "Composite",
        className: "ExtendedSqlPoolBlobAuditingPolicyListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExtendedSqlPoolBlobAuditingPolicy"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DataMaskingRuleListResult = {
    type: {
        name: "Composite",
        className: "DataMaskingRuleListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DataMaskingRule"
                        }
                    }
                }
            }
        }
    }
};
const SqlPoolBlobAuditingPolicyListResult = {
    type: {
        name: "Composite",
        className: "SqlPoolBlobAuditingPolicyListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SqlPoolBlobAuditingPolicy"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WorkloadGroupListResult = {
    type: {
        name: "Composite",
        className: "WorkloadGroupListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "WorkloadGroup"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WorkloadClassifierListResult = {
    type: {
        name: "Composite",
        className: "WorkloadClassifierListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "WorkloadClassifier"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ServerBlobAuditingPolicyListResult = {
    type: {
        name: "Composite",
        className: "ServerBlobAuditingPolicyListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ServerBlobAuditingPolicy"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExtendedServerBlobAuditingPolicyListResult = {
    type: {
        name: "Composite",
        className: "ExtendedServerBlobAuditingPolicyListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExtendedServerBlobAuditingPolicy"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ServerSecurityAlertPolicyListResult = {
    type: {
        name: "Composite",
        className: "ServerSecurityAlertPolicyListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ServerSecurityAlertPolicy"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ServerVulnerabilityAssessmentListResult = {
    type: {
        name: "Composite",
        className: "ServerVulnerabilityAssessmentListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ServerVulnerabilityAssessment"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EncryptionProtectorListResult = {
    type: {
        name: "Composite",
        className: "EncryptionProtectorListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "EncryptionProtector"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ServerUsageListResult = {
    type: {
        name: "Composite",
        className: "ServerUsageListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ServerUsage"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ServerUsage = {
    type: {
        name: "Composite",
        className: "ServerUsage",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            resourceName: {
                serializedName: "resourceName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            currentValue: {
                serializedName: "currentValue",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            limit: {
                serializedName: "limit",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            unit: {
                serializedName: "unit",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            nextResetTime: {
                serializedName: "nextResetTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const RecoverableSqlPoolListResult = {
    type: {
        name: "Composite",
        className: "RecoverableSqlPoolListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RecoverableSqlPool"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WorkspaceInfoListResult = {
    type: {
        name: "Composite",
        className: "WorkspaceInfoListResult",
        modelProperties: {
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Workspace"
                        }
                    }
                }
            }
        }
    }
};
const DataLakeStorageAccountDetails = {
    type: {
        name: "Composite",
        className: "DataLakeStorageAccountDetails",
        modelProperties: {
            accountUrl: {
                serializedName: "accountUrl",
                type: {
                    name: "String"
                }
            },
            filesystem: {
                serializedName: "filesystem",
                type: {
                    name: "String"
                }
            },
            resourceId: {
                serializedName: "resourceId",
                type: {
                    name: "String"
                }
            },
            createManagedPrivateEndpoint: {
                serializedName: "createManagedPrivateEndpoint",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const VirtualNetworkProfile = {
    type: {
        name: "Composite",
        className: "VirtualNetworkProfile",
        modelProperties: {
            computeSubnetId: {
                serializedName: "computeSubnetId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EncryptionDetails = {
    type: {
        name: "Composite",
        className: "EncryptionDetails",
        modelProperties: {
            doubleEncryptionEnabled: {
                serializedName: "doubleEncryptionEnabled",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            cmk: {
                serializedName: "cmk",
                type: {
                    name: "Composite",
                    className: "CustomerManagedKeyDetails"
                }
            }
        }
    }
};
const CustomerManagedKeyDetails = {
    type: {
        name: "Composite",
        className: "CustomerManagedKeyDetails",
        modelProperties: {
            status: {
                serializedName: "status",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            key: {
                serializedName: "key",
                type: {
                    name: "Composite",
                    className: "WorkspaceKeyDetails"
                }
            },
            kekIdentity: {
                serializedName: "kekIdentity",
                type: {
                    name: "Composite",
                    className: "KekIdentityProperties"
                }
            }
        }
    }
};
const WorkspaceKeyDetails = {
    type: {
        name: "Composite",
        className: "WorkspaceKeyDetails",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            keyVaultUrl: {
                serializedName: "keyVaultUrl",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const KekIdentityProperties = {
    type: {
        name: "Composite",
        className: "KekIdentityProperties",
        modelProperties: {
            userAssignedIdentity: {
                serializedName: "userAssignedIdentity",
                type: {
                    name: "String"
                }
            },
            useSystemAssignedIdentity: {
                serializedName: "useSystemAssignedIdentity",
                type: {
                    name: "any"
                }
            }
        }
    }
};
const ManagedVirtualNetworkSettings = {
    type: {
        name: "Composite",
        className: "ManagedVirtualNetworkSettings",
        modelProperties: {
            preventDataExfiltration: {
                serializedName: "preventDataExfiltration",
                type: {
                    name: "Boolean"
                }
            },
            linkedAccessCheckOnTargetResource: {
                serializedName: "linkedAccessCheckOnTargetResource",
                type: {
                    name: "Boolean"
                }
            },
            allowedAadTenantIdsForLinking: {
                serializedName: "allowedAadTenantIdsForLinking",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const WorkspaceRepositoryConfiguration = {
    type: {
        name: "Composite",
        className: "WorkspaceRepositoryConfiguration",
        modelProperties: {
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            hostName: {
                serializedName: "hostName",
                type: {
                    name: "String"
                }
            },
            accountName: {
                serializedName: "accountName",
                type: {
                    name: "String"
                }
            },
            projectName: {
                serializedName: "projectName",
                type: {
                    name: "String"
                }
            },
            repositoryName: {
                serializedName: "repositoryName",
                type: {
                    name: "String"
                }
            },
            collaborationBranch: {
                serializedName: "collaborationBranch",
                type: {
                    name: "String"
                }
            },
            rootFolder: {
                serializedName: "rootFolder",
                type: {
                    name: "String"
                }
            },
            lastCommitId: {
                serializedName: "lastCommitId",
                type: {
                    name: "String"
                }
            },
            tenantId: {
                serializedName: "tenantId",
                type: {
                    name: "Uuid"
                }
            }
        }
    }
};
const PurviewConfiguration = {
    type: {
        name: "Composite",
        className: "PurviewConfiguration",
        modelProperties: {
            purviewResourceId: {
                serializedName: "purviewResourceId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CspWorkspaceAdminProperties = {
    type: {
        name: "Composite",
        className: "CspWorkspaceAdminProperties",
        modelProperties: {
            initialWorkspaceAdminObjectId: {
                serializedName: "initialWorkspaceAdminObjectId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ManagedIdentity = {
    type: {
        name: "Composite",
        className: "ManagedIdentity",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            tenantId: {
                serializedName: "tenantId",
                readOnly: true,
                type: {
                    name: "Uuid"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "None",
                        "SystemAssigned",
                        "SystemAssigned,UserAssigned"
                    ]
                }
            },
            userAssignedIdentities: {
                serializedName: "userAssignedIdentities",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "Composite",
                            className: "UserAssignedManagedIdentity"
                        }
                    }
                }
            }
        }
    }
};
const UserAssignedManagedIdentity = {
    type: {
        name: "Composite",
        className: "UserAssignedManagedIdentity",
        modelProperties: {
            clientId: {
                serializedName: "clientId",
                readOnly: true,
                nullable: true,
                type: {
                    name: "Uuid"
                }
            },
            principalId: {
                serializedName: "principalId",
                readOnly: true,
                nullable: true,
                type: {
                    name: "Uuid"
                }
            }
        }
    }
};
const WorkspacePatchInfo = {
    type: {
        name: "Composite",
        className: "WorkspacePatchInfo",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "ManagedIdentity"
                }
            },
            sqlAdministratorLoginPassword: {
                serializedName: "properties.sqlAdministratorLoginPassword",
                type: {
                    name: "String"
                }
            },
            managedVirtualNetworkSettings: {
                serializedName: "properties.managedVirtualNetworkSettings",
                type: {
                    name: "Composite",
                    className: "ManagedVirtualNetworkSettings"
                }
            },
            workspaceRepositoryConfiguration: {
                serializedName: "properties.workspaceRepositoryConfiguration",
                type: {
                    name: "Composite",
                    className: "WorkspaceRepositoryConfiguration"
                }
            },
            purviewConfiguration: {
                serializedName: "properties.purviewConfiguration",
                type: {
                    name: "Composite",
                    className: "PurviewConfiguration"
                }
            },
            provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            encryption: {
                serializedName: "properties.encryption",
                type: {
                    name: "Composite",
                    className: "EncryptionDetails"
                }
            },
            publicNetworkAccess: {
                serializedName: "properties.publicNetworkAccess",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ManagedIdentitySqlControlSettingsModelPropertiesGrantSqlControlToManagedIdentity = {
    type: {
        name: "Composite",
        className: "ManagedIdentitySqlControlSettingsModelPropertiesGrantSqlControlToManagedIdentity",
        modelProperties: {
            desiredState: {
                serializedName: "desiredState",
                type: {
                    name: "String"
                }
            },
            actualState: {
                serializedName: "actualState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RestorableDroppedSqlPoolListResult = {
    type: {
        name: "Composite",
        className: "RestorableDroppedSqlPoolListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RestorableDroppedSqlPool"
                        }
                    }
                }
            }
        }
    }
};
const AutoScaleProperties = {
    type: {
        name: "Composite",
        className: "AutoScaleProperties",
        modelProperties: {
            minNodeCount: {
                serializedName: "minNodeCount",
                type: {
                    name: "Number"
                }
            },
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean"
                }
            },
            maxNodeCount: {
                serializedName: "maxNodeCount",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const AutoPauseProperties = {
    type: {
        name: "Composite",
        className: "AutoPauseProperties",
        modelProperties: {
            delayInMinutes: {
                serializedName: "delayInMinutes",
                type: {
                    name: "Number"
                }
            },
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const DynamicExecutorAllocation = {
    type: {
        name: "Composite",
        className: "DynamicExecutorAllocation",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean"
                }
            },
            minExecutors: {
                serializedName: "minExecutors",
                type: {
                    name: "Number"
                }
            },
            maxExecutors: {
                serializedName: "maxExecutors",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const LibraryRequirements = {
    type: {
        name: "Composite",
        className: "LibraryRequirements",
        modelProperties: {
            time: {
                serializedName: "time",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            content: {
                serializedName: "content",
                type: {
                    name: "String"
                }
            },
            filename: {
                serializedName: "filename",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LibraryInfo = {
    type: {
        name: "Composite",
        className: "LibraryInfo",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            path: {
                serializedName: "path",
                type: {
                    name: "String"
                }
            },
            containerName: {
                serializedName: "containerName",
                type: {
                    name: "String"
                }
            },
            uploadedTimestamp: {
                serializedName: "uploadedTimestamp",
                type: {
                    name: "DateTime"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            provisioningStatus: {
                serializedName: "provisioningStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            creatorId: {
                serializedName: "creatorId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SparkConfigProperties = {
    type: {
        name: "Composite",
        className: "SparkConfigProperties",
        modelProperties: {
            time: {
                serializedName: "time",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            content: {
                serializedName: "content",
                type: {
                    name: "String"
                }
            },
            filename: {
                serializedName: "filename",
                type: {
                    name: "String"
                }
            },
            configurationType: {
                serializedName: "configurationType",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BigDataPoolPatchInfo = {
    type: {
        name: "Composite",
        className: "BigDataPoolPatchInfo",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const BigDataPoolResourceInfoListResult = {
    type: {
        name: "Composite",
        className: "BigDataPoolResourceInfoListResult",
        modelProperties: {
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BigDataPoolResourceInfo"
                        }
                    }
                }
            }
        }
    }
};
const LibraryListResponse = {
    type: {
        name: "Composite",
        className: "LibraryListResponse",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LibraryResource"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const UpdateIntegrationRuntimeRequest = {
    type: {
        name: "Composite",
        className: "UpdateIntegrationRuntimeRequest",
        modelProperties: {
            autoUpdate: {
                serializedName: "autoUpdate",
                type: {
                    name: "String"
                }
            },
            updateDelayOffset: {
                serializedName: "updateDelayOffset",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IntegrationRuntime = {
    serializedName: "IntegrationRuntime",
    type: {
        name: "Composite",
        className: "IntegrationRuntime",
        uberParent: "IntegrationRuntime",
        additionalProperties: { type: { name: "Object" } },
        polymorphicDiscriminator: {
            serializedName: "type",
            clientName: "type"
        },
        modelProperties: {
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IntegrationRuntimeNodeIpAddress = {
    type: {
        name: "Composite",
        className: "IntegrationRuntimeNodeIpAddress",
        modelProperties: {
            ipAddress: {
                serializedName: "ipAddress",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GetSsisObjectMetadataRequest = {
    type: {
        name: "Composite",
        className: "GetSsisObjectMetadataRequest",
        modelProperties: {
            metadataPath: {
                serializedName: "metadataPath",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SsisObjectMetadataListResponse = {
    type: {
        name: "Composite",
        className: "SsisObjectMetadataListResponse",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SsisObjectMetadata"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SsisObjectMetadata = {
    type: {
        name: "Composite",
        className: "SsisObjectMetadata",
        uberParent: "SsisObjectMetadata",
        polymorphicDiscriminator: {
            serializedName: "type",
            clientName: "type"
        },
        modelProperties: {
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                type: {
                    name: "Number"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SelfHostedIntegrationRuntimeNode = {
    type: {
        name: "Composite",
        className: "SelfHostedIntegrationRuntimeNode",
        additionalProperties: { type: { name: "Object" } },
        modelProperties: {
            nodeName: {
                serializedName: "nodeName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            machineName: {
                serializedName: "machineName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            hostServiceUri: {
                serializedName: "hostServiceUri",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            capabilities: {
                serializedName: "capabilities",
                readOnly: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            versionStatus: {
                serializedName: "versionStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "version",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            registerTime: {
                serializedName: "registerTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            lastConnectTime: {
                serializedName: "lastConnectTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            expiryTime: {
                serializedName: "expiryTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            lastStartTime: {
                serializedName: "lastStartTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            lastStopTime: {
                serializedName: "lastStopTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            lastUpdateResult: {
                serializedName: "lastUpdateResult",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            lastStartUpdateTime: {
                serializedName: "lastStartUpdateTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            lastEndUpdateTime: {
                serializedName: "lastEndUpdateTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            isActiveDispatcher: {
                serializedName: "isActiveDispatcher",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            concurrentJobsLimit: {
                serializedName: "concurrentJobsLimit",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            maxConcurrentJobs: {
                serializedName: "maxConcurrentJobs",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const UpdateIntegrationRuntimeNodeRequest = {
    type: {
        name: "Composite",
        className: "UpdateIntegrationRuntimeNodeRequest",
        modelProperties: {
            concurrentJobsLimit: {
                constraints: {
                    InclusiveMinimum: 1
                },
                serializedName: "concurrentJobsLimit",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const IntegrationRuntimeListResponse = {
    type: {
        name: "Composite",
        className: "IntegrationRuntimeListResponse",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IntegrationRuntimeResource"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IntegrationRuntimeConnectionInfo = {
    type: {
        name: "Composite",
        className: "IntegrationRuntimeConnectionInfo",
        additionalProperties: { type: { name: "Object" } },
        modelProperties: {
            serviceToken: {
                serializedName: "serviceToken",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            identityCertThumbprint: {
                serializedName: "identityCertThumbprint",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            hostServiceUri: {
                serializedName: "hostServiceUri",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "version",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            publicKey: {
                serializedName: "publicKey",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            isIdentityCertExprired: {
                serializedName: "isIdentityCertExprired",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const IntegrationRuntimeStatusResponse = {
    type: {
        name: "Composite",
        className: "IntegrationRuntimeStatusResponse",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "IntegrationRuntimeStatus"
                }
            }
        }
    }
};
const IntegrationRuntimeStatus = {
    serializedName: "IntegrationRuntimeStatus",
    type: {
        name: "Composite",
        className: "IntegrationRuntimeStatus",
        uberParent: "IntegrationRuntimeStatus",
        additionalProperties: { type: { name: "Object" } },
        polymorphicDiscriminator: {
            serializedName: "type",
            clientName: "type"
        },
        modelProperties: {
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String"
                }
            },
            dataFactoryName: {
                serializedName: "dataFactoryName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            state: {
                serializedName: "state",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IntegrationRuntimeRegenerateKeyParameters = {
    type: {
        name: "Composite",
        className: "IntegrationRuntimeRegenerateKeyParameters",
        modelProperties: {
            keyName: {
                serializedName: "keyName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IntegrationRuntimeAuthKeys = {
    type: {
        name: "Composite",
        className: "IntegrationRuntimeAuthKeys",
        modelProperties: {
            authKey1: {
                serializedName: "authKey1",
                type: {
                    name: "String"
                }
            },
            authKey2: {
                serializedName: "authKey2",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IntegrationRuntimeMonitoringData = {
    type: {
        name: "Composite",
        className: "IntegrationRuntimeMonitoringData",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            nodes: {
                serializedName: "nodes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IntegrationRuntimeNodeMonitoringData"
                        }
                    }
                }
            }
        }
    }
};
const IntegrationRuntimeNodeMonitoringData = {
    type: {
        name: "Composite",
        className: "IntegrationRuntimeNodeMonitoringData",
        additionalProperties: { type: { name: "Object" } },
        modelProperties: {
            nodeName: {
                serializedName: "nodeName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            availableMemoryInMB: {
                serializedName: "availableMemoryInMB",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            cpuUtilization: {
                serializedName: "cpuUtilization",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            concurrentJobsLimit: {
                serializedName: "concurrentJobsLimit",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            concurrentJobsRunning: {
                serializedName: "concurrentJobsRunning",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            maxConcurrentJobs: {
                serializedName: "maxConcurrentJobs",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            sentBytes: {
                serializedName: "sentBytes",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            receivedBytes: {
                serializedName: "receivedBytes",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const SsisObjectMetadataStatusResponse = {
    type: {
        name: "Composite",
        className: "SsisObjectMetadataStatusResponse",
        modelProperties: {
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "String"
                }
            },
            error: {
                serializedName: "error",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IntegrationRuntimeOutboundNetworkDependenciesEndpointsResponse = {
    type: {
        name: "Composite",
        className: "IntegrationRuntimeOutboundNetworkDependenciesEndpointsResponse",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IntegrationRuntimeOutboundNetworkDependenciesCategoryEndpoint"
                        }
                    }
                }
            }
        }
    }
};
const IntegrationRuntimeOutboundNetworkDependenciesCategoryEndpoint = {
    type: {
        name: "Composite",
        className: "IntegrationRuntimeOutboundNetworkDependenciesCategoryEndpoint",
        modelProperties: {
            category: {
                serializedName: "category",
                type: {
                    name: "String"
                }
            },
            endpoints: {
                serializedName: "endpoints",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IntegrationRuntimeOutboundNetworkDependenciesEndpoint"
                        }
                    }
                }
            }
        }
    }
};
const IntegrationRuntimeOutboundNetworkDependenciesEndpoint = {
    type: {
        name: "Composite",
        className: "IntegrationRuntimeOutboundNetworkDependenciesEndpoint",
        modelProperties: {
            domainName: {
                serializedName: "domainName",
                type: {
                    name: "String"
                }
            },
            endpointDetails: {
                serializedName: "endpointDetails",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IntegrationRuntimeOutboundNetworkDependenciesEndpointDetails"
                        }
                    }
                }
            }
        }
    }
};
const IntegrationRuntimeOutboundNetworkDependenciesEndpointDetails = {
    type: {
        name: "Composite",
        className: "IntegrationRuntimeOutboundNetworkDependenciesEndpointDetails",
        modelProperties: {
            port: {
                serializedName: "port",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const SparkConfigurationListResponse = {
    type: {
        name: "Composite",
        className: "SparkConfigurationListResponse",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SparkConfigurationResource"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OperationListResult = {
    type: {
        name: "Composite",
        className: "OperationListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Operation"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Operation = {
    type: {
        name: "Composite",
        className: "Operation",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            display: {
                serializedName: "display",
                type: {
                    name: "Composite",
                    className: "OperationDisplay"
                }
            },
            origin: {
                serializedName: "origin",
                type: {
                    name: "String"
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            }
        }
    }
};
const OperationDisplay = {
    type: {
        name: "Composite",
        className: "OperationDisplay",
        modelProperties: {
            provider: {
                serializedName: "provider",
                type: {
                    name: "String"
                }
            },
            operation: {
                serializedName: "operation",
                type: {
                    name: "String"
                }
            },
            resource: {
                serializedName: "resource",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SkuDescriptionList = {
    type: {
        name: "Composite",
        className: "SkuDescriptionList",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SkuDescription"
                        }
                    }
                }
            }
        }
    }
};
const SkuDescription = {
    type: {
        name: "Composite",
        className: "SkuDescription",
        modelProperties: {
            resourceType: {
                serializedName: "resourceType",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            size: {
                serializedName: "size",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            locations: {
                serializedName: "locations",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            locationInfo: {
                serializedName: "locationInfo",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SkuLocationInfoItem"
                        }
                    }
                }
            },
            restrictions: {
                serializedName: "restrictions",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Dictionary",
                            value: { type: { name: "any" } }
                        }
                    }
                }
            }
        }
    }
};
const SkuLocationInfoItem = {
    type: {
        name: "Composite",
        className: "SkuLocationInfoItem",
        modelProperties: {
            location: {
                serializedName: "location",
                required: true,
                type: {
                    name: "String"
                }
            },
            zones: {
                serializedName: "zones",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const KustoPoolCheckNameRequest = {
    type: {
        name: "Composite",
        className: "KustoPoolCheckNameRequest",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            type: {
                defaultValue: "Microsoft.Synapse/workspaces/kustoPools",
                isConstant: true,
                serializedName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CheckNameResult = {
    type: {
        name: "Composite",
        className: "CheckNameResult",
        modelProperties: {
            nameAvailable: {
                serializedName: "nameAvailable",
                type: {
                    name: "Boolean"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            },
            reason: {
                serializedName: "reason",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const KustoPoolListResult = {
    type: {
        name: "Composite",
        className: "KustoPoolListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "KustoPool"
                        }
                    }
                }
            }
        }
    }
};
const AzureSku = {
    type: {
        name: "Composite",
        className: "AzureSku",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            capacity: {
                serializedName: "capacity",
                type: {
                    name: "Number"
                }
            },
            size: {
                serializedName: "size",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OptimizedAutoscale = {
    type: {
        name: "Composite",
        className: "OptimizedAutoscale",
        modelProperties: {
            version: {
                serializedName: "version",
                required: true,
                type: {
                    name: "Number"
                }
            },
            isEnabled: {
                serializedName: "isEnabled",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            minimum: {
                serializedName: "minimum",
                required: true,
                type: {
                    name: "Number"
                }
            },
            maximum: {
                serializedName: "maximum",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const LanguageExtensionsList = {
    type: {
        name: "Composite",
        className: "LanguageExtensionsList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LanguageExtension"
                        }
                    }
                }
            }
        }
    }
};
const LanguageExtension = {
    type: {
        name: "Composite",
        className: "LanguageExtension",
        modelProperties: {
            languageExtensionName: {
                serializedName: "languageExtensionName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SystemData = {
    type: {
        name: "Composite",
        className: "SystemData",
        modelProperties: {
            createdBy: {
                serializedName: "createdBy",
                type: {
                    name: "String"
                }
            },
            createdByType: {
                serializedName: "createdByType",
                type: {
                    name: "String"
                }
            },
            createdAt: {
                serializedName: "createdAt",
                type: {
                    name: "DateTime"
                }
            },
            lastModifiedBy: {
                serializedName: "lastModifiedBy",
                type: {
                    name: "String"
                }
            },
            lastModifiedByType: {
                serializedName: "lastModifiedByType",
                type: {
                    name: "String"
                }
            },
            lastModifiedAt: {
                serializedName: "lastModifiedAt",
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const ListResourceSkusResult = {
    type: {
        name: "Composite",
        className: "ListResourceSkusResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AzureResourceSku"
                        }
                    }
                }
            }
        }
    }
};
const AzureResourceSku = {
    type: {
        name: "Composite",
        className: "AzureResourceSku",
        modelProperties: {
            resourceType: {
                serializedName: "resourceType",
                type: {
                    name: "String"
                }
            },
            sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "AzureSku"
                }
            },
            capacity: {
                serializedName: "capacity",
                type: {
                    name: "Composite",
                    className: "AzureCapacity"
                }
            }
        }
    }
};
const AzureCapacity = {
    type: {
        name: "Composite",
        className: "AzureCapacity",
        modelProperties: {
            scaleType: {
                serializedName: "scaleType",
                required: true,
                type: {
                    name: "String"
                }
            },
            minimum: {
                serializedName: "minimum",
                required: true,
                type: {
                    name: "Number"
                }
            },
            maximum: {
                serializedName: "maximum",
                required: true,
                type: {
                    name: "Number"
                }
            },
            default: {
                serializedName: "default",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const DatabaseCheckNameRequest = {
    type: {
        name: "Composite",
        className: "DatabaseCheckNameRequest",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Microsoft.Synapse/workspaces/kustoPools/databases",
                        "Microsoft.Synapse/workspaces/kustoPools/attachedDatabaseConfigurations"
                    ]
                }
            }
        }
    }
};
const FollowerDatabaseListResult = {
    type: {
        name: "Composite",
        className: "FollowerDatabaseListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FollowerDatabaseDefinition"
                        }
                    }
                }
            }
        }
    }
};
const FollowerDatabaseDefinition = {
    type: {
        name: "Composite",
        className: "FollowerDatabaseDefinition",
        modelProperties: {
            kustoPoolResourceId: {
                serializedName: "clusterResourceId",
                required: true,
                type: {
                    name: "String"
                }
            },
            attachedDatabaseConfigurationName: {
                serializedName: "attachedDatabaseConfigurationName",
                required: true,
                type: {
                    name: "String"
                }
            },
            databaseName: {
                serializedName: "databaseName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AttachedDatabaseConfigurationListResult = {
    type: {
        name: "Composite",
        className: "AttachedDatabaseConfigurationListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AttachedDatabaseConfiguration"
                        }
                    }
                }
            }
        }
    }
};
const TableLevelSharingProperties = {
    type: {
        name: "Composite",
        className: "TableLevelSharingProperties",
        modelProperties: {
            tablesToInclude: {
                serializedName: "tablesToInclude",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            tablesToExclude: {
                serializedName: "tablesToExclude",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            externalTablesToInclude: {
                serializedName: "externalTablesToInclude",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            externalTablesToExclude: {
                serializedName: "externalTablesToExclude",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            materializedViewsToInclude: {
                serializedName: "materializedViewsToInclude",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            materializedViewsToExclude: {
                serializedName: "materializedViewsToExclude",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const DatabaseListResult = {
    type: {
        name: "Composite",
        className: "DatabaseListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Database"
                        }
                    }
                }
            }
        }
    }
};
const DataConnectionCheckNameRequest = {
    type: {
        name: "Composite",
        className: "DataConnectionCheckNameRequest",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            type: {
                defaultValue: "Microsoft.Synapse/workspaces/kustoPools/databases/dataConnections",
                isConstant: true,
                serializedName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DataConnectionValidation = {
    type: {
        name: "Composite",
        className: "DataConnectionValidation",
        modelProperties: {
            dataConnectionName: {
                serializedName: "dataConnectionName",
                type: {
                    name: "String"
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "DataConnection"
                }
            }
        }
    }
};
const DataConnectionValidationListResult = {
    type: {
        name: "Composite",
        className: "DataConnectionValidationListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DataConnectionValidationResult"
                        }
                    }
                }
            }
        }
    }
};
const DataConnectionValidationResult = {
    type: {
        name: "Composite",
        className: "DataConnectionValidationResult",
        modelProperties: {
            errorMessage: {
                serializedName: "errorMessage",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DataConnectionListResult = {
    type: {
        name: "Composite",
        className: "DataConnectionListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DataConnection"
                        }
                    }
                }
            }
        }
    }
};
const ClusterPrincipalAssignmentCheckNameRequest = {
    type: {
        name: "Composite",
        className: "ClusterPrincipalAssignmentCheckNameRequest",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            type: {
                defaultValue: "Microsoft.Synapse/workspaces/kustoPools/principalAssignments",
                isConstant: true,
                serializedName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ClusterPrincipalAssignmentListResult = {
    type: {
        name: "Composite",
        className: "ClusterPrincipalAssignmentListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ClusterPrincipalAssignment"
                        }
                    }
                }
            }
        }
    }
};
const DatabasePrincipalAssignmentCheckNameRequest = {
    type: {
        name: "Composite",
        className: "DatabasePrincipalAssignmentCheckNameRequest",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            type: {
                defaultValue: "Microsoft.Synapse/workspaces/kustoPools/databases/principalAssignments",
                isConstant: true,
                serializedName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DatabasePrincipalAssignmentListResult = {
    type: {
        name: "Composite",
        className: "DatabasePrincipalAssignmentListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DatabasePrincipalAssignment"
                        }
                    }
                }
            }
        }
    }
};
const TopQueries = {
    type: {
        name: "Composite",
        className: "TopQueries",
        modelProperties: {
            aggregationFunction: {
                serializedName: "aggregationFunction",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["min", "max", "avg", "sum"]
                }
            },
            executionType: {
                serializedName: "executionType",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["any", "regular", "irregular", "aborted", "exception"]
                }
            },
            intervalType: {
                serializedName: "intervalType",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            numberOfTopQueries: {
                serializedName: "numberOfTopQueries",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            observationStartTime: {
                serializedName: "observationStartTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            observationEndTime: {
                serializedName: "observationEndTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            observedMetric: {
                serializedName: "observedMetric",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["cpu", "io", "logio", "duration", "executionCount"]
                }
            },
            queries: {
                serializedName: "queries",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "QueryStatistic"
                        }
                    }
                }
            }
        }
    }
};
const QueryStatistic = {
    type: {
        name: "Composite",
        className: "QueryStatistic",
        modelProperties: {
            queryId: {
                serializedName: "queryId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            intervals: {
                serializedName: "intervals",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "QueryInterval"
                        }
                    }
                }
            }
        }
    }
};
const QueryInterval = {
    type: {
        name: "Composite",
        className: "QueryInterval",
        modelProperties: {
            intervalStartTime: {
                serializedName: "intervalStartTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            executionCount: {
                serializedName: "executionCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            metrics: {
                serializedName: "metrics",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "QueryMetric"
                        }
                    }
                }
            }
        }
    }
};
const QueryMetric = {
    type: {
        name: "Composite",
        className: "QueryMetric",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            unit: {
                serializedName: "unit",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["percentage", "KB", "microseconds"]
                }
            },
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const TopQueriesListResult = {
    type: {
        name: "Composite",
        className: "TopQueriesListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TopQueries"
                        }
                    }
                }
            }
        }
    }
};
const IntegrationRuntimeComputeProperties = {
    type: {
        name: "Composite",
        className: "IntegrationRuntimeComputeProperties",
        additionalProperties: { type: { name: "Object" } },
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            nodeSize: {
                serializedName: "nodeSize",
                type: {
                    name: "String"
                }
            },
            numberOfNodes: {
                constraints: {
                    InclusiveMinimum: 1
                },
                serializedName: "numberOfNodes",
                type: {
                    name: "Number"
                }
            },
            maxParallelExecutionsPerNode: {
                constraints: {
                    InclusiveMinimum: 1
                },
                serializedName: "maxParallelExecutionsPerNode",
                type: {
                    name: "Number"
                }
            },
            dataFlowProperties: {
                serializedName: "dataFlowProperties",
                type: {
                    name: "Composite",
                    className: "IntegrationRuntimeDataFlowProperties"
                }
            },
            vNetProperties: {
                serializedName: "vNetProperties",
                type: {
                    name: "Composite",
                    className: "IntegrationRuntimeVNetProperties"
                }
            }
        }
    }
};
const IntegrationRuntimeDataFlowProperties = {
    type: {
        name: "Composite",
        className: "IntegrationRuntimeDataFlowProperties",
        additionalProperties: { type: { name: "Object" } },
        modelProperties: {
            computeType: {
                serializedName: "computeType",
                type: {
                    name: "String"
                }
            },
            coreCount: {
                serializedName: "coreCount",
                type: {
                    name: "Number"
                }
            },
            timeToLive: {
                constraints: {
                    InclusiveMinimum: 0
                },
                serializedName: "timeToLive",
                type: {
                    name: "Number"
                }
            },
            cleanup: {
                serializedName: "cleanup",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const IntegrationRuntimeVNetProperties = {
    type: {
        name: "Composite",
        className: "IntegrationRuntimeVNetProperties",
        additionalProperties: { type: { name: "Object" } },
        modelProperties: {
            vNetId: {
                serializedName: "vNetId",
                type: {
                    name: "String"
                }
            },
            subnet: {
                serializedName: "subnet",
                type: {
                    name: "String"
                }
            },
            publicIPs: {
                serializedName: "publicIPs",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            subnetId: {
                serializedName: "subnetId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IntegrationRuntimeSsisProperties = {
    type: {
        name: "Composite",
        className: "IntegrationRuntimeSsisProperties",
        additionalProperties: { type: { name: "Object" } },
        modelProperties: {
            catalogInfo: {
                serializedName: "catalogInfo",
                type: {
                    name: "Composite",
                    className: "IntegrationRuntimeSsisCatalogInfo"
                }
            },
            licenseType: {
                serializedName: "licenseType",
                type: {
                    name: "String"
                }
            },
            customSetupScriptProperties: {
                serializedName: "customSetupScriptProperties",
                type: {
                    name: "Composite",
                    className: "IntegrationRuntimeCustomSetupScriptProperties"
                }
            },
            dataProxyProperties: {
                serializedName: "dataProxyProperties",
                type: {
                    name: "Composite",
                    className: "IntegrationRuntimeDataProxyProperties"
                }
            },
            edition: {
                serializedName: "edition",
                type: {
                    name: "String"
                }
            },
            expressCustomSetupProperties: {
                serializedName: "expressCustomSetupProperties",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CustomSetupBase"
                        }
                    }
                }
            }
        }
    }
};
const IntegrationRuntimeSsisCatalogInfo = {
    type: {
        name: "Composite",
        className: "IntegrationRuntimeSsisCatalogInfo",
        additionalProperties: { type: { name: "Object" } },
        modelProperties: {
            catalogServerEndpoint: {
                serializedName: "catalogServerEndpoint",
                type: {
                    name: "String"
                }
            },
            catalogAdminUserName: {
                constraints: {
                    MaxLength: 128,
                    MinLength: 1
                },
                serializedName: "catalogAdminUserName",
                type: {
                    name: "String"
                }
            },
            catalogAdminPassword: {
                serializedName: "catalogAdminPassword",
                type: {
                    name: "Composite",
                    className: "SecureString"
                }
            },
            catalogPricingTier: {
                serializedName: "catalogPricingTier",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SecretBase = {
    type: {
        name: "Composite",
        className: "SecretBase",
        uberParent: "SecretBase",
        polymorphicDiscriminator: {
            serializedName: "type",
            clientName: "type"
        },
        modelProperties: {
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IntegrationRuntimeCustomSetupScriptProperties = {
    type: {
        name: "Composite",
        className: "IntegrationRuntimeCustomSetupScriptProperties",
        modelProperties: {
            blobContainerUri: {
                serializedName: "blobContainerUri",
                type: {
                    name: "String"
                }
            },
            sasToken: {
                serializedName: "sasToken",
                type: {
                    name: "Composite",
                    className: "SecureString"
                }
            }
        }
    }
};
const IntegrationRuntimeDataProxyProperties = {
    type: {
        name: "Composite",
        className: "IntegrationRuntimeDataProxyProperties",
        modelProperties: {
            connectVia: {
                serializedName: "connectVia",
                type: {
                    name: "Composite",
                    className: "EntityReference"
                }
            },
            stagingLinkedService: {
                serializedName: "stagingLinkedService",
                type: {
                    name: "Composite",
                    className: "EntityReference"
                }
            },
            path: {
                serializedName: "path",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EntityReference = {
    type: {
        name: "Composite",
        className: "EntityReference",
        modelProperties: {
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            referenceName: {
                serializedName: "referenceName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CustomSetupBase = {
    type: {
        name: "Composite",
        className: "CustomSetupBase",
        uberParent: "CustomSetupBase",
        polymorphicDiscriminator: {
            serializedName: "type",
            clientName: "type"
        },
        modelProperties: {
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LinkedIntegrationRuntimeType = {
    type: {
        name: "Composite",
        className: "LinkedIntegrationRuntimeType",
        uberParent: "LinkedIntegrationRuntimeType",
        polymorphicDiscriminator: {
            serializedName: "authorizationType",
            clientName: "authorizationType"
        },
        modelProperties: {
            authorizationType: {
                serializedName: "authorizationType",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ManagedIntegrationRuntimeNode = {
    type: {
        name: "Composite",
        className: "ManagedIntegrationRuntimeNode",
        additionalProperties: { type: { name: "Object" } },
        modelProperties: {
            nodeId: {
                serializedName: "nodeId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            errors: {
                serializedName: "errors",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManagedIntegrationRuntimeError"
                        }
                    }
                }
            }
        }
    }
};
const ManagedIntegrationRuntimeError = {
    type: {
        name: "Composite",
        className: "ManagedIntegrationRuntimeError",
        additionalProperties: { type: { name: "Object" } },
        modelProperties: {
            time: {
                serializedName: "time",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            code: {
                serializedName: "code",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            parameters: {
                serializedName: "parameters",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            message: {
                serializedName: "message",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ManagedIntegrationRuntimeOperationResult = {
    type: {
        name: "Composite",
        className: "ManagedIntegrationRuntimeOperationResult",
        additionalProperties: { type: { name: "Object" } },
        modelProperties: {
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            startTime: {
                serializedName: "startTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            result: {
                serializedName: "result",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            errorCode: {
                serializedName: "errorCode",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            parameters: {
                serializedName: "parameters",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            activityId: {
                serializedName: "activityId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LinkedIntegrationRuntime = {
    type: {
        name: "Composite",
        className: "LinkedIntegrationRuntime",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            subscriptionId: {
                serializedName: "subscriptionId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            dataFactoryName: {
                serializedName: "dataFactoryName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            dataFactoryLocation: {
                serializedName: "dataFactoryLocation",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            createTime: {
                serializedName: "createTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const SsisEnvironmentReference = {
    type: {
        name: "Composite",
        className: "SsisEnvironmentReference",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "Number"
                }
            },
            environmentFolderName: {
                serializedName: "environmentFolderName",
                type: {
                    name: "String"
                }
            },
            environmentName: {
                serializedName: "environmentName",
                type: {
                    name: "String"
                }
            },
            referenceType: {
                serializedName: "referenceType",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SsisParameter = {
    type: {
        name: "Composite",
        className: "SsisParameter",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "Number"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            dataType: {
                serializedName: "dataType",
                type: {
                    name: "String"
                }
            },
            required: {
                serializedName: "required",
                type: {
                    name: "Boolean"
                }
            },
            sensitive: {
                serializedName: "sensitive",
                type: {
                    name: "Boolean"
                }
            },
            designDefaultValue: {
                serializedName: "designDefaultValue",
                type: {
                    name: "String"
                }
            },
            defaultValue: {
                serializedName: "defaultValue",
                type: {
                    name: "String"
                }
            },
            sensitiveDefaultValue: {
                serializedName: "sensitiveDefaultValue",
                type: {
                    name: "String"
                }
            },
            valueType: {
                serializedName: "valueType",
                type: {
                    name: "String"
                }
            },
            valueSet: {
                serializedName: "valueSet",
                type: {
                    name: "Boolean"
                }
            },
            variable: {
                serializedName: "variable",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SsisVariable = {
    type: {
        name: "Composite",
        className: "SsisVariable",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "Number"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            dataType: {
                serializedName: "dataType",
                type: {
                    name: "String"
                }
            },
            sensitive: {
                serializedName: "sensitive",
                type: {
                    name: "Boolean"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "String"
                }
            },
            sensitiveValue: {
                serializedName: "sensitiveValue",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DatabaseStatistics = {
    type: {
        name: "Composite",
        className: "DatabaseStatistics",
        modelProperties: {
            size: {
                serializedName: "size",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ProxyResource = {
    type: {
        name: "Composite",
        className: "ProxyResource",
        modelProperties: Object.assign({}, Resource.type.modelProperties)
    }
};
const TrackedResource = {
    type: {
        name: "Composite",
        className: "TrackedResource",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, location: {
                serializedName: "location",
                required: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const AzureEntityResource = {
    type: {
        name: "Composite",
        className: "AzureEntityResource",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const KustoPoolUpdate = {
    type: {
        name: "Composite",
        className: "KustoPoolUpdate",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "AzureSku"
                }
            }, state: {
                serializedName: "properties.state",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, uri: {
                serializedName: "properties.uri",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, dataIngestionUri: {
                serializedName: "properties.dataIngestionUri",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, stateReason: {
                serializedName: "properties.stateReason",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, optimizedAutoscale: {
                serializedName: "properties.optimizedAutoscale",
                type: {
                    name: "Composite",
                    className: "OptimizedAutoscale"
                }
            }, enableStreamingIngest: {
                defaultValue: false,
                serializedName: "properties.enableStreamingIngest",
                type: {
                    name: "Boolean"
                }
            }, enablePurge: {
                defaultValue: false,
                serializedName: "properties.enablePurge",
                type: {
                    name: "Boolean"
                }
            }, languageExtensions: {
                serializedName: "properties.languageExtensions",
                type: {
                    name: "Composite",
                    className: "LanguageExtensionsList"
                }
            }, workspaceUID: {
                serializedName: "properties.workspaceUID",
                type: {
                    name: "String"
                }
            } })
    }
};
const PrivateEndpointConnectionForPrivateLinkHub = {
    type: {
        name: "Composite",
        className: "PrivateEndpointConnectionForPrivateLinkHub",
        modelProperties: Object.assign(Object.assign({}, PrivateEndpointConnectionForPrivateLinkHubBasicAutoGenerated.type
            .modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            } })
    }
};
const ManagedIntegrationRuntime = {
    serializedName: "Managed",
    type: {
        name: "Composite",
        className: "ManagedIntegrationRuntime",
        uberParent: "IntegrationRuntime",
        additionalProperties: { type: { name: "Object" } },
        polymorphicDiscriminator: IntegrationRuntime.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, IntegrationRuntime.type.modelProperties), { state: {
                serializedName: "state",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, referenceName: {
                serializedName: "managedVirtualNetwork.referenceName",
                type: {
                    name: "String"
                }
            }, typeManagedVirtualNetworkType: {
                serializedName: "managedVirtualNetwork.type",
                type: {
                    name: "String"
                }
            }, id: {
                serializedName: "managedVirtualNetwork.id",
                type: {
                    name: "String"
                }
            }, computeProperties: {
                serializedName: "typeProperties.computeProperties",
                type: {
                    name: "Composite",
                    className: "IntegrationRuntimeComputeProperties"
                }
            }, ssisProperties: {
                serializedName: "typeProperties.ssisProperties",
                type: {
                    name: "Composite",
                    className: "IntegrationRuntimeSsisProperties"
                }
            } })
    }
};
const SelfHostedIntegrationRuntime = {
    serializedName: "SelfHosted",
    type: {
        name: "Composite",
        className: "SelfHostedIntegrationRuntime",
        uberParent: "IntegrationRuntime",
        additionalProperties: { type: { name: "Object" } },
        polymorphicDiscriminator: IntegrationRuntime.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, IntegrationRuntime.type.modelProperties), { linkedInfo: {
                serializedName: "typeProperties.linkedInfo",
                type: {
                    name: "Composite",
                    className: "LinkedIntegrationRuntimeType"
                }
            } })
    }
};
const SsisFolder = {
    serializedName: "Folder",
    type: {
        name: "Composite",
        className: "SsisFolder",
        uberParent: "SsisObjectMetadata",
        polymorphicDiscriminator: SsisObjectMetadata.type.polymorphicDiscriminator,
        modelProperties: Object.assign({}, SsisObjectMetadata.type.modelProperties)
    }
};
const SsisProject = {
    serializedName: "Project",
    type: {
        name: "Composite",
        className: "SsisProject",
        uberParent: "SsisObjectMetadata",
        polymorphicDiscriminator: SsisObjectMetadata.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, SsisObjectMetadata.type.modelProperties), { folderId: {
                serializedName: "folderId",
                type: {
                    name: "Number"
                }
            }, version: {
                serializedName: "version",
                type: {
                    name: "Number"
                }
            }, environmentRefs: {
                serializedName: "environmentRefs",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SsisEnvironmentReference"
                        }
                    }
                }
            }, parameters: {
                serializedName: "parameters",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SsisParameter"
                        }
                    }
                }
            } })
    }
};
const SsisPackage = {
    serializedName: "Package",
    type: {
        name: "Composite",
        className: "SsisPackage",
        uberParent: "SsisObjectMetadata",
        polymorphicDiscriminator: SsisObjectMetadata.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, SsisObjectMetadata.type.modelProperties), { folderId: {
                serializedName: "folderId",
                type: {
                    name: "Number"
                }
            }, projectVersion: {
                serializedName: "projectVersion",
                type: {
                    name: "Number"
                }
            }, projectId: {
                serializedName: "projectId",
                type: {
                    name: "Number"
                }
            }, parameters: {
                serializedName: "parameters",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SsisParameter"
                        }
                    }
                }
            } })
    }
};
const SsisEnvironment = {
    serializedName: "Environment",
    type: {
        name: "Composite",
        className: "SsisEnvironment",
        uberParent: "SsisObjectMetadata",
        polymorphicDiscriminator: SsisObjectMetadata.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, SsisObjectMetadata.type.modelProperties), { folderId: {
                serializedName: "folderId",
                type: {
                    name: "Number"
                }
            }, variables: {
                serializedName: "variables",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SsisVariable"
                        }
                    }
                }
            } })
    }
};
const ManagedIntegrationRuntimeStatus = {
    serializedName: "Managed",
    type: {
        name: "Composite",
        className: "ManagedIntegrationRuntimeStatus",
        uberParent: "IntegrationRuntimeStatus",
        additionalProperties: { type: { name: "Object" } },
        polymorphicDiscriminator: IntegrationRuntimeStatus.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, IntegrationRuntimeStatus.type.modelProperties), { createTime: {
                serializedName: "typeProperties.createTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, nodes: {
                serializedName: "typeProperties.nodes",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManagedIntegrationRuntimeNode"
                        }
                    }
                }
            }, otherErrors: {
                serializedName: "typeProperties.otherErrors",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManagedIntegrationRuntimeError"
                        }
                    }
                }
            }, lastOperation: {
                serializedName: "typeProperties.lastOperation",
                type: {
                    name: "Composite",
                    className: "ManagedIntegrationRuntimeOperationResult"
                }
            } })
    }
};
const SelfHostedIntegrationRuntimeStatus = {
    serializedName: "SelfHosted",
    type: {
        name: "Composite",
        className: "SelfHostedIntegrationRuntimeStatus",
        uberParent: "IntegrationRuntimeStatus",
        additionalProperties: { type: { name: "Object" } },
        polymorphicDiscriminator: IntegrationRuntimeStatus.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, IntegrationRuntimeStatus.type.modelProperties), { createTime: {
                serializedName: "typeProperties.createTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, taskQueueId: {
                serializedName: "typeProperties.taskQueueId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, nodeCommunicationChannelEncryptionMode: {
                serializedName: "typeProperties.nodeCommunicationChannelEncryptionMode",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, internalChannelEncryption: {
                serializedName: "typeProperties.internalChannelEncryption",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, version: {
                serializedName: "typeProperties.version",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, nodes: {
                serializedName: "typeProperties.nodes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SelfHostedIntegrationRuntimeNode"
                        }
                    }
                }
            }, scheduledUpdateDate: {
                serializedName: "typeProperties.scheduledUpdateDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, updateDelayOffset: {
                serializedName: "typeProperties.updateDelayOffset",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, localTimeZoneOffset: {
                serializedName: "typeProperties.localTimeZoneOffset",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, capabilities: {
                serializedName: "typeProperties.capabilities",
                readOnly: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, serviceUrls: {
                serializedName: "typeProperties.serviceUrls",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, autoUpdate: {
                serializedName: "typeProperties.autoUpdate",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, versionStatus: {
                serializedName: "typeProperties.versionStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, links: {
                serializedName: "typeProperties.links",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LinkedIntegrationRuntime"
                        }
                    }
                }
            }, pushedVersion: {
                serializedName: "typeProperties.pushedVersion",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, latestVersion: {
                serializedName: "typeProperties.latestVersion",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, autoUpdateETA: {
                serializedName: "typeProperties.autoUpdateETA",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, serviceRegion: {
                serializedName: "typeProperties.serviceRegion",
                type: {
                    name: "String"
                }
            }, newerVersions: {
                serializedName: "typeProperties.newerVersions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const SecureString = {
    serializedName: "SecureString",
    type: {
        name: "Composite",
        className: "SecureString",
        uberParent: "SecretBase",
        polymorphicDiscriminator: SecretBase.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, SecretBase.type.modelProperties), { value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const CmdkeySetup = {
    serializedName: "CmdkeySetup",
    type: {
        name: "Composite",
        className: "CmdkeySetup",
        uberParent: "CustomSetupBase",
        polymorphicDiscriminator: CustomSetupBase.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, CustomSetupBase.type.modelProperties), { targetName: {
                serializedName: "typeProperties.targetName",
                required: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            }, userName: {
                serializedName: "typeProperties.userName",
                required: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            }, password: {
                serializedName: "typeProperties.password",
                type: {
                    name: "Composite",
                    className: "SecretBase"
                }
            } })
    }
};
const EnvironmentVariableSetup = {
    serializedName: "EnvironmentVariableSetup",
    type: {
        name: "Composite",
        className: "EnvironmentVariableSetup",
        uberParent: "CustomSetupBase",
        polymorphicDiscriminator: CustomSetupBase.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, CustomSetupBase.type.modelProperties), { variableName: {
                serializedName: "typeProperties.variableName",
                required: true,
                type: {
                    name: "String"
                }
            }, variableValue: {
                serializedName: "typeProperties.variableValue",
                required: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ComponentSetup = {
    serializedName: "ComponentSetup",
    type: {
        name: "Composite",
        className: "ComponentSetup",
        uberParent: "CustomSetupBase",
        polymorphicDiscriminator: CustomSetupBase.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, CustomSetupBase.type.modelProperties), { componentName: {
                serializedName: "typeProperties.componentName",
                required: true,
                type: {
                    name: "String"
                }
            }, licenseKey: {
                serializedName: "typeProperties.licenseKey",
                type: {
                    name: "Composite",
                    className: "SecretBase"
                }
            } })
    }
};
const LinkedIntegrationRuntimeKeyAuthorization = {
    serializedName: "Key",
    type: {
        name: "Composite",
        className: "LinkedIntegrationRuntimeKeyAuthorization",
        uberParent: "LinkedIntegrationRuntimeType",
        polymorphicDiscriminator: LinkedIntegrationRuntimeType.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, LinkedIntegrationRuntimeType.type.modelProperties), { key: {
                serializedName: "key",
                type: {
                    name: "Composite",
                    className: "SecureString"
                }
            } })
    }
};
const LinkedIntegrationRuntimeRbacAuthorization = {
    serializedName: "RBAC",
    type: {
        name: "Composite",
        className: "LinkedIntegrationRuntimeRbacAuthorization",
        uberParent: "LinkedIntegrationRuntimeType",
        polymorphicDiscriminator: LinkedIntegrationRuntimeType.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, LinkedIntegrationRuntimeType.type.modelProperties), { resourceId: {
                serializedName: "resourceId",
                required: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const AzureADOnlyAuthentication = {
    type: {
        name: "Composite",
        className: "AzureADOnlyAuthentication",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { azureADOnlyAuthentication: {
                serializedName: "properties.azureADOnlyAuthentication",
                type: {
                    name: "Boolean"
                }
            }, state: {
                serializedName: "properties.state",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, creationDate: {
                serializedName: "properties.creationDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            } })
    }
};
const IpFirewallRuleInfo = {
    type: {
        name: "Composite",
        className: "IpFirewallRuleInfo",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { endIpAddress: {
                serializedName: "properties.endIpAddress",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, startIpAddress: {
                serializedName: "properties.startIpAddress",
                type: {
                    name: "String"
                }
            } })
    }
};
const Key = {
    type: {
        name: "Composite",
        className: "Key",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { isActiveCMK: {
                serializedName: "properties.isActiveCMK",
                type: {
                    name: "Boolean"
                }
            }, keyVaultUrl: {
                serializedName: "properties.keyVaultUrl",
                type: {
                    name: "String"
                }
            } })
    }
};
const PrivateEndpointConnection = {
    type: {
        name: "Composite",
        className: "PrivateEndpointConnection",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { privateEndpoint: {
                serializedName: "properties.privateEndpoint",
                type: {
                    name: "Composite",
                    className: "PrivateEndpoint"
                }
            }, privateLinkServiceConnectionState: {
                serializedName: "properties.privateLinkServiceConnectionState",
                type: {
                    name: "Composite",
                    className: "PrivateLinkServiceConnectionState"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const PrivateLinkResource = {
    type: {
        name: "Composite",
        className: "PrivateLinkResource",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "PrivateLinkResourceProperties"
                }
            } })
    }
};
const MetadataSyncConfig = {
    type: {
        name: "Composite",
        className: "MetadataSyncConfig",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { enabled: {
                serializedName: "properties.enabled",
                type: {
                    name: "Boolean"
                }
            }, syncIntervalInMinutes: {
                serializedName: "properties.syncIntervalInMinutes",
                type: {
                    name: "Number"
                }
            } })
    }
};
const GeoBackupPolicy = {
    type: {
        name: "Composite",
        className: "GeoBackupPolicy",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { kind: {
                serializedName: "kind",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, location: {
                serializedName: "location",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, state: {
                serializedName: "properties.state",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Disabled", "Enabled"]
                }
            }, storageType: {
                serializedName: "properties.storageType",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const DataWarehouseUserActivities = {
    type: {
        name: "Composite",
        className: "DataWarehouseUserActivities",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { activeQueriesCount: {
                serializedName: "properties.activeQueriesCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            } })
    }
};
const RestorePoint = {
    type: {
        name: "Composite",
        className: "RestorePoint",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { location: {
                serializedName: "location",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, restorePointType: {
                serializedName: "properties.restorePointType",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["CONTINUOUS", "DISCRETE"]
                }
            }, earliestRestoreDate: {
                serializedName: "properties.earliestRestoreDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, restorePointCreationDate: {
                serializedName: "properties.restorePointCreationDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, restorePointLabel: {
                serializedName: "properties.restorePointLabel",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ReplicationLink = {
    type: {
        name: "Composite",
        className: "ReplicationLink",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { location: {
                serializedName: "location",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, isTerminationAllowed: {
                serializedName: "properties.isTerminationAllowed",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            }, replicationMode: {
                serializedName: "properties.replicationMode",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, partnerServer: {
                serializedName: "properties.partnerServer",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, partnerDatabase: {
                serializedName: "properties.partnerDatabase",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, partnerLocation: {
                serializedName: "properties.partnerLocation",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, role: {
                serializedName: "properties.role",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Primary",
                        "Secondary",
                        "NonReadableSecondary",
                        "Source",
                        "Copy"
                    ]
                }
            }, partnerRole: {
                serializedName: "properties.partnerRole",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Primary",
                        "Secondary",
                        "NonReadableSecondary",
                        "Source",
                        "Copy"
                    ]
                }
            }, startTime: {
                serializedName: "properties.startTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, percentComplete: {
                serializedName: "properties.percentComplete",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, replicationState: {
                serializedName: "properties.replicationState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const MaintenanceWindows = {
    type: {
        name: "Composite",
        className: "MaintenanceWindows",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { timeRanges: {
                serializedName: "properties.timeRanges",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MaintenanceWindowTimeRange"
                        }
                    }
                }
            } })
    }
};
const MaintenanceWindowOptions = {
    type: {
        name: "Composite",
        className: "MaintenanceWindowOptions",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { isEnabled: {
                serializedName: "properties.isEnabled",
                type: {
                    name: "Boolean"
                }
            }, maintenanceWindowCycles: {
                serializedName: "properties.maintenanceWindowCycles",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MaintenanceWindowTimeRange"
                        }
                    }
                }
            }, minDurationInMinutes: {
                serializedName: "properties.minDurationInMinutes",
                type: {
                    name: "Number"
                }
            }, defaultDurationInMinutes: {
                serializedName: "properties.defaultDurationInMinutes",
                type: {
                    name: "Number"
                }
            }, minCycles: {
                serializedName: "properties.minCycles",
                type: {
                    name: "Number"
                }
            }, timeGranularityInMinutes: {
                serializedName: "properties.timeGranularityInMinutes",
                type: {
                    name: "Number"
                }
            }, allowMultipleMaintenanceWindowsPerCycle: {
                serializedName: "properties.allowMultipleMaintenanceWindowsPerCycle",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const TransparentDataEncryption = {
    type: {
        name: "Composite",
        className: "TransparentDataEncryption",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { location: {
                serializedName: "location",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, status: {
                serializedName: "properties.status",
                type: {
                    name: "Enum",
                    allowedValues: ["Enabled", "Disabled"]
                }
            } })
    }
};
const SqlPoolBlobAuditingPolicy = {
    type: {
        name: "Composite",
        className: "SqlPoolBlobAuditingPolicy",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { kind: {
                serializedName: "kind",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, state: {
                serializedName: "properties.state",
                type: {
                    name: "Enum",
                    allowedValues: ["Enabled", "Disabled"]
                }
            }, storageEndpoint: {
                serializedName: "properties.storageEndpoint",
                type: {
                    name: "String"
                }
            }, storageAccountAccessKey: {
                serializedName: "properties.storageAccountAccessKey",
                type: {
                    name: "String"
                }
            }, retentionDays: {
                serializedName: "properties.retentionDays",
                type: {
                    name: "Number"
                }
            }, auditActionsAndGroups: {
                serializedName: "properties.auditActionsAndGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, storageAccountSubscriptionId: {
                serializedName: "properties.storageAccountSubscriptionId",
                type: {
                    name: "Uuid"
                }
            }, isStorageSecondaryKeyInUse: {
                serializedName: "properties.isStorageSecondaryKeyInUse",
                type: {
                    name: "Boolean"
                }
            }, isAzureMonitorTargetEnabled: {
                defaultValue: false,
                serializedName: "properties.isAzureMonitorTargetEnabled",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const SqlPoolOperation = {
    type: {
        name: "Composite",
        className: "SqlPoolOperation",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { databaseName: {
                serializedName: "properties.databaseName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, operation: {
                serializedName: "properties.operation",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, operationFriendlyName: {
                serializedName: "properties.operationFriendlyName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, percentComplete: {
                serializedName: "properties.percentComplete",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, serverName: {
                serializedName: "properties.serverName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, startTime: {
                serializedName: "properties.startTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, state: {
                serializedName: "properties.state",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, errorCode: {
                serializedName: "properties.errorCode",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, errorDescription: {
                serializedName: "properties.errorDescription",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, errorSeverity: {
                serializedName: "properties.errorSeverity",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, isUserError: {
                serializedName: "properties.isUserError",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            }, estimatedCompletionTime: {
                serializedName: "properties.estimatedCompletionTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, description: {
                serializedName: "properties.description",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, isCancellable: {
                serializedName: "properties.isCancellable",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const SensitivityLabel = {
    type: {
        name: "Composite",
        className: "SensitivityLabel",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { managedBy: {
                serializedName: "managedBy",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, schemaName: {
                serializedName: "properties.schemaName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, tableName: {
                serializedName: "properties.tableName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, columnName: {
                serializedName: "properties.columnName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, labelName: {
                serializedName: "properties.labelName",
                type: {
                    name: "String"
                }
            }, labelId: {
                serializedName: "properties.labelId",
                type: {
                    name: "String"
                }
            }, informationType: {
                serializedName: "properties.informationType",
                type: {
                    name: "String"
                }
            }, informationTypeId: {
                serializedName: "properties.informationTypeId",
                type: {
                    name: "String"
                }
            }, isDisabled: {
                serializedName: "properties.isDisabled",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            }, rank: {
                serializedName: "properties.rank",
                type: {
                    name: "Enum",
                    allowedValues: ["None", "Low", "Medium", "High", "Critical"]
                }
            } })
    }
};
const SensitivityLabelUpdate = {
    type: {
        name: "Composite",
        className: "SensitivityLabelUpdate",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { op: {
                serializedName: "properties.op",
                type: {
                    name: "Enum",
                    allowedValues: ["set", "remove"]
                }
            }, schema: {
                serializedName: "properties.schema",
                type: {
                    name: "String"
                }
            }, table: {
                serializedName: "properties.table",
                type: {
                    name: "String"
                }
            }, column: {
                serializedName: "properties.column",
                type: {
                    name: "String"
                }
            }, sensitivityLabel: {
                serializedName: "properties.sensitivityLabel",
                type: {
                    name: "Composite",
                    className: "SensitivityLabel"
                }
            } })
    }
};
const RecommendedSensitivityLabelUpdate = {
    type: {
        name: "Composite",
        className: "RecommendedSensitivityLabelUpdate",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { op: {
                serializedName: "properties.op",
                type: {
                    name: "Enum",
                    allowedValues: ["enable", "disable"]
                }
            }, schema: {
                serializedName: "properties.schema",
                type: {
                    name: "String"
                }
            }, table: {
                serializedName: "properties.table",
                type: {
                    name: "String"
                }
            }, column: {
                serializedName: "properties.column",
                type: {
                    name: "String"
                }
            } })
    }
};
const SqlPoolSchema = {
    type: {
        name: "Composite",
        className: "SqlPoolSchema",
        modelProperties: Object.assign({}, ProxyResource.type.modelProperties)
    }
};
const SqlPoolTable = {
    type: {
        name: "Composite",
        className: "SqlPoolTable",
        modelProperties: Object.assign({}, ProxyResource.type.modelProperties)
    }
};
const SqlPoolColumn = {
    type: {
        name: "Composite",
        className: "SqlPoolColumn",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { columnType: {
                serializedName: "properties.columnType",
                type: {
                    name: "String"
                }
            }, isComputed: {
                serializedName: "properties.isComputed",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const SqlPoolConnectionPolicy = {
    type: {
        name: "Composite",
        className: "SqlPoolConnectionPolicy",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { kind: {
                serializedName: "kind",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, location: {
                serializedName: "location",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, securityEnabledAccess: {
                serializedName: "properties.securityEnabledAccess",
                type: {
                    name: "String"
                }
            }, proxyDnsName: {
                serializedName: "properties.proxyDnsName",
                type: {
                    name: "String"
                }
            }, proxyPort: {
                serializedName: "properties.proxyPort",
                type: {
                    name: "String"
                }
            }, visibility: {
                serializedName: "properties.visibility",
                type: {
                    name: "String"
                }
            }, useServerDefault: {
                serializedName: "properties.useServerDefault",
                type: {
                    name: "String"
                }
            }, redirectionState: {
                serializedName: "properties.redirectionState",
                type: {
                    name: "String"
                }
            }, state: {
                serializedName: "properties.state",
                type: {
                    name: "String"
                }
            } })
    }
};
const SqlPoolVulnerabilityAssessment = {
    type: {
        name: "Composite",
        className: "SqlPoolVulnerabilityAssessment",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { storageContainerPath: {
                serializedName: "properties.storageContainerPath",
                type: {
                    name: "String"
                }
            }, storageContainerSasKey: {
                serializedName: "properties.storageContainerSasKey",
                type: {
                    name: "String"
                }
            }, storageAccountAccessKey: {
                serializedName: "properties.storageAccountAccessKey",
                type: {
                    name: "String"
                }
            }, recurringScans: {
                serializedName: "properties.recurringScans",
                type: {
                    name: "Composite",
                    className: "VulnerabilityAssessmentRecurringScansProperties"
                }
            } })
    }
};
const VulnerabilityAssessmentScanRecord = {
    type: {
        name: "Composite",
        className: "VulnerabilityAssessmentScanRecord",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { scanId: {
                serializedName: "properties.scanId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, triggerType: {
                serializedName: "properties.triggerType",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, state: {
                serializedName: "properties.state",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, startTime: {
                serializedName: "properties.startTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, endTime: {
                serializedName: "properties.endTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, errors: {
                serializedName: "properties.errors",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VulnerabilityAssessmentScanError"
                        }
                    }
                }
            }, storageContainerPath: {
                serializedName: "properties.storageContainerPath",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, numberOfFailedSecurityChecks: {
                serializedName: "properties.numberOfFailedSecurityChecks",
                readOnly: true,
                type: {
                    name: "Number"
                }
            } })
    }
};
const SqlPoolVulnerabilityAssessmentScansExport = {
    type: {
        name: "Composite",
        className: "SqlPoolVulnerabilityAssessmentScansExport",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { exportedReportLocation: {
                serializedName: "properties.exportedReportLocation",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const SqlPoolSecurityAlertPolicy = {
    type: {
        name: "Composite",
        className: "SqlPoolSecurityAlertPolicy",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { state: {
                serializedName: "properties.state",
                type: {
                    name: "Enum",
                    allowedValues: ["New", "Enabled", "Disabled"]
                }
            }, disabledAlerts: {
                serializedName: "properties.disabledAlerts",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, emailAddresses: {
                serializedName: "properties.emailAddresses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, emailAccountAdmins: {
                serializedName: "properties.emailAccountAdmins",
                type: {
                    name: "Boolean"
                }
            }, storageEndpoint: {
                serializedName: "properties.storageEndpoint",
                type: {
                    name: "String"
                }
            }, storageAccountAccessKey: {
                serializedName: "properties.storageAccountAccessKey",
                type: {
                    name: "String"
                }
            }, retentionDays: {
                serializedName: "properties.retentionDays",
                type: {
                    name: "Number"
                }
            }, creationTime: {
                serializedName: "properties.creationTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            } })
    }
};
const SqlPoolVulnerabilityAssessmentRuleBaseline = {
    type: {
        name: "Composite",
        className: "SqlPoolVulnerabilityAssessmentRuleBaseline",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { baselineResults: {
                serializedName: "properties.baselineResults",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SqlPoolVulnerabilityAssessmentRuleBaselineItem"
                        }
                    }
                }
            } })
    }
};
const ExtendedSqlPoolBlobAuditingPolicy = {
    type: {
        name: "Composite",
        className: "ExtendedSqlPoolBlobAuditingPolicy",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { predicateExpression: {
                serializedName: "properties.predicateExpression",
                type: {
                    name: "String"
                }
            }, state: {
                serializedName: "properties.state",
                type: {
                    name: "Enum",
                    allowedValues: ["Enabled", "Disabled"]
                }
            }, storageEndpoint: {
                serializedName: "properties.storageEndpoint",
                type: {
                    name: "String"
                }
            }, storageAccountAccessKey: {
                serializedName: "properties.storageAccountAccessKey",
                type: {
                    name: "String"
                }
            }, retentionDays: {
                serializedName: "properties.retentionDays",
                type: {
                    name: "Number"
                }
            }, auditActionsAndGroups: {
                serializedName: "properties.auditActionsAndGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, storageAccountSubscriptionId: {
                serializedName: "properties.storageAccountSubscriptionId",
                type: {
                    name: "Uuid"
                }
            }, isStorageSecondaryKeyInUse: {
                serializedName: "properties.isStorageSecondaryKeyInUse",
                type: {
                    name: "Boolean"
                }
            }, isAzureMonitorTargetEnabled: {
                serializedName: "properties.isAzureMonitorTargetEnabled",
                type: {
                    name: "Boolean"
                }
            }, queueDelayMs: {
                serializedName: "properties.queueDelayMs",
                type: {
                    name: "Number"
                }
            } })
    }
};
const DataMaskingPolicy = {
    type: {
        name: "Composite",
        className: "DataMaskingPolicy",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { location: {
                serializedName: "location",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, kind: {
                serializedName: "kind",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, managedBy: {
                serializedName: "managedBy",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, dataMaskingState: {
                serializedName: "properties.dataMaskingState",
                type: {
                    name: "Enum",
                    allowedValues: ["Disabled", "Enabled"]
                }
            }, exemptPrincipals: {
                serializedName: "properties.exemptPrincipals",
                type: {
                    name: "String"
                }
            }, applicationPrincipals: {
                serializedName: "properties.applicationPrincipals",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, maskingLevel: {
                serializedName: "properties.maskingLevel",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const DataMaskingRule = {
    type: {
        name: "Composite",
        className: "DataMaskingRule",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { location: {
                serializedName: "location",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, kind: {
                serializedName: "kind",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, idPropertiesId: {
                serializedName: "properties.id",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, aliasName: {
                serializedName: "properties.aliasName",
                type: {
                    name: "String"
                }
            }, ruleState: {
                serializedName: "properties.ruleState",
                type: {
                    name: "Enum",
                    allowedValues: ["Disabled", "Enabled"]
                }
            }, schemaName: {
                serializedName: "properties.schemaName",
                type: {
                    name: "String"
                }
            }, tableName: {
                serializedName: "properties.tableName",
                type: {
                    name: "String"
                }
            }, columnName: {
                serializedName: "properties.columnName",
                type: {
                    name: "String"
                }
            }, maskingFunction: {
                serializedName: "properties.maskingFunction",
                type: {
                    name: "Enum",
                    allowedValues: ["Default", "CCN", "Email", "Number", "SSN", "Text"]
                }
            }, numberFrom: {
                serializedName: "properties.numberFrom",
                type: {
                    name: "String"
                }
            }, numberTo: {
                serializedName: "properties.numberTo",
                type: {
                    name: "String"
                }
            }, prefixSize: {
                serializedName: "properties.prefixSize",
                type: {
                    name: "String"
                }
            }, suffixSize: {
                serializedName: "properties.suffixSize",
                type: {
                    name: "String"
                }
            }, replacementString: {
                serializedName: "properties.replacementString",
                type: {
                    name: "String"
                }
            } })
    }
};
const WorkloadGroup = {
    type: {
        name: "Composite",
        className: "WorkloadGroup",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { minResourcePercent: {
                serializedName: "properties.minResourcePercent",
                type: {
                    name: "Number"
                }
            }, maxResourcePercent: {
                serializedName: "properties.maxResourcePercent",
                type: {
                    name: "Number"
                }
            }, minResourcePercentPerRequest: {
                serializedName: "properties.minResourcePercentPerRequest",
                type: {
                    name: "Number"
                }
            }, maxResourcePercentPerRequest: {
                serializedName: "properties.maxResourcePercentPerRequest",
                type: {
                    name: "Number"
                }
            }, importance: {
                serializedName: "properties.importance",
                type: {
                    name: "String"
                }
            }, queryExecutionTimeout: {
                serializedName: "properties.queryExecutionTimeout",
                type: {
                    name: "Number"
                }
            } })
    }
};
const WorkloadClassifier = {
    type: {
        name: "Composite",
        className: "WorkloadClassifier",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { memberName: {
                serializedName: "properties.memberName",
                type: {
                    name: "String"
                }
            }, label: {
                serializedName: "properties.label",
                type: {
                    name: "String"
                }
            }, context: {
                serializedName: "properties.context",
                type: {
                    name: "String"
                }
            }, startTime: {
                serializedName: "properties.startTime",
                type: {
                    name: "String"
                }
            }, endTime: {
                serializedName: "properties.endTime",
                type: {
                    name: "String"
                }
            }, importance: {
                serializedName: "properties.importance",
                type: {
                    name: "String"
                }
            } })
    }
};
const ServerBlobAuditingPolicy = {
    type: {
        name: "Composite",
        className: "ServerBlobAuditingPolicy",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { state: {
                serializedName: "properties.state",
                type: {
                    name: "Enum",
                    allowedValues: ["Enabled", "Disabled"]
                }
            }, storageEndpoint: {
                serializedName: "properties.storageEndpoint",
                type: {
                    name: "String"
                }
            }, storageAccountAccessKey: {
                serializedName: "properties.storageAccountAccessKey",
                type: {
                    name: "String"
                }
            }, retentionDays: {
                serializedName: "properties.retentionDays",
                type: {
                    name: "Number"
                }
            }, auditActionsAndGroups: {
                serializedName: "properties.auditActionsAndGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, storageAccountSubscriptionId: {
                serializedName: "properties.storageAccountSubscriptionId",
                type: {
                    name: "Uuid"
                }
            }, isStorageSecondaryKeyInUse: {
                serializedName: "properties.isStorageSecondaryKeyInUse",
                type: {
                    name: "Boolean"
                }
            }, isAzureMonitorTargetEnabled: {
                serializedName: "properties.isAzureMonitorTargetEnabled",
                type: {
                    name: "Boolean"
                }
            }, queueDelayMs: {
                serializedName: "properties.queueDelayMs",
                type: {
                    name: "Number"
                }
            }, isDevopsAuditEnabled: {
                serializedName: "properties.isDevopsAuditEnabled",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const ExtendedServerBlobAuditingPolicy = {
    type: {
        name: "Composite",
        className: "ExtendedServerBlobAuditingPolicy",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { predicateExpression: {
                serializedName: "properties.predicateExpression",
                type: {
                    name: "String"
                }
            }, state: {
                serializedName: "properties.state",
                type: {
                    name: "Enum",
                    allowedValues: ["Enabled", "Disabled"]
                }
            }, storageEndpoint: {
                serializedName: "properties.storageEndpoint",
                type: {
                    name: "String"
                }
            }, storageAccountAccessKey: {
                serializedName: "properties.storageAccountAccessKey",
                type: {
                    name: "String"
                }
            }, retentionDays: {
                serializedName: "properties.retentionDays",
                type: {
                    name: "Number"
                }
            }, auditActionsAndGroups: {
                serializedName: "properties.auditActionsAndGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, storageAccountSubscriptionId: {
                serializedName: "properties.storageAccountSubscriptionId",
                type: {
                    name: "Uuid"
                }
            }, isStorageSecondaryKeyInUse: {
                serializedName: "properties.isStorageSecondaryKeyInUse",
                type: {
                    name: "Boolean"
                }
            }, isAzureMonitorTargetEnabled: {
                serializedName: "properties.isAzureMonitorTargetEnabled",
                type: {
                    name: "Boolean"
                }
            }, queueDelayMs: {
                serializedName: "properties.queueDelayMs",
                type: {
                    name: "Number"
                }
            }, isDevopsAuditEnabled: {
                serializedName: "properties.isDevopsAuditEnabled",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const ServerSecurityAlertPolicy = {
    type: {
        name: "Composite",
        className: "ServerSecurityAlertPolicy",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { state: {
                serializedName: "properties.state",
                type: {
                    name: "Enum",
                    allowedValues: ["New", "Enabled", "Disabled"]
                }
            }, disabledAlerts: {
                serializedName: "properties.disabledAlerts",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, emailAddresses: {
                serializedName: "properties.emailAddresses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, emailAccountAdmins: {
                serializedName: "properties.emailAccountAdmins",
                type: {
                    name: "Boolean"
                }
            }, storageEndpoint: {
                serializedName: "properties.storageEndpoint",
                type: {
                    name: "String"
                }
            }, storageAccountAccessKey: {
                serializedName: "properties.storageAccountAccessKey",
                type: {
                    name: "String"
                }
            }, retentionDays: {
                serializedName: "properties.retentionDays",
                type: {
                    name: "Number"
                }
            }, creationTime: {
                serializedName: "properties.creationTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            } })
    }
};
const ServerVulnerabilityAssessment = {
    type: {
        name: "Composite",
        className: "ServerVulnerabilityAssessment",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { storageContainerPath: {
                serializedName: "properties.storageContainerPath",
                type: {
                    name: "String"
                }
            }, storageContainerSasKey: {
                serializedName: "properties.storageContainerSasKey",
                type: {
                    name: "String"
                }
            }, storageAccountAccessKey: {
                serializedName: "properties.storageAccountAccessKey",
                type: {
                    name: "String"
                }
            }, recurringScans: {
                serializedName: "properties.recurringScans",
                type: {
                    name: "Composite",
                    className: "VulnerabilityAssessmentRecurringScansProperties"
                }
            } })
    }
};
const EncryptionProtector = {
    type: {
        name: "Composite",
        className: "EncryptionProtector",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { kind: {
                serializedName: "kind",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, location: {
                serializedName: "location",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, subregion: {
                serializedName: "properties.subregion",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, serverKeyName: {
                serializedName: "properties.serverKeyName",
                type: {
                    name: "String"
                }
            }, serverKeyType: {
                serializedName: "properties.serverKeyType",
                type: {
                    name: "String"
                }
            }, uri: {
                serializedName: "properties.uri",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, thumbprint: {
                serializedName: "properties.thumbprint",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const RecoverableSqlPool = {
    type: {
        name: "Composite",
        className: "RecoverableSqlPool",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { edition: {
                serializedName: "properties.edition",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, serviceLevelObjective: {
                serializedName: "properties.serviceLevelObjective",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, elasticPoolName: {
                serializedName: "properties.elasticPoolName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, lastAvailableBackupDate: {
                serializedName: "properties.lastAvailableBackupDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            } })
    }
};
const WorkspaceAadAdminInfo = {
    type: {
        name: "Composite",
        className: "WorkspaceAadAdminInfo",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { tenantId: {
                serializedName: "properties.tenantId",
                type: {
                    name: "String"
                }
            }, login: {
                serializedName: "properties.login",
                type: {
                    name: "String"
                }
            }, administratorType: {
                serializedName: "properties.administratorType",
                type: {
                    name: "String"
                }
            }, sid: {
                serializedName: "properties.sid",
                type: {
                    name: "String"
                }
            } })
    }
};
const ManagedIdentitySqlControlSettingsModel = {
    type: {
        name: "Composite",
        className: "ManagedIdentitySqlControlSettingsModel",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { grantSqlControlToManagedIdentity: {
                serializedName: "properties.grantSqlControlToManagedIdentity",
                type: {
                    name: "Composite",
                    className: "ManagedIdentitySqlControlSettingsModelPropertiesGrantSqlControlToManagedIdentity"
                }
            } })
    }
};
const RestorableDroppedSqlPool = {
    type: {
        name: "Composite",
        className: "RestorableDroppedSqlPool",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { location: {
                serializedName: "location",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, databaseName: {
                serializedName: "properties.databaseName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, edition: {
                serializedName: "properties.edition",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, maxSizeBytes: {
                serializedName: "properties.maxSizeBytes",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, serviceLevelObjective: {
                serializedName: "properties.serviceLevelObjective",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, elasticPoolName: {
                serializedName: "properties.elasticPoolName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, creationDate: {
                serializedName: "properties.creationDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, deletionDate: {
                serializedName: "properties.deletionDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, earliestRestoreDate: {
                serializedName: "properties.earliestRestoreDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            } })
    }
};
const AttachedDatabaseConfiguration = {
    type: {
        name: "Composite",
        className: "AttachedDatabaseConfiguration",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }, systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, databaseName: {
                serializedName: "properties.databaseName",
                type: {
                    name: "String"
                }
            }, kustoPoolResourceId: {
                serializedName: "properties.clusterResourceId",
                type: {
                    name: "String"
                }
            }, attachedDatabaseNames: {
                serializedName: "properties.attachedDatabaseNames",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, defaultPrincipalsModificationKind: {
                serializedName: "properties.defaultPrincipalsModificationKind",
                type: {
                    name: "String"
                }
            }, tableLevelSharingProperties: {
                serializedName: "properties.tableLevelSharingProperties",
                type: {
                    name: "Composite",
                    className: "TableLevelSharingProperties"
                }
            } })
    }
};
const Database = {
    serializedName: "Database",
    type: {
        name: "Composite",
        className: "Database",
        uberParent: "Resource",
        polymorphicDiscriminator: {
            serializedName: "kind",
            clientName: "kind"
        },
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }, kind: {
                serializedName: "kind",
                required: true,
                type: {
                    name: "String"
                }
            }, systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            } })
    }
};
const DataConnection = {
    serializedName: "DataConnection",
    type: {
        name: "Composite",
        className: "DataConnection",
        uberParent: "Resource",
        polymorphicDiscriminator: {
            serializedName: "kind",
            clientName: "kind"
        },
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }, kind: {
                serializedName: "kind",
                required: true,
                type: {
                    name: "String"
                }
            }, systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            } })
    }
};
const ClusterPrincipalAssignment = {
    type: {
        name: "Composite",
        className: "ClusterPrincipalAssignment",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }, principalId: {
                serializedName: "properties.principalId",
                type: {
                    name: "String"
                }
            }, role: {
                serializedName: "properties.role",
                type: {
                    name: "String"
                }
            }, tenantId: {
                serializedName: "properties.tenantId",
                type: {
                    name: "String"
                }
            }, principalType: {
                serializedName: "properties.principalType",
                type: {
                    name: "String"
                }
            }, tenantName: {
                serializedName: "properties.tenantName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, principalName: {
                serializedName: "properties.principalName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const DatabasePrincipalAssignment = {
    type: {
        name: "Composite",
        className: "DatabasePrincipalAssignment",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }, principalId: {
                serializedName: "properties.principalId",
                type: {
                    name: "String"
                }
            }, role: {
                serializedName: "properties.role",
                type: {
                    name: "String"
                }
            }, tenantId: {
                serializedName: "properties.tenantId",
                type: {
                    name: "String"
                }
            }, principalType: {
                serializedName: "properties.principalType",
                type: {
                    name: "String"
                }
            }, tenantName: {
                serializedName: "properties.tenantName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, principalName: {
                serializedName: "properties.principalName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const PrivateLinkHub = {
    type: {
        name: "Composite",
        className: "PrivateLinkHub",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { provisioningState: {
                serializedName: "properties.provisioningState",
                type: {
                    name: "String"
                }
            }, privateEndpointConnections: {
                serializedName: "properties.privateEndpointConnections",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateEndpointConnectionForPrivateLinkHubBasic"
                        }
                    }
                }
            } })
    }
};
const SqlPool = {
    type: {
        name: "Composite",
        className: "SqlPool",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "Sku"
                }
            }, maxSizeBytes: {
                serializedName: "properties.maxSizeBytes",
                type: {
                    name: "Number"
                }
            }, collation: {
                defaultValue: "",
                serializedName: "properties.collation",
                type: {
                    name: "String"
                }
            }, sourceDatabaseId: {
                serializedName: "properties.sourceDatabaseId",
                type: {
                    name: "String"
                }
            }, recoverableDatabaseId: {
                serializedName: "properties.recoverableDatabaseId",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                type: {
                    name: "String"
                }
            }, status: {
                serializedName: "properties.status",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, restorePointInTime: {
                serializedName: "properties.restorePointInTime",
                type: {
                    name: "DateTime"
                }
            }, createMode: {
                serializedName: "properties.createMode",
                type: {
                    name: "String"
                }
            }, creationDate: {
                serializedName: "properties.creationDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, storageAccountType: {
                defaultValue: "GRS",
                serializedName: "properties.storageAccountType",
                type: {
                    name: "String"
                }
            }, sourceDatabaseDeletionDate: {
                serializedName: "properties.sourceDatabaseDeletionDate",
                type: {
                    name: "DateTime"
                }
            } })
    }
};
const Workspace = {
    type: {
        name: "Composite",
        className: "Workspace",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "ManagedIdentity"
                }
            }, defaultDataLakeStorage: {
                serializedName: "properties.defaultDataLakeStorage",
                type: {
                    name: "Composite",
                    className: "DataLakeStorageAccountDetails"
                }
            }, sqlAdministratorLoginPassword: {
                serializedName: "properties.sqlAdministratorLoginPassword",
                type: {
                    name: "String"
                }
            }, managedResourceGroupName: {
                serializedName: "properties.managedResourceGroupName",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, sqlAdministratorLogin: {
                serializedName: "properties.sqlAdministratorLogin",
                type: {
                    name: "String"
                }
            }, virtualNetworkProfile: {
                serializedName: "properties.virtualNetworkProfile",
                type: {
                    name: "Composite",
                    className: "VirtualNetworkProfile"
                }
            }, connectivityEndpoints: {
                serializedName: "properties.connectivityEndpoints",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, managedVirtualNetwork: {
                serializedName: "properties.managedVirtualNetwork",
                type: {
                    name: "String"
                }
            }, privateEndpointConnections: {
                serializedName: "properties.privateEndpointConnections",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateEndpointConnection"
                        }
                    }
                }
            }, encryption: {
                serializedName: "properties.encryption",
                type: {
                    name: "Composite",
                    className: "EncryptionDetails"
                }
            }, workspaceUID: {
                serializedName: "properties.workspaceUID",
                readOnly: true,
                type: {
                    name: "Uuid"
                }
            }, extraProperties: {
                serializedName: "properties.extraProperties",
                readOnly: true,
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Dictionary", value: { type: { name: "any" } } }
                    }
                }
            }, managedVirtualNetworkSettings: {
                serializedName: "properties.managedVirtualNetworkSettings",
                type: {
                    name: "Composite",
                    className: "ManagedVirtualNetworkSettings"
                }
            }, workspaceRepositoryConfiguration: {
                serializedName: "properties.workspaceRepositoryConfiguration",
                type: {
                    name: "Composite",
                    className: "WorkspaceRepositoryConfiguration"
                }
            }, purviewConfiguration: {
                serializedName: "properties.purviewConfiguration",
                type: {
                    name: "Composite",
                    className: "PurviewConfiguration"
                }
            }, adlaResourceId: {
                serializedName: "properties.adlaResourceId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, publicNetworkAccess: {
                serializedName: "properties.publicNetworkAccess",
                type: {
                    name: "String"
                }
            }, cspWorkspaceAdminProperties: {
                serializedName: "properties.cspWorkspaceAdminProperties",
                type: {
                    name: "Composite",
                    className: "CspWorkspaceAdminProperties"
                }
            }, settings: {
                serializedName: "properties.settings",
                readOnly: true,
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Dictionary", value: { type: { name: "any" } } }
                    }
                }
            }, azureADOnlyAuthentication: {
                serializedName: "properties.azureADOnlyAuthentication",
                type: {
                    name: "Boolean"
                }
            }, trustedServiceBypassEnabled: {
                defaultValue: false,
                serializedName: "properties.trustedServiceBypassEnabled",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const BigDataPoolResourceInfo = {
    type: {
        name: "Composite",
        className: "BigDataPoolResourceInfo",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { provisioningState: {
                serializedName: "properties.provisioningState",
                type: {
                    name: "String"
                }
            }, autoScale: {
                serializedName: "properties.autoScale",
                type: {
                    name: "Composite",
                    className: "AutoScaleProperties"
                }
            }, creationDate: {
                serializedName: "properties.creationDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, autoPause: {
                serializedName: "properties.autoPause",
                type: {
                    name: "Composite",
                    className: "AutoPauseProperties"
                }
            }, isComputeIsolationEnabled: {
                serializedName: "properties.isComputeIsolationEnabled",
                type: {
                    name: "Boolean"
                }
            }, sessionLevelPackagesEnabled: {
                serializedName: "properties.sessionLevelPackagesEnabled",
                type: {
                    name: "Boolean"
                }
            }, cacheSize: {
                serializedName: "properties.cacheSize",
                type: {
                    name: "Number"
                }
            }, dynamicExecutorAllocation: {
                serializedName: "properties.dynamicExecutorAllocation",
                type: {
                    name: "Composite",
                    className: "DynamicExecutorAllocation"
                }
            }, sparkEventsFolder: {
                serializedName: "properties.sparkEventsFolder",
                type: {
                    name: "String"
                }
            }, nodeCount: {
                serializedName: "properties.nodeCount",
                type: {
                    name: "Number"
                }
            }, libraryRequirements: {
                serializedName: "properties.libraryRequirements",
                type: {
                    name: "Composite",
                    className: "LibraryRequirements"
                }
            }, customLibraries: {
                serializedName: "properties.customLibraries",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LibraryInfo"
                        }
                    }
                }
            }, sparkConfigProperties: {
                serializedName: "properties.sparkConfigProperties",
                type: {
                    name: "Composite",
                    className: "SparkConfigProperties"
                }
            }, sparkVersion: {
                serializedName: "properties.sparkVersion",
                type: {
                    name: "String"
                }
            }, defaultSparkLogFolder: {
                serializedName: "properties.defaultSparkLogFolder",
                type: {
                    name: "String"
                }
            }, nodeSize: {
                serializedName: "properties.nodeSize",
                type: {
                    name: "String"
                }
            }, nodeSizeFamily: {
                serializedName: "properties.nodeSizeFamily",
                type: {
                    name: "String"
                }
            }, lastSucceededTimestamp: {
                serializedName: "properties.lastSucceededTimestamp",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            } })
    }
};
const KustoPool = {
    type: {
        name: "Composite",
        className: "KustoPool",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "AzureSku"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }, state: {
                serializedName: "properties.state",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, uri: {
                serializedName: "properties.uri",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, dataIngestionUri: {
                serializedName: "properties.dataIngestionUri",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, stateReason: {
                serializedName: "properties.stateReason",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, optimizedAutoscale: {
                serializedName: "properties.optimizedAutoscale",
                type: {
                    name: "Composite",
                    className: "OptimizedAutoscale"
                }
            }, enableStreamingIngest: {
                defaultValue: false,
                serializedName: "properties.enableStreamingIngest",
                type: {
                    name: "Boolean"
                }
            }, enablePurge: {
                defaultValue: false,
                serializedName: "properties.enablePurge",
                type: {
                    name: "Boolean"
                }
            }, languageExtensions: {
                serializedName: "properties.languageExtensions",
                type: {
                    name: "Composite",
                    className: "LanguageExtensionsList"
                }
            }, workspaceUID: {
                serializedName: "properties.workspaceUID",
                type: {
                    name: "String"
                }
            } })
    }
};
const SubResource = {
    type: {
        name: "Composite",
        className: "SubResource",
        modelProperties: Object.assign({}, AzureEntityResource.type.modelProperties)
    }
};
const ReadWriteDatabase = {
    serializedName: "ReadWrite",
    type: {
        name: "Composite",
        className: "ReadWriteDatabase",
        uberParent: "Resource",
        polymorphicDiscriminator: Resource.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, Database.type.modelProperties), { provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, softDeletePeriod: {
                serializedName: "properties.softDeletePeriod",
                type: {
                    name: "TimeSpan"
                }
            }, hotCachePeriod: {
                serializedName: "properties.hotCachePeriod",
                type: {
                    name: "TimeSpan"
                }
            }, statistics: {
                serializedName: "properties.statistics",
                type: {
                    name: "Composite",
                    className: "DatabaseStatistics"
                }
            }, isFollowed: {
                serializedName: "properties.isFollowed",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const ReadOnlyFollowingDatabase = {
    serializedName: "ReadOnlyFollowing",
    type: {
        name: "Composite",
        className: "ReadOnlyFollowingDatabase",
        uberParent: "Resource",
        polymorphicDiscriminator: Resource.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, Database.type.modelProperties), { provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, softDeletePeriod: {
                serializedName: "properties.softDeletePeriod",
                readOnly: true,
                type: {
                    name: "TimeSpan"
                }
            }, hotCachePeriod: {
                serializedName: "properties.hotCachePeriod",
                type: {
                    name: "TimeSpan"
                }
            }, statistics: {
                serializedName: "properties.statistics",
                type: {
                    name: "Composite",
                    className: "DatabaseStatistics"
                }
            }, leaderClusterResourceId: {
                serializedName: "properties.leaderClusterResourceId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, attachedDatabaseConfigurationName: {
                serializedName: "properties.attachedDatabaseConfigurationName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, principalsModificationKind: {
                serializedName: "properties.principalsModificationKind",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const EventHubDataConnection = {
    serializedName: "EventHub",
    type: {
        name: "Composite",
        className: "EventHubDataConnection",
        uberParent: "Resource",
        polymorphicDiscriminator: Resource.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, DataConnection.type.modelProperties), { eventHubResourceId: {
                serializedName: "properties.eventHubResourceId",
                type: {
                    name: "String"
                }
            }, consumerGroup: {
                serializedName: "properties.consumerGroup",
                type: {
                    name: "String"
                }
            }, tableName: {
                serializedName: "properties.tableName",
                type: {
                    name: "String"
                }
            }, mappingRuleName: {
                serializedName: "properties.mappingRuleName",
                type: {
                    name: "String"
                }
            }, dataFormat: {
                serializedName: "properties.dataFormat",
                type: {
                    name: "String"
                }
            }, eventSystemProperties: {
                serializedName: "properties.eventSystemProperties",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, compression: {
                serializedName: "properties.compression",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, managedIdentityResourceId: {
                serializedName: "properties.managedIdentityResourceId",
                type: {
                    name: "String"
                }
            } })
    }
};
const IotHubDataConnection = {
    serializedName: "IotHub",
    type: {
        name: "Composite",
        className: "IotHubDataConnection",
        uberParent: "Resource",
        polymorphicDiscriminator: Resource.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, DataConnection.type.modelProperties), { iotHubResourceId: {
                serializedName: "properties.iotHubResourceId",
                type: {
                    name: "String"
                }
            }, consumerGroup: {
                serializedName: "properties.consumerGroup",
                type: {
                    name: "String"
                }
            }, tableName: {
                serializedName: "properties.tableName",
                type: {
                    name: "String"
                }
            }, mappingRuleName: {
                serializedName: "properties.mappingRuleName",
                type: {
                    name: "String"
                }
            }, dataFormat: {
                serializedName: "properties.dataFormat",
                type: {
                    name: "String"
                }
            }, eventSystemProperties: {
                serializedName: "properties.eventSystemProperties",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, sharedAccessPolicyName: {
                serializedName: "properties.sharedAccessPolicyName",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const EventGridDataConnection = {
    serializedName: "EventGrid",
    type: {
        name: "Composite",
        className: "EventGridDataConnection",
        uberParent: "Resource",
        polymorphicDiscriminator: Resource.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, DataConnection.type.modelProperties), { storageAccountResourceId: {
                serializedName: "properties.storageAccountResourceId",
                type: {
                    name: "String"
                }
            }, eventHubResourceId: {
                serializedName: "properties.eventHubResourceId",
                type: {
                    name: "String"
                }
            }, consumerGroup: {
                serializedName: "properties.consumerGroup",
                type: {
                    name: "String"
                }
            }, tableName: {
                serializedName: "properties.tableName",
                type: {
                    name: "String"
                }
            }, mappingRuleName: {
                serializedName: "properties.mappingRuleName",
                type: {
                    name: "String"
                }
            }, dataFormat: {
                serializedName: "properties.dataFormat",
                type: {
                    name: "String"
                }
            }, ignoreFirstRecord: {
                serializedName: "properties.ignoreFirstRecord",
                type: {
                    name: "Boolean"
                }
            }, blobStorageEventType: {
                serializedName: "properties.blobStorageEventType",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const LibraryResource = {
    type: {
        name: "Composite",
        className: "LibraryResource",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { namePropertiesName: {
                serializedName: "properties.name",
                type: {
                    name: "String"
                }
            }, path: {
                serializedName: "properties.path",
                type: {
                    name: "String"
                }
            }, containerName: {
                serializedName: "properties.containerName",
                type: {
                    name: "String"
                }
            }, uploadedTimestamp: {
                serializedName: "properties.uploadedTimestamp",
                type: {
                    name: "DateTime"
                }
            }, typePropertiesType: {
                serializedName: "properties.type",
                type: {
                    name: "String"
                }
            }, provisioningStatus: {
                serializedName: "properties.provisioningStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, creatorId: {
                serializedName: "properties.creatorId",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const IntegrationRuntimeResource = {
    type: {
        name: "Composite",
        className: "IntegrationRuntimeResource",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "IntegrationRuntime"
                }
            } })
    }
};
const SparkConfigurationResource = {
    type: {
        name: "Composite",
        className: "SparkConfigurationResource",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            }, configs: {
                serializedName: "properties.configs",
                required: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, annotations: {
                serializedName: "properties.annotations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, notes: {
                serializedName: "properties.notes",
                type: {
                    name: "String"
                }
            }, createdBy: {
                serializedName: "properties.createdBy",
                type: {
                    name: "String"
                }
            }, created: {
                serializedName: "properties.created",
                type: {
                    name: "DateTime"
                }
            } })
    }
};
let discriminators = {
    IntegrationRuntime: IntegrationRuntime,
    SsisObjectMetadata: SsisObjectMetadata,
    IntegrationRuntimeStatus: IntegrationRuntimeStatus,
    SecretBase: SecretBase,
    CustomSetupBase: CustomSetupBase,
    LinkedIntegrationRuntimeType: LinkedIntegrationRuntimeType,
    "IntegrationRuntime.Managed": ManagedIntegrationRuntime,
    "IntegrationRuntime.SelfHosted": SelfHostedIntegrationRuntime,
    "SsisObjectMetadata.Folder": SsisFolder,
    "SsisObjectMetadata.Project": SsisProject,
    "SsisObjectMetadata.Package": SsisPackage,
    "SsisObjectMetadata.Environment": SsisEnvironment,
    "IntegrationRuntimeStatus.Managed": ManagedIntegrationRuntimeStatus,
    "IntegrationRuntimeStatus.SelfHosted": SelfHostedIntegrationRuntimeStatus,
    "SecretBase.SecureString": SecureString,
    "CustomSetupBase.CmdkeySetup": CmdkeySetup,
    "CustomSetupBase.EnvironmentVariableSetup": EnvironmentVariableSetup,
    "CustomSetupBase.ComponentSetup": ComponentSetup,
    "LinkedIntegrationRuntimeType.Key": LinkedIntegrationRuntimeKeyAuthorization,
    "LinkedIntegrationRuntimeType.RBAC": LinkedIntegrationRuntimeRbacAuthorization,
    "Resource.Database": Database,
    "Resource.DataConnection": DataConnection,
    "Resource.ReadWrite": ReadWriteDatabase,
    "Resource.ReadOnlyFollowing": ReadOnlyFollowingDatabase,
    "Resource.EventHub": EventHubDataConnection,
    "Resource.IotHub": IotHubDataConnection,
    "Resource.EventGrid": EventGridDataConnection
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Resource: Resource,
    ErrorResponse: ErrorResponse,
    ErrorDetail: ErrorDetail,
    ErrorAdditionalInfo: ErrorAdditionalInfo,
    AzureADOnlyAuthenticationListResult: AzureADOnlyAuthenticationListResult,
    CheckNameAvailabilityRequest: CheckNameAvailabilityRequest,
    CheckNameAvailabilityResponse: CheckNameAvailabilityResponse,
    IpFirewallRuleInfoListResult: IpFirewallRuleInfoListResult,
    IpFirewallRuleProperties: IpFirewallRuleProperties,
    ReplaceAllIpFirewallRulesRequest: ReplaceAllIpFirewallRulesRequest,
    ReplaceAllFirewallRulesOperationResponse: ReplaceAllFirewallRulesOperationResponse,
    KeyInfoListResult: KeyInfoListResult,
    AvailableRpOperation: AvailableRpOperation,
    AvailableRpOperationDisplayInfo: AvailableRpOperationDisplayInfo,
    OperationMetaServiceSpecification: OperationMetaServiceSpecification,
    OperationMetaMetricSpecification: OperationMetaMetricSpecification,
    OperationMetaMetricDimensionSpecification: OperationMetaMetricDimensionSpecification,
    OperationMetaLogSpecification: OperationMetaLogSpecification,
    OperationResource: OperationResource,
    PrivateEndpointConnectionProperties: PrivateEndpointConnectionProperties,
    PrivateEndpoint: PrivateEndpoint,
    PrivateLinkServiceConnectionState: PrivateLinkServiceConnectionState,
    PrivateEndpointConnectionList: PrivateEndpointConnectionList,
    PrivateLinkResourceListResult: PrivateLinkResourceListResult,
    PrivateLinkResourceProperties: PrivateLinkResourceProperties,
    PrivateLinkHubInfoListResult: PrivateLinkHubInfoListResult,
    PrivateEndpointConnectionForPrivateLinkHubBasic: PrivateEndpointConnectionForPrivateLinkHubBasic,
    PrivateLinkHubPatchInfo: PrivateLinkHubPatchInfo,
    PrivateEndpointConnectionForPrivateLinkHubResourceCollectionResponse: PrivateEndpointConnectionForPrivateLinkHubResourceCollectionResponse,
    PrivateEndpointConnectionForPrivateLinkHubBasicAutoGenerated: PrivateEndpointConnectionForPrivateLinkHubBasicAutoGenerated,
    Sku: Sku,
    SqlPoolPatchInfo: SqlPoolPatchInfo,
    SqlPoolInfoListResult: SqlPoolInfoListResult,
    ResourceMoveDefinition: ResourceMoveDefinition,
    GeoBackupPolicyListResult: GeoBackupPolicyListResult,
    RestorePointListResult: RestorePointListResult,
    CreateSqlPoolRestorePointDefinition: CreateSqlPoolRestorePointDefinition,
    ReplicationLinkListResult: ReplicationLinkListResult,
    MaintenanceWindowTimeRange: MaintenanceWindowTimeRange,
    TransparentDataEncryptionListResult: TransparentDataEncryptionListResult,
    SqlPoolBlobAuditingPolicySqlPoolOperationListResult: SqlPoolBlobAuditingPolicySqlPoolOperationListResult,
    SqlPoolUsageListResult: SqlPoolUsageListResult,
    SqlPoolUsage: SqlPoolUsage,
    SensitivityLabelListResult: SensitivityLabelListResult,
    SensitivityLabelUpdateList: SensitivityLabelUpdateList,
    RecommendedSensitivityLabelUpdateList: RecommendedSensitivityLabelUpdateList,
    SqlPoolSchemaListResult: SqlPoolSchemaListResult,
    SqlPoolTableListResult: SqlPoolTableListResult,
    SqlPoolColumnListResult: SqlPoolColumnListResult,
    SqlPoolVulnerabilityAssessmentListResult: SqlPoolVulnerabilityAssessmentListResult,
    VulnerabilityAssessmentRecurringScansProperties: VulnerabilityAssessmentRecurringScansProperties,
    VulnerabilityAssessmentScanRecordListResult: VulnerabilityAssessmentScanRecordListResult,
    VulnerabilityAssessmentScanError: VulnerabilityAssessmentScanError,
    ListSqlPoolSecurityAlertPolicies: ListSqlPoolSecurityAlertPolicies,
    SqlPoolVulnerabilityAssessmentRuleBaselineItem: SqlPoolVulnerabilityAssessmentRuleBaselineItem,
    ExtendedSqlPoolBlobAuditingPolicyListResult: ExtendedSqlPoolBlobAuditingPolicyListResult,
    DataMaskingRuleListResult: DataMaskingRuleListResult,
    SqlPoolBlobAuditingPolicyListResult: SqlPoolBlobAuditingPolicyListResult,
    WorkloadGroupListResult: WorkloadGroupListResult,
    WorkloadClassifierListResult: WorkloadClassifierListResult,
    ServerBlobAuditingPolicyListResult: ServerBlobAuditingPolicyListResult,
    ExtendedServerBlobAuditingPolicyListResult: ExtendedServerBlobAuditingPolicyListResult,
    ServerSecurityAlertPolicyListResult: ServerSecurityAlertPolicyListResult,
    ServerVulnerabilityAssessmentListResult: ServerVulnerabilityAssessmentListResult,
    EncryptionProtectorListResult: EncryptionProtectorListResult,
    ServerUsageListResult: ServerUsageListResult,
    ServerUsage: ServerUsage,
    RecoverableSqlPoolListResult: RecoverableSqlPoolListResult,
    WorkspaceInfoListResult: WorkspaceInfoListResult,
    DataLakeStorageAccountDetails: DataLakeStorageAccountDetails,
    VirtualNetworkProfile: VirtualNetworkProfile,
    EncryptionDetails: EncryptionDetails,
    CustomerManagedKeyDetails: CustomerManagedKeyDetails,
    WorkspaceKeyDetails: WorkspaceKeyDetails,
    KekIdentityProperties: KekIdentityProperties,
    ManagedVirtualNetworkSettings: ManagedVirtualNetworkSettings,
    WorkspaceRepositoryConfiguration: WorkspaceRepositoryConfiguration,
    PurviewConfiguration: PurviewConfiguration,
    CspWorkspaceAdminProperties: CspWorkspaceAdminProperties,
    ManagedIdentity: ManagedIdentity,
    UserAssignedManagedIdentity: UserAssignedManagedIdentity,
    WorkspacePatchInfo: WorkspacePatchInfo,
    ManagedIdentitySqlControlSettingsModelPropertiesGrantSqlControlToManagedIdentity: ManagedIdentitySqlControlSettingsModelPropertiesGrantSqlControlToManagedIdentity,
    RestorableDroppedSqlPoolListResult: RestorableDroppedSqlPoolListResult,
    AutoScaleProperties: AutoScaleProperties,
    AutoPauseProperties: AutoPauseProperties,
    DynamicExecutorAllocation: DynamicExecutorAllocation,
    LibraryRequirements: LibraryRequirements,
    LibraryInfo: LibraryInfo,
    SparkConfigProperties: SparkConfigProperties,
    BigDataPoolPatchInfo: BigDataPoolPatchInfo,
    BigDataPoolResourceInfoListResult: BigDataPoolResourceInfoListResult,
    LibraryListResponse: LibraryListResponse,
    UpdateIntegrationRuntimeRequest: UpdateIntegrationRuntimeRequest,
    IntegrationRuntime: IntegrationRuntime,
    IntegrationRuntimeNodeIpAddress: IntegrationRuntimeNodeIpAddress,
    GetSsisObjectMetadataRequest: GetSsisObjectMetadataRequest,
    SsisObjectMetadataListResponse: SsisObjectMetadataListResponse,
    SsisObjectMetadata: SsisObjectMetadata,
    SelfHostedIntegrationRuntimeNode: SelfHostedIntegrationRuntimeNode,
    UpdateIntegrationRuntimeNodeRequest: UpdateIntegrationRuntimeNodeRequest,
    IntegrationRuntimeListResponse: IntegrationRuntimeListResponse,
    IntegrationRuntimeConnectionInfo: IntegrationRuntimeConnectionInfo,
    IntegrationRuntimeStatusResponse: IntegrationRuntimeStatusResponse,
    IntegrationRuntimeStatus: IntegrationRuntimeStatus,
    IntegrationRuntimeRegenerateKeyParameters: IntegrationRuntimeRegenerateKeyParameters,
    IntegrationRuntimeAuthKeys: IntegrationRuntimeAuthKeys,
    IntegrationRuntimeMonitoringData: IntegrationRuntimeMonitoringData,
    IntegrationRuntimeNodeMonitoringData: IntegrationRuntimeNodeMonitoringData,
    SsisObjectMetadataStatusResponse: SsisObjectMetadataStatusResponse,
    IntegrationRuntimeOutboundNetworkDependenciesEndpointsResponse: IntegrationRuntimeOutboundNetworkDependenciesEndpointsResponse,
    IntegrationRuntimeOutboundNetworkDependenciesCategoryEndpoint: IntegrationRuntimeOutboundNetworkDependenciesCategoryEndpoint,
    IntegrationRuntimeOutboundNetworkDependenciesEndpoint: IntegrationRuntimeOutboundNetworkDependenciesEndpoint,
    IntegrationRuntimeOutboundNetworkDependenciesEndpointDetails: IntegrationRuntimeOutboundNetworkDependenciesEndpointDetails,
    SparkConfigurationListResponse: SparkConfigurationListResponse,
    OperationListResult: OperationListResult,
    Operation: Operation,
    OperationDisplay: OperationDisplay,
    SkuDescriptionList: SkuDescriptionList,
    SkuDescription: SkuDescription,
    SkuLocationInfoItem: SkuLocationInfoItem,
    KustoPoolCheckNameRequest: KustoPoolCheckNameRequest,
    CheckNameResult: CheckNameResult,
    KustoPoolListResult: KustoPoolListResult,
    AzureSku: AzureSku,
    OptimizedAutoscale: OptimizedAutoscale,
    LanguageExtensionsList: LanguageExtensionsList,
    LanguageExtension: LanguageExtension,
    SystemData: SystemData,
    ListResourceSkusResult: ListResourceSkusResult,
    AzureResourceSku: AzureResourceSku,
    AzureCapacity: AzureCapacity,
    DatabaseCheckNameRequest: DatabaseCheckNameRequest,
    FollowerDatabaseListResult: FollowerDatabaseListResult,
    FollowerDatabaseDefinition: FollowerDatabaseDefinition,
    AttachedDatabaseConfigurationListResult: AttachedDatabaseConfigurationListResult,
    TableLevelSharingProperties: TableLevelSharingProperties,
    DatabaseListResult: DatabaseListResult,
    DataConnectionCheckNameRequest: DataConnectionCheckNameRequest,
    DataConnectionValidation: DataConnectionValidation,
    DataConnectionValidationListResult: DataConnectionValidationListResult,
    DataConnectionValidationResult: DataConnectionValidationResult,
    DataConnectionListResult: DataConnectionListResult,
    ClusterPrincipalAssignmentCheckNameRequest: ClusterPrincipalAssignmentCheckNameRequest,
    ClusterPrincipalAssignmentListResult: ClusterPrincipalAssignmentListResult,
    DatabasePrincipalAssignmentCheckNameRequest: DatabasePrincipalAssignmentCheckNameRequest,
    DatabasePrincipalAssignmentListResult: DatabasePrincipalAssignmentListResult,
    TopQueries: TopQueries,
    QueryStatistic: QueryStatistic,
    QueryInterval: QueryInterval,
    QueryMetric: QueryMetric,
    TopQueriesListResult: TopQueriesListResult,
    IntegrationRuntimeComputeProperties: IntegrationRuntimeComputeProperties,
    IntegrationRuntimeDataFlowProperties: IntegrationRuntimeDataFlowProperties,
    IntegrationRuntimeVNetProperties: IntegrationRuntimeVNetProperties,
    IntegrationRuntimeSsisProperties: IntegrationRuntimeSsisProperties,
    IntegrationRuntimeSsisCatalogInfo: IntegrationRuntimeSsisCatalogInfo,
    SecretBase: SecretBase,
    IntegrationRuntimeCustomSetupScriptProperties: IntegrationRuntimeCustomSetupScriptProperties,
    IntegrationRuntimeDataProxyProperties: IntegrationRuntimeDataProxyProperties,
    EntityReference: EntityReference,
    CustomSetupBase: CustomSetupBase,
    LinkedIntegrationRuntimeType: LinkedIntegrationRuntimeType,
    ManagedIntegrationRuntimeNode: ManagedIntegrationRuntimeNode,
    ManagedIntegrationRuntimeError: ManagedIntegrationRuntimeError,
    ManagedIntegrationRuntimeOperationResult: ManagedIntegrationRuntimeOperationResult,
    LinkedIntegrationRuntime: LinkedIntegrationRuntime,
    SsisEnvironmentReference: SsisEnvironmentReference,
    SsisParameter: SsisParameter,
    SsisVariable: SsisVariable,
    DatabaseStatistics: DatabaseStatistics,
    ProxyResource: ProxyResource,
    TrackedResource: TrackedResource,
    AzureEntityResource: AzureEntityResource,
    KustoPoolUpdate: KustoPoolUpdate,
    PrivateEndpointConnectionForPrivateLinkHub: PrivateEndpointConnectionForPrivateLinkHub,
    ManagedIntegrationRuntime: ManagedIntegrationRuntime,
    SelfHostedIntegrationRuntime: SelfHostedIntegrationRuntime,
    SsisFolder: SsisFolder,
    SsisProject: SsisProject,
    SsisPackage: SsisPackage,
    SsisEnvironment: SsisEnvironment,
    ManagedIntegrationRuntimeStatus: ManagedIntegrationRuntimeStatus,
    SelfHostedIntegrationRuntimeStatus: SelfHostedIntegrationRuntimeStatus,
    SecureString: SecureString,
    CmdkeySetup: CmdkeySetup,
    EnvironmentVariableSetup: EnvironmentVariableSetup,
    ComponentSetup: ComponentSetup,
    LinkedIntegrationRuntimeKeyAuthorization: LinkedIntegrationRuntimeKeyAuthorization,
    LinkedIntegrationRuntimeRbacAuthorization: LinkedIntegrationRuntimeRbacAuthorization,
    AzureADOnlyAuthentication: AzureADOnlyAuthentication,
    IpFirewallRuleInfo: IpFirewallRuleInfo,
    Key: Key,
    PrivateEndpointConnection: PrivateEndpointConnection,
    PrivateLinkResource: PrivateLinkResource,
    MetadataSyncConfig: MetadataSyncConfig,
    GeoBackupPolicy: GeoBackupPolicy,
    DataWarehouseUserActivities: DataWarehouseUserActivities,
    RestorePoint: RestorePoint,
    ReplicationLink: ReplicationLink,
    MaintenanceWindows: MaintenanceWindows,
    MaintenanceWindowOptions: MaintenanceWindowOptions,
    TransparentDataEncryption: TransparentDataEncryption,
    SqlPoolBlobAuditingPolicy: SqlPoolBlobAuditingPolicy,
    SqlPoolOperation: SqlPoolOperation,
    SensitivityLabel: SensitivityLabel,
    SensitivityLabelUpdate: SensitivityLabelUpdate,
    RecommendedSensitivityLabelUpdate: RecommendedSensitivityLabelUpdate,
    SqlPoolSchema: SqlPoolSchema,
    SqlPoolTable: SqlPoolTable,
    SqlPoolColumn: SqlPoolColumn,
    SqlPoolConnectionPolicy: SqlPoolConnectionPolicy,
    SqlPoolVulnerabilityAssessment: SqlPoolVulnerabilityAssessment,
    VulnerabilityAssessmentScanRecord: VulnerabilityAssessmentScanRecord,
    SqlPoolVulnerabilityAssessmentScansExport: SqlPoolVulnerabilityAssessmentScansExport,
    SqlPoolSecurityAlertPolicy: SqlPoolSecurityAlertPolicy,
    SqlPoolVulnerabilityAssessmentRuleBaseline: SqlPoolVulnerabilityAssessmentRuleBaseline,
    ExtendedSqlPoolBlobAuditingPolicy: ExtendedSqlPoolBlobAuditingPolicy,
    DataMaskingPolicy: DataMaskingPolicy,
    DataMaskingRule: DataMaskingRule,
    WorkloadGroup: WorkloadGroup,
    WorkloadClassifier: WorkloadClassifier,
    ServerBlobAuditingPolicy: ServerBlobAuditingPolicy,
    ExtendedServerBlobAuditingPolicy: ExtendedServerBlobAuditingPolicy,
    ServerSecurityAlertPolicy: ServerSecurityAlertPolicy,
    ServerVulnerabilityAssessment: ServerVulnerabilityAssessment,
    EncryptionProtector: EncryptionProtector,
    RecoverableSqlPool: RecoverableSqlPool,
    WorkspaceAadAdminInfo: WorkspaceAadAdminInfo,
    ManagedIdentitySqlControlSettingsModel: ManagedIdentitySqlControlSettingsModel,
    RestorableDroppedSqlPool: RestorableDroppedSqlPool,
    AttachedDatabaseConfiguration: AttachedDatabaseConfiguration,
    Database: Database,
    DataConnection: DataConnection,
    ClusterPrincipalAssignment: ClusterPrincipalAssignment,
    DatabasePrincipalAssignment: DatabasePrincipalAssignment,
    PrivateLinkHub: PrivateLinkHub,
    SqlPool: SqlPool,
    Workspace: Workspace,
    BigDataPoolResourceInfo: BigDataPoolResourceInfo,
    KustoPool: KustoPool,
    SubResource: SubResource,
    ReadWriteDatabase: ReadWriteDatabase,
    ReadOnlyFollowingDatabase: ReadOnlyFollowingDatabase,
    EventHubDataConnection: EventHubDataConnection,
    IotHubDataConnection: IotHubDataConnection,
    EventGridDataConnection: EventGridDataConnection,
    LibraryResource: LibraryResource,
    IntegrationRuntimeResource: IntegrationRuntimeResource,
    SparkConfigurationResource: SparkConfigurationResource,
    discriminators: discriminators
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const $host = {
    parameterPath: "$host",
    mapper: {
        serializedName: "$host",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2021-06-01",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const subscriptionId = {
    parameterPath: "subscriptionId",
    mapper: {
        constraints: {
            MinLength: 1
        },
        serializedName: "subscriptionId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const resourceGroupName = {
    parameterPath: "resourceGroupName",
    mapper: {
        constraints: {
            MaxLength: 90,
            MinLength: 1
        },
        serializedName: "resourceGroupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const workspaceName = {
    parameterPath: "workspaceName",
    mapper: {
        serializedName: "workspaceName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const azureADOnlyAuthenticationName = {
    parameterPath: "azureADOnlyAuthenticationName",
    mapper: {
        serializedName: "azureADOnlyAuthenticationName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const azureADOnlyAuthenticationInfo = {
    parameterPath: "azureADOnlyAuthenticationInfo",
    mapper: AzureADOnlyAuthentication
};
const nextLink = {
    parameterPath: "nextLink",
    mapper: {
        serializedName: "nextLink",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const request = {
    parameterPath: "request",
    mapper: CheckNameAvailabilityRequest
};
const operationId = {
    parameterPath: "operationId",
    mapper: {
        serializedName: "operationId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const ipFirewallRuleInfo = {
    parameterPath: "ipFirewallRuleInfo",
    mapper: IpFirewallRuleInfo
};
const ruleName = {
    parameterPath: "ruleName",
    mapper: {
        serializedName: "ruleName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const request1 = {
    parameterPath: "request",
    mapper: ReplaceAllIpFirewallRulesRequest
};
const keyName = {
    parameterPath: "keyName",
    mapper: {
        serializedName: "keyName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const keyProperties = {
    parameterPath: "keyProperties",
    mapper: Key
};
const privateEndpointConnectionName = {
    parameterPath: "privateEndpointConnectionName",
    mapper: {
        serializedName: "privateEndpointConnectionName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const request2 = {
    parameterPath: "request",
    mapper: PrivateEndpointConnection
};
const privateLinkResourceName = {
    parameterPath: "privateLinkResourceName",
    mapper: {
        serializedName: "privateLinkResourceName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const privateLinkHubName = {
    parameterPath: "privateLinkHubName",
    mapper: {
        serializedName: "privateLinkHubName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const privateLinkHubPatchInfo = {
    parameterPath: "privateLinkHubPatchInfo",
    mapper: PrivateLinkHubPatchInfo
};
const privateLinkHubInfo = {
    parameterPath: "privateLinkHubInfo",
    mapper: PrivateLinkHub
};
const sqlPoolName = {
    parameterPath: "sqlPoolName",
    mapper: {
        serializedName: "sqlPoolName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const sqlPoolInfo = {
    parameterPath: "sqlPoolInfo",
    mapper: SqlPoolPatchInfo
};
const sqlPoolInfo1 = {
    parameterPath: "sqlPoolInfo",
    mapper: SqlPool
};
const parameters = {
    parameterPath: "parameters",
    mapper: ResourceMoveDefinition
};
const metadataSyncConfiguration = {
    parameterPath: "metadataSyncConfiguration",
    mapper: MetadataSyncConfig
};
const parameters1 = {
    parameterPath: "parameters",
    mapper: GeoBackupPolicy
};
const geoBackupPolicyName = {
    parameterPath: "geoBackupPolicyName",
    mapper: {
        serializedName: "geoBackupPolicyName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const dataWarehouseUserActivityName = {
    parameterPath: "dataWarehouseUserActivityName",
    mapper: {
        serializedName: "dataWarehouseUserActivityName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters2 = {
    parameterPath: "parameters",
    mapper: CreateSqlPoolRestorePointDefinition
};
const restorePointName = {
    parameterPath: "restorePointName",
    mapper: {
        serializedName: "restorePointName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const linkId = {
    parameterPath: "linkId",
    mapper: {
        serializedName: "linkId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const maintenanceWindowName = {
    parameterPath: "maintenanceWindowName",
    mapper: {
        serializedName: "maintenanceWindowName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters3 = {
    parameterPath: "parameters",
    mapper: MaintenanceWindows
};
const maintenanceWindowOptionsName = {
    parameterPath: "maintenanceWindowOptionsName",
    mapper: {
        serializedName: "maintenanceWindowOptionsName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const transparentDataEncryptionName = {
    parameterPath: "transparentDataEncryptionName",
    mapper: {
        serializedName: "transparentDataEncryptionName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters4 = {
    parameterPath: "parameters",
    mapper: TransparentDataEncryption
};
const blobAuditingPolicyName = {
    parameterPath: "blobAuditingPolicyName",
    mapper: {
        defaultValue: "default",
        isConstant: true,
        serializedName: "blobAuditingPolicyName",
        type: {
            name: "String"
        }
    }
};
const parameters5 = {
    parameterPath: "parameters",
    mapper: SqlPoolBlobAuditingPolicy
};
const filter = {
    parameterPath: ["options", "filter"],
    mapper: {
        serializedName: "$filter",
        type: {
            name: "String"
        }
    }
};
const parameters6 = {
    parameterPath: "parameters",
    mapper: SensitivityLabelUpdateList
};
const includeDisabledRecommendations = {
    parameterPath: ["options", "includeDisabledRecommendations"],
    mapper: {
        serializedName: "includeDisabledRecommendations",
        type: {
            name: "Boolean"
        }
    }
};
const skipToken = {
    parameterPath: ["options", "skipToken"],
    mapper: {
        serializedName: "$skipToken",
        type: {
            name: "String"
        }
    }
};
const parameters7 = {
    parameterPath: "parameters",
    mapper: SensitivityLabel
};
const schemaName = {
    parameterPath: "schemaName",
    mapper: {
        serializedName: "schemaName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const tableName = {
    parameterPath: "tableName",
    mapper: {
        serializedName: "tableName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const columnName = {
    parameterPath: "columnName",
    mapper: {
        serializedName: "columnName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const sensitivityLabelSource = {
    parameterPath: "sensitivityLabelSource",
    mapper: {
        defaultValue: "current",
        isConstant: true,
        serializedName: "sensitivityLabelSource",
        type: {
            name: "String"
        }
    }
};
const sensitivityLabelSource1 = {
    parameterPath: "sensitivityLabelSource",
    mapper: {
        serializedName: "sensitivityLabelSource",
        required: true,
        type: {
            name: "Enum",
            allowedValues: ["current", "recommended"]
        }
    }
};
const sensitivityLabelSource2 = {
    parameterPath: "sensitivityLabelSource",
    mapper: {
        defaultValue: "recommended",
        isConstant: true,
        serializedName: "sensitivityLabelSource",
        type: {
            name: "String"
        }
    }
};
const parameters8 = {
    parameterPath: "parameters",
    mapper: RecommendedSensitivityLabelUpdateList
};
const connectionPolicyName = {
    parameterPath: "connectionPolicyName",
    mapper: {
        serializedName: "connectionPolicyName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const vulnerabilityAssessmentName = {
    parameterPath: "vulnerabilityAssessmentName",
    mapper: {
        serializedName: "vulnerabilityAssessmentName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters9 = {
    parameterPath: "parameters",
    mapper: SqlPoolVulnerabilityAssessment
};
const scanId = {
    parameterPath: "scanId",
    mapper: {
        serializedName: "scanId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const securityAlertPolicyName = {
    parameterPath: "securityAlertPolicyName",
    mapper: {
        serializedName: "securityAlertPolicyName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters10 = {
    parameterPath: "parameters",
    mapper: SqlPoolSecurityAlertPolicy
};
const parameters11 = {
    parameterPath: "parameters",
    mapper: SqlPoolVulnerabilityAssessmentRuleBaseline
};
const ruleId = {
    parameterPath: "ruleId",
    mapper: {
        serializedName: "ruleId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const baselineName = {
    parameterPath: "baselineName",
    mapper: {
        serializedName: "baselineName",
        required: true,
        type: {
            name: "Enum",
            allowedValues: ["master", "default"]
        }
    }
};
const parameters12 = {
    parameterPath: "parameters",
    mapper: ExtendedSqlPoolBlobAuditingPolicy
};
const parameters13 = {
    parameterPath: "parameters",
    mapper: DataMaskingPolicy
};
const dataMaskingPolicyName = {
    parameterPath: "dataMaskingPolicyName",
    mapper: {
        defaultValue: "Default",
        isConstant: true,
        serializedName: "dataMaskingPolicyName",
        type: {
            name: "String"
        }
    }
};
const parameters14 = {
    parameterPath: "parameters",
    mapper: DataMaskingRule
};
const dataMaskingRuleName = {
    parameterPath: "dataMaskingRuleName",
    mapper: {
        serializedName: "dataMaskingRuleName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const workloadGroupName = {
    parameterPath: "workloadGroupName",
    mapper: {
        serializedName: "workloadGroupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters15 = {
    parameterPath: "parameters",
    mapper: WorkloadGroup
};
const workloadClassifierName = {
    parameterPath: "workloadClassifierName",
    mapper: {
        serializedName: "workloadClassifierName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters16 = {
    parameterPath: "parameters",
    mapper: WorkloadClassifier
};
const blobAuditingPolicyName1 = {
    parameterPath: "blobAuditingPolicyName",
    mapper: {
        serializedName: "blobAuditingPolicyName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters17 = {
    parameterPath: "parameters",
    mapper: ServerBlobAuditingPolicy
};
const parameters18 = {
    parameterPath: "parameters",
    mapper: ExtendedServerBlobAuditingPolicy
};
const securityAlertPolicyName1 = {
    parameterPath: "securityAlertPolicyName",
    mapper: {
        serializedName: "securityAlertPolicyName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters19 = {
    parameterPath: "parameters",
    mapper: ServerSecurityAlertPolicy
};
const parameters20 = {
    parameterPath: "parameters",
    mapper: ServerVulnerabilityAssessment
};
const encryptionProtectorName = {
    parameterPath: "encryptionProtectorName",
    mapper: {
        serializedName: "encryptionProtectorName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters21 = {
    parameterPath: "parameters",
    mapper: EncryptionProtector
};
const workspacePatchInfo = {
    parameterPath: "workspacePatchInfo",
    mapper: WorkspacePatchInfo
};
const workspaceInfo = {
    parameterPath: "workspaceInfo",
    mapper: Workspace
};
const aadAdminInfo = {
    parameterPath: "aadAdminInfo",
    mapper: WorkspaceAadAdminInfo
};
const managedIdentitySqlControlSettings = {
    parameterPath: "managedIdentitySqlControlSettings",
    mapper: ManagedIdentitySqlControlSettingsModel
};
const restorableDroppedSqlPoolId = {
    parameterPath: "restorableDroppedSqlPoolId",
    mapper: {
        serializedName: "restorableDroppedSqlPoolId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const apiVersion1 = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2021-06-01-preview",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const bigDataPoolName = {
    parameterPath: "bigDataPoolName",
    mapper: {
        serializedName: "bigDataPoolName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const bigDataPoolPatchInfo = {
    parameterPath: "bigDataPoolPatchInfo",
    mapper: BigDataPoolPatchInfo
};
const bigDataPoolInfo = {
    parameterPath: "bigDataPoolInfo",
    mapper: BigDataPoolResourceInfo
};
const force = {
    parameterPath: ["options", "force"],
    mapper: {
        defaultValue: false,
        serializedName: "force",
        type: {
            name: "Boolean"
        }
    }
};
const libraryName = {
    parameterPath: "libraryName",
    mapper: {
        serializedName: "libraryName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const updateIntegrationRuntimeRequest = {
    parameterPath: "updateIntegrationRuntimeRequest",
    mapper: UpdateIntegrationRuntimeRequest
};
const integrationRuntimeName = {
    parameterPath: "integrationRuntimeName",
    mapper: {
        serializedName: "integrationRuntimeName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const ifNoneMatch = {
    parameterPath: ["options", "ifNoneMatch"],
    mapper: {
        serializedName: "If-None-Match",
        type: {
            name: "String"
        }
    }
};
const integrationRuntime = {
    parameterPath: "integrationRuntime",
    mapper: IntegrationRuntimeResource
};
const ifMatch = {
    parameterPath: ["options", "ifMatch"],
    mapper: {
        serializedName: "If-Match",
        type: {
            name: "String"
        }
    }
};
const nodeName = {
    parameterPath: "nodeName",
    mapper: {
        serializedName: "nodeName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const getMetadataRequest = {
    parameterPath: ["options", "getMetadataRequest"],
    mapper: GetSsisObjectMetadataRequest
};
const updateIntegrationRuntimeNodeRequest = {
    parameterPath: "updateIntegrationRuntimeNodeRequest",
    mapper: UpdateIntegrationRuntimeNodeRequest
};
const regenerateKeyParameters = {
    parameterPath: "regenerateKeyParameters",
    mapper: IntegrationRuntimeRegenerateKeyParameters
};
const sparkConfigurationName = {
    parameterPath: "sparkConfigurationName",
    mapper: {
        serializedName: "sparkConfigurationName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const kustoPoolName = {
    parameterPath: "kustoPoolName",
    mapper: KustoPoolCheckNameRequest
};
const location = {
    parameterPath: "location",
    mapper: {
        constraints: {
            MinLength: 1
        },
        serializedName: "location",
        required: true,
        type: {
            name: "String"
        }
    }
};
const kustoPoolName1 = {
    parameterPath: "kustoPoolName",
    mapper: {
        serializedName: "kustoPoolName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters22 = {
    parameterPath: "parameters",
    mapper: KustoPool
};
const parameters23 = {
    parameterPath: "parameters",
    mapper: KustoPoolUpdate
};
const languageExtensionsToAdd = {
    parameterPath: "languageExtensionsToAdd",
    mapper: LanguageExtensionsList
};
const languageExtensionsToRemove = {
    parameterPath: "languageExtensionsToRemove",
    mapper: LanguageExtensionsList
};
const followerDatabaseToRemove = {
    parameterPath: "followerDatabaseToRemove",
    mapper: FollowerDatabaseDefinition
};
const resourceName = {
    parameterPath: "resourceName",
    mapper: DatabaseCheckNameRequest
};
const attachedDatabaseConfigurationName = {
    parameterPath: "attachedDatabaseConfigurationName",
    mapper: {
        serializedName: "attachedDatabaseConfigurationName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters24 = {
    parameterPath: "parameters",
    mapper: AttachedDatabaseConfiguration
};
const databaseName = {
    parameterPath: "databaseName",
    mapper: {
        serializedName: "databaseName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters25 = {
    parameterPath: "parameters",
    mapper: Database
};
const dataConnectionName = {
    parameterPath: "dataConnectionName",
    mapper: DataConnectionCheckNameRequest
};
const parameters26 = {
    parameterPath: "parameters",
    mapper: DataConnectionValidation
};
const dataConnectionName1 = {
    parameterPath: "dataConnectionName",
    mapper: {
        serializedName: "dataConnectionName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters27 = {
    parameterPath: "parameters",
    mapper: DataConnection
};
const principalAssignmentName = {
    parameterPath: "principalAssignmentName",
    mapper: ClusterPrincipalAssignmentCheckNameRequest
};
const principalAssignmentName1 = {
    parameterPath: "principalAssignmentName",
    mapper: {
        serializedName: "principalAssignmentName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters28 = {
    parameterPath: "parameters",
    mapper: ClusterPrincipalAssignment
};
const principalAssignmentName2 = {
    parameterPath: "principalAssignmentName",
    mapper: DatabasePrincipalAssignmentCheckNameRequest
};
const parameters29 = {
    parameterPath: "parameters",
    mapper: DatabasePrincipalAssignment
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class LroImpl {
    constructor(sendOperationFn, args, spec, requestPath = spec.path, requestMethod = spec.httpMethod) {
        this.sendOperationFn = sendOperationFn;
        this.args = args;
        this.spec = spec;
        this.requestPath = requestPath;
        this.requestMethod = requestMethod;
    }
    sendInitialRequest() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return this.sendOperationFn(this.args, this.spec);
        });
    }
    sendPollRequest(path) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const _a = this.spec, restSpec = tslib.__rest(_a, ["requestBody"]);
            return this.sendOperationFn(this.args, Object.assign(Object.assign({}, restSpec), { path, httpMethod: "GET" }));
        });
    }
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing AzureADOnlyAuthentications operations. */
class AzureADOnlyAuthenticationsImpl {
    /**
     * Initialize a new instance of the class AzureADOnlyAuthentications class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of Azure Active Directory only authentication property for a workspace
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param options The options parameters.
     */
    list(resourceGroupName, workspaceName, options) {
        const iter = this.listPagingAll(resourceGroupName, workspaceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, workspaceName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, workspaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, workspaceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, workspaceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, workspaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, workspaceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a Azure Active Directory only authentication property
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param azureADOnlyAuthenticationName name of the property
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, azureADOnlyAuthenticationName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workspaceName,
            azureADOnlyAuthenticationName,
            options
        }, getOperationSpec);
    }
    /**
     * Create or Update a Azure Active Directory only authentication property for the workspaces
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param azureADOnlyAuthenticationName name of the property
     * @param azureADOnlyAuthenticationInfo Azure Active Directory Property
     * @param options The options parameters.
     */
    beginCreate(resourceGroupName, workspaceName, azureADOnlyAuthenticationName, azureADOnlyAuthenticationInfo, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                workspaceName,
                azureADOnlyAuthenticationName,
                azureADOnlyAuthenticationInfo,
                options
            }, createOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Create or Update a Azure Active Directory only authentication property for the workspaces
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param azureADOnlyAuthenticationName name of the property
     * @param azureADOnlyAuthenticationInfo Azure Active Directory Property
     * @param options The options parameters.
     */
    beginCreateAndWait(resourceGroupName, workspaceName, azureADOnlyAuthenticationName, azureADOnlyAuthenticationInfo, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreate(resourceGroupName, workspaceName, azureADOnlyAuthenticationName, azureADOnlyAuthenticationInfo, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets a list of Azure Active Directory only authentication property for a workspace
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param options The options parameters.
     */
    _list(resourceGroupName, workspaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, options }, listOperationSpec);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, workspaceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, nextLink, options }, listNextOperationSpec);
    }
}
// Operation Specifications
const serializer = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/azureADOnlyAuthentications/{azureADOnlyAuthenticationName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AzureADOnlyAuthentication
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        azureADOnlyAuthenticationName
    ],
    headerParameters: [accept],
    serializer
};
const createOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/azureADOnlyAuthentications/{azureADOnlyAuthenticationName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: AzureADOnlyAuthentication
        },
        201: {
            bodyMapper: AzureADOnlyAuthentication
        },
        202: {
            bodyMapper: AzureADOnlyAuthentication
        },
        204: {
            bodyMapper: AzureADOnlyAuthentication
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: azureADOnlyAuthenticationInfo,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        azureADOnlyAuthenticationName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const listOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/azureADOnlyAuthentications",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AzureADOnlyAuthenticationListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept],
    serializer
};
const listNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AzureADOnlyAuthenticationListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        nextLink
    ],
    headerParameters: [accept],
    serializer
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing Operations operations. */
class OperationsImpl {
    /**
     * Initialize a new instance of the class Operations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Check whether a workspace name is available
     * @param request The check request
     * @param options The options parameters.
     */
    checkNameAvailability(request, options) {
        return this.client.sendOperationRequest({ request, options }, checkNameAvailabilityOperationSpec);
    }
    /**
     * Get all available operations
     * @param options The options parameters.
     */
    list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$1);
    }
    /**
     * Get the result of an operation
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param operationId Operation ID
     * @param options The options parameters.
     */
    getLocationHeaderResult(resourceGroupName, workspaceName, operationId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, operationId, options }, getLocationHeaderResultOperationSpec);
    }
    /**
     * Get the status of an operation
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param operationId Operation ID
     * @param options The options parameters.
     */
    getAzureAsyncHeaderResult(resourceGroupName, workspaceName, operationId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, operationId, options }, getAzureAsyncHeaderResultOperationSpec);
    }
}
// Operation Specifications
const serializer$1 = coreClient.createSerializer(Mappers, /* isXml */ false);
const checkNameAvailabilityOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Synapse/checkNameAvailability",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: CheckNameAvailabilityResponse
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: request,
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1
};
const listOperationSpec$1 = {
    path: "/providers/Microsoft.Synapse/operations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: {
                        type: { name: "Composite", className: "AvailableRpOperation" }
                    }
                }
            }
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [$host],
    headerParameters: [accept],
    serializer: serializer$1
};
const getLocationHeaderResultOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/operationResults/{operationId}",
    httpMethod: "GET",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        operationId
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const getAzureAsyncHeaderResultOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/operationStatuses/{operationId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationResource
        },
        404: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        operationId
    ],
    headerParameters: [accept],
    serializer: serializer$1
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing IpFirewallRules operations. */
class IpFirewallRulesImpl {
    /**
     * Initialize a new instance of the class IpFirewallRules class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Returns a list of firewall rules
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param options The options parameters.
     */
    listByWorkspace(resourceGroupName, workspaceName, options) {
        const iter = this.listByWorkspacePagingAll(resourceGroupName, workspaceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByWorkspacePagingPage(resourceGroupName, workspaceName, options);
            }
        };
    }
    listByWorkspacePagingPage(resourceGroupName, workspaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByWorkspacePagingPage_1() {
            let result = yield tslib.__await(this._listByWorkspace(resourceGroupName, workspaceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByWorkspaceNext(resourceGroupName, workspaceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByWorkspacePagingAll(resourceGroupName, workspaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByWorkspacePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByWorkspacePagingPage(resourceGroupName, workspaceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Returns a list of firewall rules
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param options The options parameters.
     */
    _listByWorkspace(resourceGroupName, workspaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, options }, listByWorkspaceOperationSpec);
    }
    /**
     * Creates or updates a firewall rule
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param ruleName The IP firewall rule name
     * @param ipFirewallRuleInfo IP firewall rule properties
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, workspaceName, ruleName, ipFirewallRuleInfo, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                workspaceName,
                ruleName,
                ipFirewallRuleInfo,
                options
            }, createOrUpdateOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Creates or updates a firewall rule
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param ruleName The IP firewall rule name
     * @param ipFirewallRuleInfo IP firewall rule properties
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, workspaceName, ruleName, ipFirewallRuleInfo, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, workspaceName, ruleName, ipFirewallRuleInfo, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes a firewall rule
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param ruleName The IP firewall rule name
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, workspaceName, ruleName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, workspaceName, ruleName, options }, deleteOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes a firewall rule
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param ruleName The IP firewall rule name
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, workspaceName, ruleName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, workspaceName, ruleName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Get a firewall rule
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param ruleName The IP firewall rule name
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, ruleName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, ruleName, options }, getOperationSpec$1);
    }
    /**
     * Replaces firewall rules
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param request Replace all IP firewall rules request
     * @param options The options parameters.
     */
    beginReplaceAll(resourceGroupName, workspaceName, request, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, workspaceName, request, options }, replaceAllOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Replaces firewall rules
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param request Replace all IP firewall rules request
     * @param options The options parameters.
     */
    beginReplaceAllAndWait(resourceGroupName, workspaceName, request, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginReplaceAll(resourceGroupName, workspaceName, request, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListByWorkspaceNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param nextLink The nextLink from the previous successful call to the ListByWorkspace method.
     * @param options The options parameters.
     */
    _listByWorkspaceNext(resourceGroupName, workspaceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, nextLink, options }, listByWorkspaceNextOperationSpec);
    }
}
// Operation Specifications
const serializer$2 = coreClient.createSerializer(Mappers, /* isXml */ false);
const listByWorkspaceOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/firewallRules",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IpFirewallRuleInfoListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const createOrUpdateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/firewallRules/{ruleName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: IpFirewallRuleInfo
        },
        201: {
            bodyMapper: IpFirewallRuleInfo
        },
        202: {
            bodyMapper: IpFirewallRuleInfo
        },
        204: {
            bodyMapper: IpFirewallRuleInfo
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: ipFirewallRuleInfo,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        ruleName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$2
};
const deleteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/firewallRules/{ruleName}",
    httpMethod: "DELETE",
    responses: {
        200: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } }
            }
        },
        201: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } }
            }
        },
        202: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } }
            }
        },
        204: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } }
            }
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        ruleName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const getOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/firewallRules/{ruleName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IpFirewallRuleInfo
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        ruleName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const replaceAllOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/replaceAllIpFirewallRules",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ReplaceAllFirewallRulesOperationResponse
        },
        201: {
            bodyMapper: ReplaceAllFirewallRulesOperationResponse
        },
        202: {
            bodyMapper: ReplaceAllFirewallRulesOperationResponse
        },
        204: {
            bodyMapper: ReplaceAllFirewallRulesOperationResponse
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: request1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$2
};
const listByWorkspaceNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IpFirewallRuleInfoListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$2
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Keys operations. */
class KeysImpl {
    /**
     * Initialize a new instance of the class Keys class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Returns a list of keys in a workspace
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param options The options parameters.
     */
    listByWorkspace(resourceGroupName, workspaceName, options) {
        const iter = this.listByWorkspacePagingAll(resourceGroupName, workspaceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByWorkspacePagingPage(resourceGroupName, workspaceName, options);
            }
        };
    }
    listByWorkspacePagingPage(resourceGroupName, workspaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByWorkspacePagingPage_1() {
            let result = yield tslib.__await(this._listByWorkspace(resourceGroupName, workspaceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByWorkspaceNext(resourceGroupName, workspaceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByWorkspacePagingAll(resourceGroupName, workspaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByWorkspacePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByWorkspacePagingPage(resourceGroupName, workspaceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Returns a list of keys in a workspace
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param options The options parameters.
     */
    _listByWorkspace(resourceGroupName, workspaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, options }, listByWorkspaceOperationSpec$1);
    }
    /**
     * Gets a workspace key
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param keyName The name of the workspace key
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, keyName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, keyName, options }, getOperationSpec$2);
    }
    /**
     * Creates or updates a workspace key
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param keyName The name of the workspace key
     * @param keyProperties Key put request properties
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, workspaceName, keyName, keyProperties, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, keyName, keyProperties, options }, createOrUpdateOperationSpec$1);
    }
    /**
     * Deletes a workspace key
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param keyName The name of the workspace key
     * @param options The options parameters.
     */
    delete(resourceGroupName, workspaceName, keyName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, keyName, options }, deleteOperationSpec$1);
    }
    /**
     * ListByWorkspaceNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param nextLink The nextLink from the previous successful call to the ListByWorkspace method.
     * @param options The options parameters.
     */
    _listByWorkspaceNext(resourceGroupName, workspaceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, nextLink, options }, listByWorkspaceNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$3 = coreClient.createSerializer(Mappers, /* isXml */ false);
const listByWorkspaceOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/keys",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: KeyInfoListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const getOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/keys/{keyName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Key
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        keyName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const createOrUpdateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/keys/{keyName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Key
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: keyProperties,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        keyName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$3
};
const deleteOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/keys/{keyName}",
    httpMethod: "DELETE",
    responses: {
        200: {
            bodyMapper: Key
        },
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        keyName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const listByWorkspaceNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: KeyInfoListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$3
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PrivateEndpointConnections operations. */
class PrivateEndpointConnectionsImpl {
    /**
     * Initialize a new instance of the class PrivateEndpointConnections class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists private endpoint connection in workspace.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param options The options parameters.
     */
    list(resourceGroupName, workspaceName, options) {
        const iter = this.listPagingAll(resourceGroupName, workspaceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, workspaceName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, workspaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, workspaceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, workspaceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, workspaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, workspaceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a private endpoint connection.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param privateEndpointConnectionName The name of the private endpoint connection.
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, privateEndpointConnectionName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workspaceName,
            privateEndpointConnectionName,
            options
        }, getOperationSpec$3);
    }
    /**
     * Approve or reject a private endpoint connection.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param privateEndpointConnectionName The name of the private endpoint connection.
     * @param request Request body of private endpoint connection to create.
     * @param options The options parameters.
     */
    beginCreate(resourceGroupName, workspaceName, privateEndpointConnectionName, request, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                workspaceName,
                privateEndpointConnectionName,
                request,
                options
            }, createOperationSpec$1);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Approve or reject a private endpoint connection.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param privateEndpointConnectionName The name of the private endpoint connection.
     * @param request Request body of private endpoint connection to create.
     * @param options The options parameters.
     */
    beginCreateAndWait(resourceGroupName, workspaceName, privateEndpointConnectionName, request, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreate(resourceGroupName, workspaceName, privateEndpointConnectionName, request, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete a private endpoint connection.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param privateEndpointConnectionName The name of the private endpoint connection.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, workspaceName, privateEndpointConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                workspaceName,
                privateEndpointConnectionName,
                options
            }, deleteOperationSpec$2);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Delete a private endpoint connection.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param privateEndpointConnectionName The name of the private endpoint connection.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, workspaceName, privateEndpointConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, workspaceName, privateEndpointConnectionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists private endpoint connection in workspace.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param options The options parameters.
     */
    _list(resourceGroupName, workspaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, options }, listOperationSpec$2);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, workspaceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, nextLink, options }, listNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$4 = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        privateEndpointConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const createOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnection
        },
        201: {
            bodyMapper: PrivateEndpointConnection
        },
        202: {
            bodyMapper: PrivateEndpointConnection
        },
        204: {
            bodyMapper: PrivateEndpointConnection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: request2,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        privateEndpointConnectionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$4
};
const deleteOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        privateEndpointConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const listOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/privateEndpointConnections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnectionList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const listNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnectionList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$4
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PrivateLinkResources operations. */
class PrivateLinkResourcesImpl {
    /**
     * Initialize a new instance of the class PrivateLinkResources class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get all private link resources for a workspaces
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param options The options parameters.
     */
    list(resourceGroupName, workspaceName, options) {
        const iter = this.listPagingAll(resourceGroupName, workspaceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, workspaceName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, workspaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, workspaceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, workspaceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, workspaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, workspaceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get all private link resources for a workspaces
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param options The options parameters.
     */
    _list(resourceGroupName, workspaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, options }, listOperationSpec$3);
    }
    /**
     * Get private link resource in workspace
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param privateLinkResourceName The name of the private link resource
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, privateLinkResourceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, privateLinkResourceName, options }, getOperationSpec$4);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, workspaceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, nextLink, options }, listNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$5 = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/privateLinkResources",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateLinkResourceListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const getOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/privateLinkResources/{privateLinkResourceName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateLinkResource
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        privateLinkResourceName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const listNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateLinkResourceListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$5
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PrivateLinkHubPrivateLinkResources operations. */
class PrivateLinkHubPrivateLinkResourcesImpl {
    /**
     * Initialize a new instance of the class PrivateLinkHubPrivateLinkResources class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get all private link resources for a private link hub
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateLinkHubName The name of the private link hub
     * @param options The options parameters.
     */
    list(resourceGroupName, privateLinkHubName, options) {
        const iter = this.listPagingAll(resourceGroupName, privateLinkHubName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, privateLinkHubName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, privateLinkHubName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, privateLinkHubName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, privateLinkHubName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, privateLinkHubName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, privateLinkHubName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get all private link resources for a private link hub
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateLinkHubName The name of the private link hub
     * @param options The options parameters.
     */
    _list(resourceGroupName, privateLinkHubName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateLinkHubName, options }, listOperationSpec$4);
    }
    /**
     * Get private link resource in private link hub
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateLinkHubName The name of the private link hub
     * @param privateLinkResourceName The name of the private link resource
     * @param options The options parameters.
     */
    get(resourceGroupName, privateLinkHubName, privateLinkResourceName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            privateLinkHubName,
            privateLinkResourceName,
            options
        }, getOperationSpec$5);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateLinkHubName The name of the private link hub
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, privateLinkHubName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateLinkHubName, nextLink, options }, listNextOperationSpec$3);
    }
}
// Operation Specifications
const serializer$6 = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/privateLinkHubs/{privateLinkHubName}/privateLinkResources",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateLinkResourceListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateLinkHubName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const getOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/privateLinkHubs/{privateLinkHubName}/privateLinkResources/{privateLinkResourceName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateLinkResource
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateLinkResourceName,
        privateLinkHubName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const listNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateLinkResourceListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        privateLinkHubName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PrivateLinkHubs operations. */
class PrivateLinkHubsImpl {
    /**
     * Initialize a new instance of the class PrivateLinkHubs class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Returns a list of privateLinkHubs in a resource group
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupPagingPage(resourceGroupName, options);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Returns a list of privateLinkHubs in a subscription
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Returns a list of privateLinkHubs in a resource group
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec);
    }
    /**
     * Gets a privateLinkHub
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateLinkHubName Name of the privateLinkHub
     * @param options The options parameters.
     */
    get(resourceGroupName, privateLinkHubName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateLinkHubName, options }, getOperationSpec$6);
    }
    /**
     * Updates a privateLinkHub
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateLinkHubName Name of the privateLinkHub
     * @param privateLinkHubPatchInfo PrivateLinkHub patch request properties
     * @param options The options parameters.
     */
    update(resourceGroupName, privateLinkHubName, privateLinkHubPatchInfo, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            privateLinkHubName,
            privateLinkHubPatchInfo,
            options
        }, updateOperationSpec);
    }
    /**
     * Creates or updates a privateLinkHub
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateLinkHubName Name of the privateLinkHub
     * @param privateLinkHubInfo PrivateLinkHub create or update request properties
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, privateLinkHubName, privateLinkHubInfo, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateLinkHubName, privateLinkHubInfo, options }, createOrUpdateOperationSpec$2);
    }
    /**
     * Deletes a privateLinkHub
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateLinkHubName Name of the privateLinkHub
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, privateLinkHubName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, privateLinkHubName, options }, deleteOperationSpec$3);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Deletes a privateLinkHub
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateLinkHubName Name of the privateLinkHub
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, privateLinkHubName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, privateLinkHubName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Returns a list of privateLinkHubs in a subscription
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$5);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$4);
    }
}
// Operation Specifications
const serializer$7 = coreClient.createSerializer(Mappers, /* isXml */ false);
const listByResourceGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/privateLinkHubs",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateLinkHubInfoListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const getOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/privateLinkHubs/{privateLinkHubName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateLinkHub
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateLinkHubName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const updateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/privateLinkHubs/{privateLinkHubName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: PrivateLinkHub
        },
        201: {
            bodyMapper: PrivateLinkHub
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: privateLinkHubPatchInfo,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateLinkHubName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$7
};
const createOrUpdateOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/privateLinkHubs/{privateLinkHubName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PrivateLinkHub
        },
        201: {
            bodyMapper: PrivateLinkHub
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: privateLinkHubInfo,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateLinkHubName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$7
};
const deleteOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/privateLinkHubs/{privateLinkHubName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateLinkHubName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const listOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Synapse/privateLinkHubs",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateLinkHubInfoListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$7
};
const listByResourceGroupNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateLinkHubInfoListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const listNextOperationSpec$4 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateLinkHubInfoListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$7
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PrivateEndpointConnectionsPrivateLinkHub operations. */
class PrivateEndpointConnectionsPrivateLinkHubImpl {
    /**
     * Initialize a new instance of the class PrivateEndpointConnectionsPrivateLinkHub class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get all PrivateEndpointConnections in the PrivateLinkHub
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateLinkHubName Name of the privateLinkHub
     * @param options The options parameters.
     */
    list(resourceGroupName, privateLinkHubName, options) {
        const iter = this.listPagingAll(resourceGroupName, privateLinkHubName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, privateLinkHubName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, privateLinkHubName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, privateLinkHubName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, privateLinkHubName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, privateLinkHubName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, privateLinkHubName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get all PrivateEndpointConnections in the PrivateLinkHub
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateLinkHubName Name of the privateLinkHub
     * @param options The options parameters.
     */
    _list(resourceGroupName, privateLinkHubName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateLinkHubName, options }, listOperationSpec$6);
    }
    /**
     * Get all PrivateEndpointConnection in the PrivateLinkHub by name
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateLinkHubName Name of the privateLinkHub
     * @param privateEndpointConnectionName Name of the privateEndpointConnection
     * @param options The options parameters.
     */
    get(resourceGroupName, privateLinkHubName, privateEndpointConnectionName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            privateLinkHubName,
            privateEndpointConnectionName,
            options
        }, getOperationSpec$7);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateLinkHubName Name of the privateLinkHub
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, privateLinkHubName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateLinkHubName, nextLink, options }, listNextOperationSpec$5);
    }
}
// Operation Specifications
const serializer$8 = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/privateLinkHubs/{privateLinkHubName}/privateEndpointConnections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnectionForPrivateLinkHubResourceCollectionResponse
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateLinkHubName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const getOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/privateLinkHubs/{privateLinkHubName}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnectionForPrivateLinkHub
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateEndpointConnectionName,
        privateLinkHubName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const listNextOperationSpec$5 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnectionForPrivateLinkHubResourceCollectionResponse
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        privateLinkHubName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing SqlPools operations. */
class SqlPoolsImpl {
    /**
     * Initialize a new instance of the class SqlPools class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List all SQL pools
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param options The options parameters.
     */
    listByWorkspace(resourceGroupName, workspaceName, options) {
        const iter = this.listByWorkspacePagingAll(resourceGroupName, workspaceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByWorkspacePagingPage(resourceGroupName, workspaceName, options);
            }
        };
    }
    listByWorkspacePagingPage(resourceGroupName, workspaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByWorkspacePagingPage_1() {
            let result = yield tslib.__await(this._listByWorkspace(resourceGroupName, workspaceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByWorkspaceNext(resourceGroupName, workspaceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByWorkspacePagingAll(resourceGroupName, workspaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByWorkspacePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByWorkspacePagingPage(resourceGroupName, workspaceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get SQL pool properties
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, sqlPoolName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, sqlPoolName, options }, getOperationSpec$8);
    }
    /**
     * Apply a partial update to a SQL pool
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param sqlPoolInfo The updated SQL pool properties
     * @param options The options parameters.
     */
    update(resourceGroupName, workspaceName, sqlPoolName, sqlPoolInfo, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, sqlPoolName, sqlPoolInfo, options }, updateOperationSpec$1);
    }
    /**
     * Create a SQL pool
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param sqlPoolInfo The SQL pool to create
     * @param options The options parameters.
     */
    beginCreate(resourceGroupName, workspaceName, sqlPoolName, sqlPoolInfo, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, workspaceName, sqlPoolName, sqlPoolInfo, options }, createOperationSpec$2);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Create a SQL pool
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param sqlPoolInfo The SQL pool to create
     * @param options The options parameters.
     */
    beginCreateAndWait(resourceGroupName, workspaceName, sqlPoolName, sqlPoolInfo, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreate(resourceGroupName, workspaceName, sqlPoolName, sqlPoolInfo, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete a SQL pool
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, workspaceName, sqlPoolName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, workspaceName, sqlPoolName, options }, deleteOperationSpec$4);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Delete a SQL pool
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, workspaceName, sqlPoolName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, workspaceName, sqlPoolName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * List all SQL pools
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param options The options parameters.
     */
    _listByWorkspace(resourceGroupName, workspaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, options }, listByWorkspaceOperationSpec$2);
    }
    /**
     * Pause a SQL pool
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param options The options parameters.
     */
    beginPause(resourceGroupName, workspaceName, sqlPoolName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, workspaceName, sqlPoolName, options }, pauseOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Pause a SQL pool
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param options The options parameters.
     */
    beginPauseAndWait(resourceGroupName, workspaceName, sqlPoolName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginPause(resourceGroupName, workspaceName, sqlPoolName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Resume a SQL pool
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param options The options parameters.
     */
    beginResume(resourceGroupName, workspaceName, sqlPoolName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, workspaceName, sqlPoolName, options }, resumeOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Resume a SQL pool
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param options The options parameters.
     */
    beginResumeAndWait(resourceGroupName, workspaceName, sqlPoolName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginResume(resourceGroupName, workspaceName, sqlPoolName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Rename a SQL pool.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param parameters The resource move definition for renaming this Sql pool.
     * @param options The options parameters.
     */
    rename(resourceGroupName, workspaceName, sqlPoolName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, sqlPoolName, parameters, options }, renameOperationSpec);
    }
    /**
     * ListByWorkspaceNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param nextLink The nextLink from the previous successful call to the ListByWorkspace method.
     * @param options The options parameters.
     */
    _listByWorkspaceNext(resourceGroupName, workspaceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, nextLink, options }, listByWorkspaceNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$9 = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SqlPool
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const updateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: SqlPool
        },
        202: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: sqlPoolInfo,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$9
};
const createOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SqlPool
        },
        201: {
            bodyMapper: SqlPool
        },
        202: {
            bodyMapper: SqlPool
        },
        204: {
            bodyMapper: SqlPool
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: sqlPoolInfo1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$9
};
const deleteOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}",
    httpMethod: "DELETE",
    responses: {
        200: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } }
            }
        },
        201: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } }
            }
        },
        202: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } }
            }
        },
        204: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } }
            }
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const listByWorkspaceOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SqlPoolInfoListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const pauseOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/pause",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } }
            }
        },
        201: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } }
            }
        },
        202: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } }
            }
        },
        204: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } }
            }
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const resumeOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/resume",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } }
            }
        },
        201: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } }
            }
        },
        202: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } }
            }
        },
        204: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } }
            }
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const renameOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/move",
    httpMethod: "POST",
    responses: { 200: {}, default: {} },
    requestBody: parameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName
    ],
    headerParameters: [contentType],
    mediaType: "json",
    serializer: serializer$9
};
const listByWorkspaceNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SqlPoolInfoListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$9
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing SqlPoolMetadataSyncConfigs operations. */
class SqlPoolMetadataSyncConfigsImpl {
    /**
     * Initialize a new instance of the class SqlPoolMetadataSyncConfigs class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get the metadata sync configuration for a SQL pool
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, sqlPoolName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, sqlPoolName, options }, getOperationSpec$9);
    }
    /**
     * Set the metadata sync configuration for a SQL pool
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param metadataSyncConfiguration Metadata sync configuration
     * @param options The options parameters.
     */
    create(resourceGroupName, workspaceName, sqlPoolName, metadataSyncConfiguration, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workspaceName,
            sqlPoolName,
            metadataSyncConfiguration,
            options
        }, createOperationSpec$3);
    }
}
// Operation Specifications
const serializer$a = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/metadataSync/config",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MetadataSyncConfig
        },
        404: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const createOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/metadataSync/config",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: MetadataSyncConfig
        },
        404: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: metadataSyncConfiguration,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing SqlPoolOperationResults operations. */
class SqlPoolOperationResultsImpl {
    /**
     * Initialize a new instance of the class SqlPoolOperationResults class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get the status of a SQL pool operation
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param operationId Operation ID
     * @param options The options parameters.
     */
    getLocationHeaderResult(resourceGroupName, workspaceName, sqlPoolName, operationId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, sqlPoolName, operationId, options }, getLocationHeaderResultOperationSpec$1);
    }
}
// Operation Specifications
const serializer$b = coreClient.createSerializer(Mappers, /* isXml */ false);
const getLocationHeaderResultOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/operationResults/{operationId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } }
            }
        },
        202: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } }
            }
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        operationId,
        sqlPoolName
    ],
    headerParameters: [accept],
    serializer: serializer$b
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing SqlPoolGeoBackupPolicies operations. */
class SqlPoolGeoBackupPoliciesImpl {
    /**
     * Initialize a new instance of the class SqlPoolGeoBackupPolicies class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get list of SQL pool geo backup policies
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param options The options parameters.
     */
    list(resourceGroupName, workspaceName, sqlPoolName, options) {
        const iter = this.listPagingAll(resourceGroupName, workspaceName, sqlPoolName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, workspaceName, sqlPoolName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, workspaceName, sqlPoolName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, workspaceName, sqlPoolName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listPagingAll(resourceGroupName, workspaceName, sqlPoolName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, workspaceName, sqlPoolName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get list of SQL pool geo backup policies
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param options The options parameters.
     */
    _list(resourceGroupName, workspaceName, sqlPoolName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, sqlPoolName, options }, listOperationSpec$7);
    }
    /**
     * Updates a SQL Pool geo backup policy.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param geoBackupPolicyName The name of the geo backup policy.
     * @param parameters The required parameters for creating or updating the geo backup policy.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, workspaceName, sqlPoolName, geoBackupPolicyName, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workspaceName,
            sqlPoolName,
            geoBackupPolicyName,
            parameters,
            options
        }, createOrUpdateOperationSpec$3);
    }
    /**
     * Get the specified SQL pool geo backup policy
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param geoBackupPolicyName The name of the geo backup policy.
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, sqlPoolName, geoBackupPolicyName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workspaceName,
            sqlPoolName,
            geoBackupPolicyName,
            options
        }, getOperationSpec$a);
    }
}
// Operation Specifications
const serializer$c = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/geoBackupPolicies",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: GeoBackupPolicyListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName
    ],
    headerParameters: [accept],
    serializer: serializer$c
};
const createOrUpdateOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/geoBackupPolicies/{geoBackupPolicyName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: GeoBackupPolicy
        },
        201: {
            bodyMapper: GeoBackupPolicy
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName,
        geoBackupPolicyName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$c
};
const getOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/geoBackupPolicies/{geoBackupPolicyName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: GeoBackupPolicy
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName,
        geoBackupPolicyName
    ],
    headerParameters: [accept],
    serializer: serializer$c
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing SqlPoolDataWarehouseUserActivities operations. */
class SqlPoolDataWarehouseUserActivitiesImpl {
    /**
     * Initialize a new instance of the class SqlPoolDataWarehouseUserActivities class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets the user activities of a SQL pool which includes running and suspended queries
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param dataWarehouseUserActivityName The activity name of the Sql pool.
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, sqlPoolName, dataWarehouseUserActivityName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workspaceName,
            sqlPoolName,
            dataWarehouseUserActivityName,
            options
        }, getOperationSpec$b);
    }
}
// Operation Specifications
const serializer$d = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/dataWarehouseUserActivities/{dataWarehouseUserActivityName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DataWarehouseUserActivities
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName,
        dataWarehouseUserActivityName
    ],
    headerParameters: [accept],
    serializer: serializer$d
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing SqlPoolRestorePoints operations. */
class SqlPoolRestorePointsImpl {
    /**
     * Initialize a new instance of the class SqlPoolRestorePoints class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get SQL pool backup information
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param options The options parameters.
     */
    list(resourceGroupName, workspaceName, sqlPoolName, options) {
        const iter = this.listPagingAll(resourceGroupName, workspaceName, sqlPoolName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, workspaceName, sqlPoolName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, workspaceName, sqlPoolName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, workspaceName, sqlPoolName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, workspaceName, sqlPoolName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, workspaceName, sqlPoolName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, workspaceName, sqlPoolName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get SQL pool backup information
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param options The options parameters.
     */
    _list(resourceGroupName, workspaceName, sqlPoolName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, sqlPoolName, options }, listOperationSpec$8);
    }
    /**
     * Creates a restore point for a data warehouse.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param parameters The definition for creating the restore point of this Sql pool.
     * @param options The options parameters.
     */
    beginCreate(resourceGroupName, workspaceName, sqlPoolName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, workspaceName, sqlPoolName, parameters, options }, createOperationSpec$4);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Creates a restore point for a data warehouse.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param parameters The definition for creating the restore point of this Sql pool.
     * @param options The options parameters.
     */
    beginCreateAndWait(resourceGroupName, workspaceName, sqlPoolName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreate(resourceGroupName, workspaceName, sqlPoolName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets a restore point.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param restorePointName The name of the restore point.
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, sqlPoolName, restorePointName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workspaceName,
            sqlPoolName,
            restorePointName,
            options
        }, getOperationSpec$c);
    }
    /**
     * Deletes a restore point.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param restorePointName The name of the restore point.
     * @param options The options parameters.
     */
    delete(resourceGroupName, workspaceName, sqlPoolName, restorePointName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workspaceName,
            sqlPoolName,
            restorePointName,
            options
        }, deleteOperationSpec$5);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, workspaceName, sqlPoolName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, sqlPoolName, nextLink, options }, listNextOperationSpec$6);
    }
}
// Operation Specifications
const serializer$e = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/restorePoints",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RestorePointListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName
    ],
    headerParameters: [accept],
    serializer: serializer$e
};
const createOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/restorePoints",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: RestorePoint
        },
        201: {
            bodyMapper: RestorePoint
        },
        202: {
            bodyMapper: RestorePoint
        },
        204: {
            bodyMapper: RestorePoint
        },
        default: {}
    },
    requestBody: parameters2,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$e
};
const getOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/restorePoints/{restorePointName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RestorePoint
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName,
        restorePointName
    ],
    headerParameters: [accept],
    serializer: serializer$e
};
const deleteOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/restorePoints/{restorePointName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 204: {}, default: {} },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName,
        restorePointName
    ],
    serializer: serializer$e
};
const listNextOperationSpec$6 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RestorePointListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        nextLink,
        sqlPoolName
    ],
    headerParameters: [accept],
    serializer: serializer$e
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing SqlPoolReplicationLinks operations. */
class SqlPoolReplicationLinksImpl {
    /**
     * Initialize a new instance of the class SqlPoolReplicationLinks class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists a Sql pool's replication links.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param options The options parameters.
     */
    list(resourceGroupName, workspaceName, sqlPoolName, options) {
        const iter = this.listPagingAll(resourceGroupName, workspaceName, sqlPoolName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, workspaceName, sqlPoolName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, workspaceName, sqlPoolName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, workspaceName, sqlPoolName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, workspaceName, sqlPoolName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, workspaceName, sqlPoolName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, workspaceName, sqlPoolName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists a Sql pool's replication links.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param options The options parameters.
     */
    _list(resourceGroupName, workspaceName, sqlPoolName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, sqlPoolName, options }, listOperationSpec$9);
    }
    /**
     * Get SQL pool replication link by name.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param linkId The ID of the replication link.
     * @param options The options parameters.
     */
    getByName(resourceGroupName, workspaceName, sqlPoolName, linkId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, sqlPoolName, linkId, options }, getByNameOperationSpec);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, workspaceName, sqlPoolName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, sqlPoolName, nextLink, options }, listNextOperationSpec$7);
    }
}
// Operation Specifications
const serializer$f = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/replicationLinks",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ReplicationLinkListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const getByNameOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/replicationLinks/{linkId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ReplicationLink
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName,
        linkId
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const listNextOperationSpec$7 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ReplicationLinkListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        nextLink,
        sqlPoolName
    ],
    headerParameters: [accept],
    serializer: serializer$f
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing SqlPoolMaintenanceWindows operations. */
class SqlPoolMaintenanceWindowsImpl {
    /**
     * Initialize a new instance of the class SqlPoolMaintenanceWindows class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get a SQL pool's Maintenance Windows.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param maintenanceWindowName Maintenance window name.
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, sqlPoolName, maintenanceWindowName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workspaceName,
            sqlPoolName,
            maintenanceWindowName,
            options
        }, getOperationSpec$d);
    }
    /**
     * Creates or updates a Sql pool's maintenance windows settings.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param maintenanceWindowName Maintenance window name.
     * @param parameters The required parameters for creating or updating Maintenance Windows settings
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, workspaceName, sqlPoolName, maintenanceWindowName, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workspaceName,
            sqlPoolName,
            maintenanceWindowName,
            parameters,
            options
        }, createOrUpdateOperationSpec$4);
    }
}
// Operation Specifications
const serializer$g = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$d = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/maintenancewindows/current",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MaintenanceWindows
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, maintenanceWindowName],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName
    ],
    headerParameters: [accept],
    serializer: serializer$g
};
const createOrUpdateOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/maintenancewindows/current",
    httpMethod: "PUT",
    responses: { 200: {}, default: {} },
    requestBody: parameters3,
    queryParameters: [apiVersion, maintenanceWindowName],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName
    ],
    headerParameters: [contentType],
    mediaType: "json",
    serializer: serializer$g
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing SqlPoolMaintenanceWindowOptions operations. */
class SqlPoolMaintenanceWindowOptionsImpl {
    /**
     * Initialize a new instance of the class SqlPoolMaintenanceWindowOptions class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get list of SQL pool's available maintenance windows.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param maintenanceWindowOptionsName Maintenance window options name.
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, sqlPoolName, maintenanceWindowOptionsName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workspaceName,
            sqlPoolName,
            maintenanceWindowOptionsName,
            options
        }, getOperationSpec$e);
    }
}
// Operation Specifications
const serializer$h = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$e = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/maintenanceWindowOptions/current",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MaintenanceWindowOptions
        },
        default: {}
    },
    queryParameters: [
        apiVersion,
        maintenanceWindowOptionsName
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName
    ],
    headerParameters: [accept],
    serializer: serializer$h
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing SqlPoolTransparentDataEncryptions operations. */
class SqlPoolTransparentDataEncryptionsImpl {
    /**
     * Initialize a new instance of the class SqlPoolTransparentDataEncryptions class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get list of SQL pool's transparent data encryption configurations.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param options The options parameters.
     */
    list(resourceGroupName, workspaceName, sqlPoolName, options) {
        const iter = this.listPagingAll(resourceGroupName, workspaceName, sqlPoolName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, workspaceName, sqlPoolName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, workspaceName, sqlPoolName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, workspaceName, sqlPoolName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, workspaceName, sqlPoolName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, workspaceName, sqlPoolName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, workspaceName, sqlPoolName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get a SQL pool's transparent data encryption configuration.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param transparentDataEncryptionName The name of the transparent data encryption configuration.
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, sqlPoolName, transparentDataEncryptionName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workspaceName,
            sqlPoolName,
            transparentDataEncryptionName,
            options
        }, getOperationSpec$f);
    }
    /**
     * Creates or updates a Sql pool's transparent data encryption configuration.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param transparentDataEncryptionName The name of the transparent data encryption configuration.
     * @param parameters The required parameters for creating or updating transparent data encryption.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, workspaceName, sqlPoolName, transparentDataEncryptionName, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workspaceName,
            sqlPoolName,
            transparentDataEncryptionName,
            parameters,
            options
        }, createOrUpdateOperationSpec$5);
    }
    /**
     * Get list of SQL pool's transparent data encryption configurations.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param options The options parameters.
     */
    _list(resourceGroupName, workspaceName, sqlPoolName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, sqlPoolName, options }, listOperationSpec$a);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, workspaceName, sqlPoolName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, sqlPoolName, nextLink, options }, listNextOperationSpec$8);
    }
}
// Operation Specifications
const serializer$i = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$f = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/transparentDataEncryption/{transparentDataEncryptionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TransparentDataEncryption
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName,
        transparentDataEncryptionName
    ],
    headerParameters: [accept],
    serializer: serializer$i
};
const createOrUpdateOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/transparentDataEncryption/{transparentDataEncryptionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: TransparentDataEncryption
        },
        201: {
            bodyMapper: TransparentDataEncryption
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters4,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName,
        transparentDataEncryptionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$i
};
const listOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/transparentDataEncryption",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TransparentDataEncryptionListResult
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName
    ],
    headerParameters: [accept],
    serializer: serializer$i
};
const listNextOperationSpec$8 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TransparentDataEncryptionListResult
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        nextLink,
        sqlPoolName
    ],
    headerParameters: [accept],
    serializer: serializer$i
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing SqlPoolBlobAuditingPolicies operations. */
class SqlPoolBlobAuditingPoliciesImpl {
    /**
     * Initialize a new instance of the class SqlPoolBlobAuditingPolicies class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists auditing settings of a Sql pool.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param options The options parameters.
     */
    listBySqlPool(resourceGroupName, workspaceName, sqlPoolName, options) {
        const iter = this.listBySqlPoolPagingAll(resourceGroupName, workspaceName, sqlPoolName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listBySqlPoolPagingPage(resourceGroupName, workspaceName, sqlPoolName, options);
            }
        };
    }
    listBySqlPoolPagingPage(resourceGroupName, workspaceName, sqlPoolName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySqlPoolPagingPage_1() {
            let result = yield tslib.__await(this._listBySqlPool(resourceGroupName, workspaceName, sqlPoolName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listBySqlPoolNext(resourceGroupName, workspaceName, sqlPoolName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listBySqlPoolPagingAll(resourceGroupName, workspaceName, sqlPoolName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySqlPoolPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBySqlPoolPagingPage(resourceGroupName, workspaceName, sqlPoolName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get a SQL pool's blob auditing policy.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, sqlPoolName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, sqlPoolName, options }, getOperationSpec$g);
    }
    /**
     * Creates or updates a SQL pool's blob auditing policy.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param parameters The database blob auditing policy.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, workspaceName, sqlPoolName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, sqlPoolName, parameters, options }, createOrUpdateOperationSpec$6);
    }
    /**
     * Lists auditing settings of a Sql pool.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param options The options parameters.
     */
    _listBySqlPool(resourceGroupName, workspaceName, sqlPoolName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, sqlPoolName, options }, listBySqlPoolOperationSpec);
    }
    /**
     * ListBySqlPoolNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param nextLink The nextLink from the previous successful call to the ListBySqlPool method.
     * @param options The options parameters.
     */
    _listBySqlPoolNext(resourceGroupName, workspaceName, sqlPoolName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, sqlPoolName, nextLink, options }, listBySqlPoolNextOperationSpec);
    }
}
// Operation Specifications
const serializer$j = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$g = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/auditingSettings/{blobAuditingPolicyName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SqlPoolBlobAuditingPolicy
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName,
        blobAuditingPolicyName
    ],
    headerParameters: [accept],
    serializer: serializer$j
};
const createOrUpdateOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/auditingSettings/{blobAuditingPolicyName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SqlPoolBlobAuditingPolicy
        },
        201: {
            bodyMapper: SqlPoolBlobAuditingPolicy
        },
        default: {}
    },
    requestBody: parameters5,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName,
        blobAuditingPolicyName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$j
};
const listBySqlPoolOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/auditingSettings",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SqlPoolBlobAuditingPolicyListResult
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName
    ],
    headerParameters: [accept],
    serializer: serializer$j
};
const listBySqlPoolNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SqlPoolBlobAuditingPolicyListResult
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        nextLink,
        sqlPoolName
    ],
    headerParameters: [accept],
    serializer: serializer$j
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing SqlPoolOperations operations. */
class SqlPoolOperationsImpl {
    /**
     * Initialize a new instance of the class SqlPoolOperations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of operations performed on the SQL pool.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param options The options parameters.
     */
    list(resourceGroupName, workspaceName, sqlPoolName, options) {
        const iter = this.listPagingAll(resourceGroupName, workspaceName, sqlPoolName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, workspaceName, sqlPoolName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, workspaceName, sqlPoolName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, workspaceName, sqlPoolName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, workspaceName, sqlPoolName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, workspaceName, sqlPoolName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, workspaceName, sqlPoolName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a list of operations performed on the SQL pool.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param options The options parameters.
     */
    _list(resourceGroupName, workspaceName, sqlPoolName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, sqlPoolName, options }, listOperationSpec$b);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, workspaceName, sqlPoolName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, sqlPoolName, nextLink, options }, listNextOperationSpec$9);
    }
}
// Operation Specifications
const serializer$k = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/operations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SqlPoolBlobAuditingPolicySqlPoolOperationListResult
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName
    ],
    headerParameters: [accept],
    serializer: serializer$k
};
const listNextOperationSpec$9 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SqlPoolBlobAuditingPolicySqlPoolOperationListResult
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        nextLink,
        sqlPoolName
    ],
    headerParameters: [accept],
    serializer: serializer$k
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing SqlPoolUsages operations. */
class SqlPoolUsagesImpl {
    /**
     * Initialize a new instance of the class SqlPoolUsages class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets SQL pool usages.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param options The options parameters.
     */
    list(resourceGroupName, workspaceName, sqlPoolName, options) {
        const iter = this.listPagingAll(resourceGroupName, workspaceName, sqlPoolName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, workspaceName, sqlPoolName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, workspaceName, sqlPoolName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, workspaceName, sqlPoolName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, workspaceName, sqlPoolName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, workspaceName, sqlPoolName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, workspaceName, sqlPoolName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets SQL pool usages.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param options The options parameters.
     */
    _list(resourceGroupName, workspaceName, sqlPoolName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, sqlPoolName, options }, listOperationSpec$c);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, workspaceName, sqlPoolName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, sqlPoolName, nextLink, options }, listNextOperationSpec$a);
    }
}
// Operation Specifications
const serializer$l = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/usages",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SqlPoolUsageListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName
    ],
    headerParameters: [accept],
    serializer: serializer$l
};
const listNextOperationSpec$a = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SqlPoolUsageListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        nextLink,
        sqlPoolName
    ],
    headerParameters: [accept],
    serializer: serializer$l
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing SqlPoolSensitivityLabels operations. */
class SqlPoolSensitivityLabelsImpl {
    /**
     * Initialize a new instance of the class SqlPoolSensitivityLabels class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets SQL pool sensitivity labels.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param options The options parameters.
     */
    listCurrent(resourceGroupName, workspaceName, sqlPoolName, options) {
        const iter = this.listCurrentPagingAll(resourceGroupName, workspaceName, sqlPoolName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listCurrentPagingPage(resourceGroupName, workspaceName, sqlPoolName, options);
            }
        };
    }
    listCurrentPagingPage(resourceGroupName, workspaceName, sqlPoolName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listCurrentPagingPage_1() {
            let result = yield tslib.__await(this._listCurrent(resourceGroupName, workspaceName, sqlPoolName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listCurrentNext(resourceGroupName, workspaceName, sqlPoolName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listCurrentPagingAll(resourceGroupName, workspaceName, sqlPoolName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listCurrentPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listCurrentPagingPage(resourceGroupName, workspaceName, sqlPoolName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets sensitivity labels of a given SQL pool.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param options The options parameters.
     */
    listRecommended(resourceGroupName, workspaceName, sqlPoolName, options) {
        const iter = this.listRecommendedPagingAll(resourceGroupName, workspaceName, sqlPoolName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listRecommendedPagingPage(resourceGroupName, workspaceName, sqlPoolName, options);
            }
        };
    }
    listRecommendedPagingPage(resourceGroupName, workspaceName, sqlPoolName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listRecommendedPagingPage_1() {
            let result = yield tslib.__await(this._listRecommended(resourceGroupName, workspaceName, sqlPoolName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listRecommendedNext(resourceGroupName, workspaceName, sqlPoolName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listRecommendedPagingAll(resourceGroupName, workspaceName, sqlPoolName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listRecommendedPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listRecommendedPagingPage(resourceGroupName, workspaceName, sqlPoolName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Gets SQL pool sensitivity labels.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param options The options parameters.
     */
    _listCurrent(resourceGroupName, workspaceName, sqlPoolName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, sqlPoolName, options }, listCurrentOperationSpec);
    }
    /**
     * Update sensitivity labels of a given SQL Pool using an operations batch.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param parameters A list of sensitivity label update operations.
     * @param options The options parameters.
     */
    update(resourceGroupName, workspaceName, sqlPoolName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, sqlPoolName, parameters, options }, updateOperationSpec$2);
    }
    /**
     * Gets sensitivity labels of a given SQL pool.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param options The options parameters.
     */
    _listRecommended(resourceGroupName, workspaceName, sqlPoolName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, sqlPoolName, options }, listRecommendedOperationSpec);
    }
    /**
     * Creates or updates the sensitivity label of a given column in a Sql pool
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param schemaName The name of the schema.
     * @param tableName The name of the table.
     * @param columnName The name of the column.
     * @param parameters The column sensitivity label resource.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, workspaceName, sqlPoolName, schemaName, tableName, columnName, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workspaceName,
            sqlPoolName,
            schemaName,
            tableName,
            columnName,
            parameters,
            options
        }, createOrUpdateOperationSpec$7);
    }
    /**
     * Deletes the sensitivity label of a given column in a Sql pool
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param schemaName The name of the schema.
     * @param tableName The name of the table.
     * @param columnName The name of the column.
     * @param options The options parameters.
     */
    delete(resourceGroupName, workspaceName, sqlPoolName, schemaName, tableName, columnName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workspaceName,
            sqlPoolName,
            schemaName,
            tableName,
            columnName,
            options
        }, deleteOperationSpec$6);
    }
    /**
     * Gets the sensitivity label of a given column
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param schemaName The name of the schema.
     * @param tableName The name of the table.
     * @param columnName The name of the column.
     * @param sensitivityLabelSource The source of the sensitivity label.
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, sqlPoolName, schemaName, tableName, columnName, sensitivityLabelSource, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workspaceName,
            sqlPoolName,
            schemaName,
            tableName,
            columnName,
            sensitivityLabelSource,
            options
        }, getOperationSpec$h);
    }
    /**
     * Enables sensitivity recommendations on a given column (recommendations are enabled by default on all
     * columns)
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param schemaName The name of the schema.
     * @param tableName The name of the table.
     * @param columnName The name of the column.
     * @param options The options parameters.
     */
    enableRecommendation(resourceGroupName, workspaceName, sqlPoolName, schemaName, tableName, columnName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workspaceName,
            sqlPoolName,
            schemaName,
            tableName,
            columnName,
            options
        }, enableRecommendationOperationSpec);
    }
    /**
     * Disables sensitivity recommendations on a given column
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param schemaName The name of the schema.
     * @param tableName The name of the table.
     * @param columnName The name of the column.
     * @param options The options parameters.
     */
    disableRecommendation(resourceGroupName, workspaceName, sqlPoolName, schemaName, tableName, columnName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workspaceName,
            sqlPoolName,
            schemaName,
            tableName,
            columnName,
            options
        }, disableRecommendationOperationSpec);
    }
    /**
     * ListCurrentNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param nextLink The nextLink from the previous successful call to the ListCurrent method.
     * @param options The options parameters.
     */
    _listCurrentNext(resourceGroupName, workspaceName, sqlPoolName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, sqlPoolName, nextLink, options }, listCurrentNextOperationSpec);
    }
    /**
     * ListRecommendedNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param nextLink The nextLink from the previous successful call to the ListRecommended method.
     * @param options The options parameters.
     */
    _listRecommendedNext(resourceGroupName, workspaceName, sqlPoolName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, sqlPoolName, nextLink, options }, listRecommendedNextOperationSpec);
    }
}
// Operation Specifications
const serializer$m = coreClient.createSerializer(Mappers, /* isXml */ false);
const listCurrentOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/currentSensitivityLabels",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SensitivityLabelListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, filter],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const updateOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/currentSensitivityLabels",
    httpMethod: "PATCH",
    responses: { 200: {}, default: {} },
    requestBody: parameters6,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName
    ],
    headerParameters: [contentType],
    mediaType: "json",
    serializer: serializer$m
};
const listRecommendedOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/recommendedSensitivityLabels",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SensitivityLabelListResult
        },
        default: {}
    },
    queryParameters: [
        apiVersion,
        filter,
        includeDisabledRecommendations,
        skipToken
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const createOrUpdateOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/schemas/{schemaName}/tables/{tableName}/columns/{columnName}/sensitivityLabels/{sensitivityLabelSource}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SensitivityLabel
        },
        201: {
            bodyMapper: SensitivityLabel
        },
        default: {}
    },
    requestBody: parameters7,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName,
        schemaName,
        tableName,
        columnName,
        sensitivityLabelSource
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$m
};
const deleteOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/schemas/{schemaName}/tables/{tableName}/columns/{columnName}/sensitivityLabels/{sensitivityLabelSource}",
    httpMethod: "DELETE",
    responses: { 200: {}, 204: {}, default: {} },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName,
        schemaName,
        tableName,
        columnName,
        sensitivityLabelSource
    ],
    serializer: serializer$m
};
const getOperationSpec$h = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/schemas/{schemaName}/tables/{tableName}/columns/{columnName}/sensitivityLabels/{sensitivityLabelSource}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SensitivityLabel
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName,
        schemaName,
        tableName,
        columnName,
        sensitivityLabelSource1
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const enableRecommendationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/schemas/{schemaName}/tables/{tableName}/columns/{columnName}/sensitivityLabels/{sensitivityLabelSource}/enable",
    httpMethod: "POST",
    responses: { 200: {}, default: {} },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName,
        schemaName,
        tableName,
        columnName,
        sensitivityLabelSource2
    ],
    serializer: serializer$m
};
const disableRecommendationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/schemas/{schemaName}/tables/{tableName}/columns/{columnName}/sensitivityLabels/{sensitivityLabelSource}/disable",
    httpMethod: "POST",
    responses: { 200: {}, default: {} },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName,
        schemaName,
        tableName,
        columnName,
        sensitivityLabelSource2
    ],
    serializer: serializer$m
};
const listCurrentNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SensitivityLabelListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, filter],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        nextLink,
        sqlPoolName
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const listRecommendedNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SensitivityLabelListResult
        },
        default: {}
    },
    queryParameters: [
        apiVersion,
        filter,
        includeDisabledRecommendations,
        skipToken
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        nextLink,
        sqlPoolName
    ],
    headerParameters: [accept],
    serializer: serializer$m
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing SqlPoolRecommendedSensitivityLabels operations. */
class SqlPoolRecommendedSensitivityLabelsImpl {
    /**
     * Initialize a new instance of the class SqlPoolRecommendedSensitivityLabels class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Update recommended sensitivity labels states of a given SQL Pool using an operations batch.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param parameters A list of recommended sensitivity label update operations.
     * @param options The options parameters.
     */
    update(resourceGroupName, workspaceName, sqlPoolName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, sqlPoolName, parameters, options }, updateOperationSpec$3);
    }
}
// Operation Specifications
const serializer$n = coreClient.createSerializer(Mappers, /* isXml */ false);
const updateOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/recommendedSensitivityLabels",
    httpMethod: "PATCH",
    responses: { 200: {}, default: {} },
    requestBody: parameters8,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName
    ],
    headerParameters: [contentType],
    mediaType: "json",
    serializer: serializer$n
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing SqlPoolSchemas operations. */
class SqlPoolSchemasImpl {
    /**
     * Initialize a new instance of the class SqlPoolSchemas class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets schemas of a given SQL pool.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param options The options parameters.
     */
    list(resourceGroupName, workspaceName, sqlPoolName, options) {
        const iter = this.listPagingAll(resourceGroupName, workspaceName, sqlPoolName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, workspaceName, sqlPoolName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, workspaceName, sqlPoolName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, workspaceName, sqlPoolName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, workspaceName, sqlPoolName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, workspaceName, sqlPoolName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, workspaceName, sqlPoolName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets schemas of a given SQL pool.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param options The options parameters.
     */
    _list(resourceGroupName, workspaceName, sqlPoolName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, sqlPoolName, options }, listOperationSpec$d);
    }
    /**
     * Get Sql Pool schema
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param schemaName The name of the schema.
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, sqlPoolName, schemaName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, sqlPoolName, schemaName, options }, getOperationSpec$i);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, workspaceName, sqlPoolName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, sqlPoolName, nextLink, options }, listNextOperationSpec$b);
    }
}
// Operation Specifications
const serializer$o = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$d = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/schemas",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SqlPoolSchemaListResult
        },
        default: {}
    },
    queryParameters: [apiVersion, filter],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName
    ],
    headerParameters: [accept],
    serializer: serializer$o
};
const getOperationSpec$i = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/schemas/{schemaName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SqlPoolSchema
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName,
        schemaName
    ],
    headerParameters: [accept],
    serializer: serializer$o
};
const listNextOperationSpec$b = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SqlPoolSchemaListResult
        },
        default: {}
    },
    queryParameters: [apiVersion, filter],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        nextLink,
        sqlPoolName
    ],
    headerParameters: [accept],
    serializer: serializer$o
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing SqlPoolTables operations. */
class SqlPoolTablesImpl {
    /**
     * Initialize a new instance of the class SqlPoolTables class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets tables of a given schema in a SQL pool.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param schemaName The name of the schema.
     * @param options The options parameters.
     */
    listBySchema(resourceGroupName, workspaceName, sqlPoolName, schemaName, options) {
        const iter = this.listBySchemaPagingAll(resourceGroupName, workspaceName, sqlPoolName, schemaName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listBySchemaPagingPage(resourceGroupName, workspaceName, sqlPoolName, schemaName, options);
            }
        };
    }
    listBySchemaPagingPage(resourceGroupName, workspaceName, sqlPoolName, schemaName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySchemaPagingPage_1() {
            let result = yield tslib.__await(this._listBySchema(resourceGroupName, workspaceName, sqlPoolName, schemaName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listBySchemaNext(resourceGroupName, workspaceName, sqlPoolName, schemaName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listBySchemaPagingAll(resourceGroupName, workspaceName, sqlPoolName, schemaName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySchemaPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBySchemaPagingPage(resourceGroupName, workspaceName, sqlPoolName, schemaName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets tables of a given schema in a SQL pool.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param schemaName The name of the schema.
     * @param options The options parameters.
     */
    _listBySchema(resourceGroupName, workspaceName, sqlPoolName, schemaName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, sqlPoolName, schemaName, options }, listBySchemaOperationSpec);
    }
    /**
     * Get Sql pool table
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param schemaName The name of the schema.
     * @param tableName The name of the table.
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, sqlPoolName, schemaName, tableName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workspaceName,
            sqlPoolName,
            schemaName,
            tableName,
            options
        }, getOperationSpec$j);
    }
    /**
     * ListBySchemaNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param schemaName The name of the schema.
     * @param nextLink The nextLink from the previous successful call to the ListBySchema method.
     * @param options The options parameters.
     */
    _listBySchemaNext(resourceGroupName, workspaceName, sqlPoolName, schemaName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workspaceName,
            sqlPoolName,
            schemaName,
            nextLink,
            options
        }, listBySchemaNextOperationSpec);
    }
}
// Operation Specifications
const serializer$p = coreClient.createSerializer(Mappers, /* isXml */ false);
const listBySchemaOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/schemas/{schemaName}/tables",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SqlPoolTableListResult
        },
        default: {}
    },
    queryParameters: [apiVersion, filter],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName,
        schemaName
    ],
    headerParameters: [accept],
    serializer: serializer$p
};
const getOperationSpec$j = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/schemas/{schemaName}/tables/{tableName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SqlPoolTable
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName,
        schemaName,
        tableName
    ],
    headerParameters: [accept],
    serializer: serializer$p
};
const listBySchemaNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SqlPoolTableListResult
        },
        default: {}
    },
    queryParameters: [apiVersion, filter],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        nextLink,
        sqlPoolName,
        schemaName
    ],
    headerParameters: [accept],
    serializer: serializer$p
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing SqlPoolTableColumns operations. */
class SqlPoolTableColumnsImpl {
    /**
     * Initialize a new instance of the class SqlPoolTableColumns class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets columns in a given table in a SQL pool.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param schemaName The name of the schema.
     * @param tableName The name of the table.
     * @param options The options parameters.
     */
    listByTableName(resourceGroupName, workspaceName, sqlPoolName, schemaName, tableName, options) {
        const iter = this.listByTableNamePagingAll(resourceGroupName, workspaceName, sqlPoolName, schemaName, tableName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByTableNamePagingPage(resourceGroupName, workspaceName, sqlPoolName, schemaName, tableName, options);
            }
        };
    }
    listByTableNamePagingPage(resourceGroupName, workspaceName, sqlPoolName, schemaName, tableName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByTableNamePagingPage_1() {
            let result = yield tslib.__await(this._listByTableName(resourceGroupName, workspaceName, sqlPoolName, schemaName, tableName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByTableNameNext(resourceGroupName, workspaceName, sqlPoolName, schemaName, tableName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByTableNamePagingAll(resourceGroupName, workspaceName, sqlPoolName, schemaName, tableName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByTableNamePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByTableNamePagingPage(resourceGroupName, workspaceName, sqlPoolName, schemaName, tableName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets columns in a given table in a SQL pool.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param schemaName The name of the schema.
     * @param tableName The name of the table.
     * @param options The options parameters.
     */
    _listByTableName(resourceGroupName, workspaceName, sqlPoolName, schemaName, tableName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workspaceName,
            sqlPoolName,
            schemaName,
            tableName,
            options
        }, listByTableNameOperationSpec);
    }
    /**
     * ListByTableNameNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param schemaName The name of the schema.
     * @param tableName The name of the table.
     * @param nextLink The nextLink from the previous successful call to the ListByTableName method.
     * @param options The options parameters.
     */
    _listByTableNameNext(resourceGroupName, workspaceName, sqlPoolName, schemaName, tableName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workspaceName,
            sqlPoolName,
            schemaName,
            tableName,
            nextLink,
            options
        }, listByTableNameNextOperationSpec);
    }
}
// Operation Specifications
const serializer$q = coreClient.createSerializer(Mappers, /* isXml */ false);
const listByTableNameOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/schemas/{schemaName}/tables/{tableName}/columns",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SqlPoolColumnListResult
        },
        default: {}
    },
    queryParameters: [apiVersion, filter],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName,
        schemaName,
        tableName
    ],
    headerParameters: [accept],
    serializer: serializer$q
};
const listByTableNameNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SqlPoolColumnListResult
        },
        default: {}
    },
    queryParameters: [apiVersion, filter],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        nextLink,
        sqlPoolName,
        schemaName,
        tableName
    ],
    headerParameters: [accept],
    serializer: serializer$q
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing SqlPoolConnectionPolicies operations. */
class SqlPoolConnectionPoliciesImpl {
    /**
     * Initialize a new instance of the class SqlPoolConnectionPolicies class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get a Sql pool's connection policy, which is used with table auditing.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param connectionPolicyName The name of the connection policy.
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, sqlPoolName, connectionPolicyName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workspaceName,
            sqlPoolName,
            connectionPolicyName,
            options
        }, getOperationSpec$k);
    }
}
// Operation Specifications
const serializer$r = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$k = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/connectionPolicies/{connectionPolicyName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SqlPoolConnectionPolicy
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName,
        connectionPolicyName
    ],
    headerParameters: [accept],
    serializer: serializer$r
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing SqlPoolVulnerabilityAssessments operations. */
class SqlPoolVulnerabilityAssessmentsImpl {
    /**
     * Initialize a new instance of the class SqlPoolVulnerabilityAssessments class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists the vulnerability assessment policies associated with a SQL pool.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param options The options parameters.
     */
    list(resourceGroupName, workspaceName, sqlPoolName, options) {
        const iter = this.listPagingAll(resourceGroupName, workspaceName, sqlPoolName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, workspaceName, sqlPoolName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, workspaceName, sqlPoolName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, workspaceName, sqlPoolName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, workspaceName, sqlPoolName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, workspaceName, sqlPoolName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, workspaceName, sqlPoolName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists the vulnerability assessment policies associated with a SQL pool.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param options The options parameters.
     */
    _list(resourceGroupName, workspaceName, sqlPoolName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, sqlPoolName, options }, listOperationSpec$e);
    }
    /**
     * Gets the Sql pool's vulnerability assessment.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param vulnerabilityAssessmentName The name of the vulnerability assessment.
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, sqlPoolName, vulnerabilityAssessmentName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workspaceName,
            sqlPoolName,
            vulnerabilityAssessmentName,
            options
        }, getOperationSpec$l);
    }
    /**
     * Creates or updates the Sql pool vulnerability assessment.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param vulnerabilityAssessmentName The name of the vulnerability assessment.
     * @param parameters The requested resource.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, workspaceName, sqlPoolName, vulnerabilityAssessmentName, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workspaceName,
            sqlPoolName,
            vulnerabilityAssessmentName,
            parameters,
            options
        }, createOrUpdateOperationSpec$8);
    }
    /**
     * Removes the database's vulnerability assessment.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param vulnerabilityAssessmentName The name of the vulnerability assessment.
     * @param options The options parameters.
     */
    delete(resourceGroupName, workspaceName, sqlPoolName, vulnerabilityAssessmentName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workspaceName,
            sqlPoolName,
            vulnerabilityAssessmentName,
            options
        }, deleteOperationSpec$7);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, workspaceName, sqlPoolName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, sqlPoolName, nextLink, options }, listNextOperationSpec$c);
    }
}
// Operation Specifications
const serializer$s = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$e = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/vulnerabilityAssessments",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SqlPoolVulnerabilityAssessmentListResult
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName
    ],
    headerParameters: [accept],
    serializer: serializer$s
};
const getOperationSpec$l = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/vulnerabilityAssessments/{vulnerabilityAssessmentName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SqlPoolVulnerabilityAssessment
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName,
        vulnerabilityAssessmentName
    ],
    headerParameters: [accept],
    serializer: serializer$s
};
const createOrUpdateOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/vulnerabilityAssessments/{vulnerabilityAssessmentName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SqlPoolVulnerabilityAssessment
        },
        201: {
            bodyMapper: SqlPoolVulnerabilityAssessment
        },
        default: {}
    },
    requestBody: parameters9,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName,
        vulnerabilityAssessmentName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$s
};
const deleteOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/vulnerabilityAssessments/{vulnerabilityAssessmentName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 204: {}, default: {} },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName,
        vulnerabilityAssessmentName
    ],
    serializer: serializer$s
};
const listNextOperationSpec$c = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SqlPoolVulnerabilityAssessmentListResult
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        nextLink,
        sqlPoolName
    ],
    headerParameters: [accept],
    serializer: serializer$s
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing SqlPoolVulnerabilityAssessmentScans operations. */
class SqlPoolVulnerabilityAssessmentScansImpl {
    /**
     * Initialize a new instance of the class SqlPoolVulnerabilityAssessmentScans class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists the vulnerability assessment scans of a SQL pool.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param vulnerabilityAssessmentName The name of the vulnerability assessment.
     * @param options The options parameters.
     */
    list(resourceGroupName, workspaceName, sqlPoolName, vulnerabilityAssessmentName, options) {
        const iter = this.listPagingAll(resourceGroupName, workspaceName, sqlPoolName, vulnerabilityAssessmentName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, workspaceName, sqlPoolName, vulnerabilityAssessmentName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, workspaceName, sqlPoolName, vulnerabilityAssessmentName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, workspaceName, sqlPoolName, vulnerabilityAssessmentName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, workspaceName, sqlPoolName, vulnerabilityAssessmentName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, workspaceName, sqlPoolName, vulnerabilityAssessmentName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, workspaceName, sqlPoolName, vulnerabilityAssessmentName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists the vulnerability assessment scans of a SQL pool.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param vulnerabilityAssessmentName The name of the vulnerability assessment.
     * @param options The options parameters.
     */
    _list(resourceGroupName, workspaceName, sqlPoolName, vulnerabilityAssessmentName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workspaceName,
            sqlPoolName,
            vulnerabilityAssessmentName,
            options
        }, listOperationSpec$f);
    }
    /**
     * Executes a Vulnerability Assessment database scan.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param vulnerabilityAssessmentName The name of the vulnerability assessment.
     * @param scanId The vulnerability assessment scan Id of the scan to retrieve.
     * @param options The options parameters.
     */
    beginInitiateScan(resourceGroupName, workspaceName, sqlPoolName, vulnerabilityAssessmentName, scanId, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                workspaceName,
                sqlPoolName,
                vulnerabilityAssessmentName,
                scanId,
                options
            }, initiateScanOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Executes a Vulnerability Assessment database scan.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param vulnerabilityAssessmentName The name of the vulnerability assessment.
     * @param scanId The vulnerability assessment scan Id of the scan to retrieve.
     * @param options The options parameters.
     */
    beginInitiateScanAndWait(resourceGroupName, workspaceName, sqlPoolName, vulnerabilityAssessmentName, scanId, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginInitiateScan(resourceGroupName, workspaceName, sqlPoolName, vulnerabilityAssessmentName, scanId, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Convert an existing scan result to a human readable format. If already exists nothing happens
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param vulnerabilityAssessmentName The name of the vulnerability assessment.
     * @param scanId The vulnerability assessment scan Id of the scan to retrieve.
     * @param options The options parameters.
     */
    export(resourceGroupName, workspaceName, sqlPoolName, vulnerabilityAssessmentName, scanId, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workspaceName,
            sqlPoolName,
            vulnerabilityAssessmentName,
            scanId,
            options
        }, exportOperationSpec);
    }
    /**
     * Gets a vulnerability assessment scan record of a Sql pool.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param vulnerabilityAssessmentName The name of the vulnerability assessment.
     * @param scanId The vulnerability assessment scan Id of the scan to retrieve.
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, sqlPoolName, vulnerabilityAssessmentName, scanId, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workspaceName,
            sqlPoolName,
            vulnerabilityAssessmentName,
            scanId,
            options
        }, getOperationSpec$m);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param vulnerabilityAssessmentName The name of the vulnerability assessment.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, workspaceName, sqlPoolName, vulnerabilityAssessmentName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workspaceName,
            sqlPoolName,
            vulnerabilityAssessmentName,
            nextLink,
            options
        }, listNextOperationSpec$d);
    }
}
// Operation Specifications
const serializer$t = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$f = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/vulnerabilityAssessments/{vulnerabilityAssessmentName}/scans",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VulnerabilityAssessmentScanRecordListResult
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName,
        vulnerabilityAssessmentName
    ],
    headerParameters: [accept],
    serializer: serializer$t
};
const initiateScanOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/vulnerabilityAssessments/{vulnerabilityAssessmentName}/scans/{scanId}/initiateScan",
    httpMethod: "POST",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName,
        vulnerabilityAssessmentName,
        scanId
    ],
    serializer: serializer$t
};
const exportOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/vulnerabilityAssessments/{vulnerabilityAssessmentName}/scans/{scanId}/export",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: SqlPoolVulnerabilityAssessmentScansExport
        },
        201: {
            bodyMapper: SqlPoolVulnerabilityAssessmentScansExport
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName,
        vulnerabilityAssessmentName,
        scanId
    ],
    headerParameters: [accept],
    serializer: serializer$t
};
const getOperationSpec$m = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/vulnerabilityAssessments/{vulnerabilityAssessmentName}/scans/{scanId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VulnerabilityAssessmentScanRecord
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName,
        vulnerabilityAssessmentName,
        scanId
    ],
    headerParameters: [accept],
    serializer: serializer$t
};
const listNextOperationSpec$d = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VulnerabilityAssessmentScanRecordListResult
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        nextLink,
        sqlPoolName,
        vulnerabilityAssessmentName
    ],
    headerParameters: [accept],
    serializer: serializer$t
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing SqlPoolSecurityAlertPolicies operations. */
class SqlPoolSecurityAlertPoliciesImpl {
    /**
     * Initialize a new instance of the class SqlPoolSecurityAlertPolicies class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get a list of Sql pool's security alert policies.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param options The options parameters.
     */
    list(resourceGroupName, workspaceName, sqlPoolName, options) {
        const iter = this.listPagingAll(resourceGroupName, workspaceName, sqlPoolName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, workspaceName, sqlPoolName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, workspaceName, sqlPoolName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, workspaceName, sqlPoolName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, workspaceName, sqlPoolName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, workspaceName, sqlPoolName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, workspaceName, sqlPoolName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get a list of Sql pool's security alert policies.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param options The options parameters.
     */
    _list(resourceGroupName, workspaceName, sqlPoolName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, sqlPoolName, options }, listOperationSpec$g);
    }
    /**
     * Get a Sql pool's security alert policy.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param securityAlertPolicyName The name of the security alert policy.
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, sqlPoolName, securityAlertPolicyName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workspaceName,
            sqlPoolName,
            securityAlertPolicyName,
            options
        }, getOperationSpec$n);
    }
    /**
     * Create or update a Sql pool's security alert policy.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param securityAlertPolicyName The name of the security alert policy.
     * @param parameters The Sql pool security alert policy.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, workspaceName, sqlPoolName, securityAlertPolicyName, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workspaceName,
            sqlPoolName,
            securityAlertPolicyName,
            parameters,
            options
        }, createOrUpdateOperationSpec$9);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, workspaceName, sqlPoolName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, sqlPoolName, nextLink, options }, listNextOperationSpec$e);
    }
}
// Operation Specifications
const serializer$u = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$g = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/securityAlertPolicies",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListSqlPoolSecurityAlertPolicies
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName
    ],
    headerParameters: [accept],
    serializer: serializer$u
};
const getOperationSpec$n = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/securityAlertPolicies/{securityAlertPolicyName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SqlPoolSecurityAlertPolicy
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName,
        securityAlertPolicyName
    ],
    headerParameters: [accept],
    serializer: serializer$u
};
const createOrUpdateOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/securityAlertPolicies/{securityAlertPolicyName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SqlPoolSecurityAlertPolicy
        },
        201: {
            bodyMapper: SqlPoolSecurityAlertPolicy
        },
        default: {}
    },
    requestBody: parameters10,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName,
        securityAlertPolicyName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$u
};
const listNextOperationSpec$e = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListSqlPoolSecurityAlertPolicies
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        nextLink,
        sqlPoolName
    ],
    headerParameters: [accept],
    serializer: serializer$u
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing SqlPoolVulnerabilityAssessmentRuleBaselines operations. */
class SqlPoolVulnerabilityAssessmentRuleBaselinesImpl {
    /**
     * Initialize a new instance of the class SqlPoolVulnerabilityAssessmentRuleBaselines class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Creates or updates a Sql pool's vulnerability assessment rule baseline.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param vulnerabilityAssessmentName The name of the vulnerability assessment.
     * @param ruleId The vulnerability assessment rule ID.
     * @param baselineName The name of the vulnerability assessment rule baseline (default implies a
     *                     baseline on a Sql pool level rule and master for workspace level rule).
     * @param parameters The requested rule baseline resource.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, workspaceName, sqlPoolName, vulnerabilityAssessmentName, ruleId, baselineName, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workspaceName,
            sqlPoolName,
            vulnerabilityAssessmentName,
            ruleId,
            baselineName,
            parameters,
            options
        }, createOrUpdateOperationSpec$a);
    }
    /**
     * Removes the database's vulnerability assessment rule baseline.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param vulnerabilityAssessmentName The name of the vulnerability assessment.
     * @param ruleId The vulnerability assessment rule ID.
     * @param baselineName The name of the vulnerability assessment rule baseline (default implies a
     *                     baseline on a Sql pool level rule and master for workspace level rule).
     * @param options The options parameters.
     */
    delete(resourceGroupName, workspaceName, sqlPoolName, vulnerabilityAssessmentName, ruleId, baselineName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workspaceName,
            sqlPoolName,
            vulnerabilityAssessmentName,
            ruleId,
            baselineName,
            options
        }, deleteOperationSpec$8);
    }
    /**
     * Gets a SqlPool's vulnerability assessment rule baseline.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param vulnerabilityAssessmentName The name of the vulnerability assessment.
     * @param ruleId The vulnerability assessment rule ID.
     * @param baselineName The name of the vulnerability assessment rule baseline (default implies a
     *                     baseline on a Sql pool level rule and master for server level rule).
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, sqlPoolName, vulnerabilityAssessmentName, ruleId, baselineName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workspaceName,
            sqlPoolName,
            vulnerabilityAssessmentName,
            ruleId,
            baselineName,
            options
        }, getOperationSpec$o);
    }
}
// Operation Specifications
const serializer$v = coreClient.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/vulnerabilityAssessments/{vulnerabilityAssessmentName}/rules/{ruleId}/baselines/{baselineName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SqlPoolVulnerabilityAssessmentRuleBaseline
        },
        default: {}
    },
    requestBody: parameters11,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName,
        vulnerabilityAssessmentName,
        ruleId,
        baselineName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$v
};
const deleteOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/vulnerabilityAssessments/{vulnerabilityAssessmentName}/rules/{ruleId}/baselines/{baselineName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 204: {}, default: {} },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName,
        vulnerabilityAssessmentName,
        ruleId,
        baselineName
    ],
    serializer: serializer$v
};
const getOperationSpec$o = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/vulnerabilityAssessments/{vulnerabilityAssessmentName}/rules/{ruleId}/baselines/{baselineName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SqlPoolVulnerabilityAssessmentRuleBaseline
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName,
        vulnerabilityAssessmentName,
        ruleId,
        baselineName
    ],
    headerParameters: [accept],
    serializer: serializer$v
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ExtendedSqlPoolBlobAuditingPolicies operations. */
class ExtendedSqlPoolBlobAuditingPoliciesImpl {
    /**
     * Initialize a new instance of the class ExtendedSqlPoolBlobAuditingPolicies class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists extended auditing settings of a Sql pool.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param options The options parameters.
     */
    listBySqlPool(resourceGroupName, workspaceName, sqlPoolName, options) {
        const iter = this.listBySqlPoolPagingAll(resourceGroupName, workspaceName, sqlPoolName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listBySqlPoolPagingPage(resourceGroupName, workspaceName, sqlPoolName, options);
            }
        };
    }
    listBySqlPoolPagingPage(resourceGroupName, workspaceName, sqlPoolName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySqlPoolPagingPage_1() {
            let result = yield tslib.__await(this._listBySqlPool(resourceGroupName, workspaceName, sqlPoolName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listBySqlPoolNext(resourceGroupName, workspaceName, sqlPoolName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listBySqlPoolPagingAll(resourceGroupName, workspaceName, sqlPoolName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySqlPoolPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBySqlPoolPagingPage(resourceGroupName, workspaceName, sqlPoolName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets an extended Sql pool's blob auditing policy.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, sqlPoolName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, sqlPoolName, options }, getOperationSpec$p);
    }
    /**
     * Creates or updates an extended Sql pool's blob auditing policy.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param parameters The extended Sql pool blob auditing policy.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, workspaceName, sqlPoolName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, sqlPoolName, parameters, options }, createOrUpdateOperationSpec$b);
    }
    /**
     * Lists extended auditing settings of a Sql pool.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param options The options parameters.
     */
    _listBySqlPool(resourceGroupName, workspaceName, sqlPoolName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, sqlPoolName, options }, listBySqlPoolOperationSpec$1);
    }
    /**
     * ListBySqlPoolNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param nextLink The nextLink from the previous successful call to the ListBySqlPool method.
     * @param options The options parameters.
     */
    _listBySqlPoolNext(resourceGroupName, workspaceName, sqlPoolName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, sqlPoolName, nextLink, options }, listBySqlPoolNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$w = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$p = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/extendedAuditingSettings/{blobAuditingPolicyName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExtendedSqlPoolBlobAuditingPolicy
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName,
        blobAuditingPolicyName
    ],
    headerParameters: [accept],
    serializer: serializer$w
};
const createOrUpdateOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/extendedAuditingSettings/{blobAuditingPolicyName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ExtendedSqlPoolBlobAuditingPolicy
        },
        201: {
            bodyMapper: ExtendedSqlPoolBlobAuditingPolicy
        },
        default: {}
    },
    requestBody: parameters12,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName,
        blobAuditingPolicyName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$w
};
const listBySqlPoolOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/extendedAuditingSettings",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExtendedSqlPoolBlobAuditingPolicyListResult
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName
    ],
    headerParameters: [accept],
    serializer: serializer$w
};
const listBySqlPoolNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExtendedSqlPoolBlobAuditingPolicyListResult
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        nextLink,
        sqlPoolName
    ],
    headerParameters: [accept],
    serializer: serializer$w
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing DataMaskingPolicies operations. */
class DataMaskingPoliciesImpl {
    /**
     * Initialize a new instance of the class DataMaskingPolicies class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Creates or updates a Sql pool data masking policy
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param parameters Parameters for creating or updating a data masking policy.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, workspaceName, sqlPoolName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, sqlPoolName, parameters, options }, createOrUpdateOperationSpec$c);
    }
    /**
     * Gets a Sql pool data masking policy.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, sqlPoolName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, sqlPoolName, options }, getOperationSpec$q);
    }
}
// Operation Specifications
const serializer$x = coreClient.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/dataMaskingPolicies/{dataMaskingPolicyName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: DataMaskingPolicy
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters13,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName,
        dataMaskingPolicyName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$x
};
const getOperationSpec$q = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/dataMaskingPolicies/{dataMaskingPolicyName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DataMaskingPolicy
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName,
        dataMaskingPolicyName
    ],
    headerParameters: [accept],
    serializer: serializer$x
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing DataMaskingRules operations. */
class DataMaskingRulesImpl {
    /**
     * Initialize a new instance of the class DataMaskingRules class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of Sql pool data masking rules.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param options The options parameters.
     */
    listBySqlPool(resourceGroupName, workspaceName, sqlPoolName, options) {
        const iter = this.listBySqlPoolPagingAll(resourceGroupName, workspaceName, sqlPoolName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listBySqlPoolPagingPage(resourceGroupName, workspaceName, sqlPoolName, options);
            }
        };
    }
    listBySqlPoolPagingPage(resourceGroupName, workspaceName, sqlPoolName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySqlPoolPagingPage_1() {
            let result = yield tslib.__await(this._listBySqlPool(resourceGroupName, workspaceName, sqlPoolName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listBySqlPoolPagingAll(resourceGroupName, workspaceName, sqlPoolName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySqlPoolPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBySqlPoolPagingPage(resourceGroupName, workspaceName, sqlPoolName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Creates or updates a Sql pool data masking rule.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param dataMaskingRuleName The name of the data masking rule.
     * @param parameters The required parameters for creating or updating a data masking rule.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, workspaceName, sqlPoolName, dataMaskingRuleName, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workspaceName,
            sqlPoolName,
            dataMaskingRuleName,
            parameters,
            options
        }, createOrUpdateOperationSpec$d);
    }
    /**
     * Gets the specific Sql pool data masking rule.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param dataMaskingRuleName The name of the data masking rule.
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, sqlPoolName, dataMaskingRuleName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workspaceName,
            sqlPoolName,
            dataMaskingRuleName,
            options
        }, getOperationSpec$r);
    }
    /**
     * Gets a list of Sql pool data masking rules.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param options The options parameters.
     */
    _listBySqlPool(resourceGroupName, workspaceName, sqlPoolName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, sqlPoolName, options }, listBySqlPoolOperationSpec$2);
    }
}
// Operation Specifications
const serializer$y = coreClient.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$d = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/dataMaskingPolicies/{dataMaskingPolicyName}/rules/{dataMaskingRuleName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: DataMaskingRule
        },
        201: {
            bodyMapper: DataMaskingRule
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters14,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName,
        dataMaskingPolicyName,
        dataMaskingRuleName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$y
};
const getOperationSpec$r = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/dataMaskingPolicies/{dataMaskingPolicyName}/rules/{dataMaskingRuleName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DataMaskingRule
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName,
        dataMaskingPolicyName,
        dataMaskingRuleName
    ],
    headerParameters: [accept],
    serializer: serializer$y
};
const listBySqlPoolOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/dataMaskingPolicies/{dataMaskingPolicyName}/rules",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DataMaskingRuleListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName,
        dataMaskingPolicyName
    ],
    headerParameters: [accept],
    serializer: serializer$y
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing SqlPoolColumns operations. */
class SqlPoolColumnsImpl {
    /**
     * Initialize a new instance of the class SqlPoolColumns class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get Sql pool column
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param schemaName The name of the schema.
     * @param tableName The name of the table.
     * @param columnName The name of the column.
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, sqlPoolName, schemaName, tableName, columnName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workspaceName,
            sqlPoolName,
            schemaName,
            tableName,
            columnName,
            options
        }, getOperationSpec$s);
    }
}
// Operation Specifications
const serializer$z = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$s = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/schemas/{schemaName}/tables/{tableName}/columns/{columnName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SqlPoolColumn
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName,
        schemaName,
        tableName,
        columnName
    ],
    headerParameters: [accept],
    serializer: serializer$z
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing SqlPoolWorkloadGroup operations. */
class SqlPoolWorkloadGroupImpl {
    /**
     * Initialize a new instance of the class SqlPoolWorkloadGroup class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get list of  Sql pool's workload groups.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param options The options parameters.
     */
    list(resourceGroupName, workspaceName, sqlPoolName, options) {
        const iter = this.listPagingAll(resourceGroupName, workspaceName, sqlPoolName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, workspaceName, sqlPoolName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, workspaceName, sqlPoolName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, workspaceName, sqlPoolName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, workspaceName, sqlPoolName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, workspaceName, sqlPoolName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, workspaceName, sqlPoolName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get a Sql pool's workload group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param workloadGroupName The name of the workload group.
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, sqlPoolName, workloadGroupName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workspaceName,
            sqlPoolName,
            workloadGroupName,
            options
        }, getOperationSpec$t);
    }
    /**
     * Create Or Update a Sql pool's workload group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param workloadGroupName The name of the workload group.
     * @param parameters The requested workload group state.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, workspaceName, sqlPoolName, workloadGroupName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                workspaceName,
                sqlPoolName,
                workloadGroupName,
                parameters,
                options
            }, createOrUpdateOperationSpec$e);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Create Or Update a Sql pool's workload group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param workloadGroupName The name of the workload group.
     * @param parameters The requested workload group state.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, workspaceName, sqlPoolName, workloadGroupName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, workspaceName, sqlPoolName, workloadGroupName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Remove Sql pool's workload group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param workloadGroupName The name of the workload group.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, workspaceName, sqlPoolName, workloadGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                workspaceName,
                sqlPoolName,
                workloadGroupName,
                options
            }, deleteOperationSpec$9);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Remove Sql pool's workload group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param workloadGroupName The name of the workload group.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, workspaceName, sqlPoolName, workloadGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, workspaceName, sqlPoolName, workloadGroupName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Get list of  Sql pool's workload groups.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param options The options parameters.
     */
    _list(resourceGroupName, workspaceName, sqlPoolName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, sqlPoolName, options }, listOperationSpec$h);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, workspaceName, sqlPoolName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, sqlPoolName, nextLink, options }, listNextOperationSpec$f);
    }
}
// Operation Specifications
const serializer$A = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$t = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/workloadGroups/{workloadGroupName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkloadGroup
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName,
        workloadGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$A
};
const createOrUpdateOperationSpec$e = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/workloadGroups/{workloadGroupName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: WorkloadGroup
        },
        201: {
            bodyMapper: WorkloadGroup
        },
        202: {
            bodyMapper: WorkloadGroup
        },
        204: {
            bodyMapper: WorkloadGroup
        },
        default: {}
    },
    requestBody: parameters15,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName,
        workloadGroupName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$A
};
const deleteOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/workloadGroups/{workloadGroupName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName,
        workloadGroupName
    ],
    serializer: serializer$A
};
const listOperationSpec$h = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/workloadGroups",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkloadGroupListResult
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName
    ],
    headerParameters: [accept],
    serializer: serializer$A
};
const listNextOperationSpec$f = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkloadGroupListResult
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        nextLink,
        sqlPoolName
    ],
    headerParameters: [accept],
    serializer: serializer$A
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing SqlPoolWorkloadClassifier operations. */
class SqlPoolWorkloadClassifierImpl {
    /**
     * Initialize a new instance of the class SqlPoolWorkloadClassifier class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get list of  Sql pool's workload classifier for workload groups.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param workloadGroupName The name of the workload group.
     * @param options The options parameters.
     */
    list(resourceGroupName, workspaceName, sqlPoolName, workloadGroupName, options) {
        const iter = this.listPagingAll(resourceGroupName, workspaceName, sqlPoolName, workloadGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, workspaceName, sqlPoolName, workloadGroupName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, workspaceName, sqlPoolName, workloadGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, workspaceName, sqlPoolName, workloadGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, workspaceName, sqlPoolName, workloadGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, workspaceName, sqlPoolName, workloadGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, workspaceName, sqlPoolName, workloadGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get a workload classifier of Sql pool's workload group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param workloadGroupName The name of the workload group.
     * @param workloadClassifierName The name of the workload classifier.
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, sqlPoolName, workloadGroupName, workloadClassifierName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workspaceName,
            sqlPoolName,
            workloadGroupName,
            workloadClassifierName,
            options
        }, getOperationSpec$u);
    }
    /**
     * Create Or Update workload classifier for a Sql pool's workload group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param workloadGroupName The name of the workload group.
     * @param workloadClassifierName The name of the workload classifier.
     * @param parameters The properties of the workload classifier.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, workspaceName, sqlPoolName, workloadGroupName, workloadClassifierName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                workspaceName,
                sqlPoolName,
                workloadGroupName,
                workloadClassifierName,
                parameters,
                options
            }, createOrUpdateOperationSpec$f);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Create Or Update workload classifier for a Sql pool's workload group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param workloadGroupName The name of the workload group.
     * @param workloadClassifierName The name of the workload classifier.
     * @param parameters The properties of the workload classifier.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, workspaceName, sqlPoolName, workloadGroupName, workloadClassifierName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, workspaceName, sqlPoolName, workloadGroupName, workloadClassifierName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Remove workload classifier of a Sql pool's workload group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param workloadGroupName The name of the workload group.
     * @param workloadClassifierName The name of the workload classifier.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, workspaceName, sqlPoolName, workloadGroupName, workloadClassifierName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                workspaceName,
                sqlPoolName,
                workloadGroupName,
                workloadClassifierName,
                options
            }, deleteOperationSpec$a);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Remove workload classifier of a Sql pool's workload group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param workloadGroupName The name of the workload group.
     * @param workloadClassifierName The name of the workload classifier.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, workspaceName, sqlPoolName, workloadGroupName, workloadClassifierName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, workspaceName, sqlPoolName, workloadGroupName, workloadClassifierName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Get list of  Sql pool's workload classifier for workload groups.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param workloadGroupName The name of the workload group.
     * @param options The options parameters.
     */
    _list(resourceGroupName, workspaceName, sqlPoolName, workloadGroupName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workspaceName,
            sqlPoolName,
            workloadGroupName,
            options
        }, listOperationSpec$i);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName SQL pool name
     * @param workloadGroupName The name of the workload group.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, workspaceName, sqlPoolName, workloadGroupName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workspaceName,
            sqlPoolName,
            workloadGroupName,
            nextLink,
            options
        }, listNextOperationSpec$g);
    }
}
// Operation Specifications
const serializer$B = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$u = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/workloadGroups/{workloadGroupName}/workloadClassifiers/{workloadClassifierName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkloadClassifier
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName,
        workloadGroupName,
        workloadClassifierName
    ],
    headerParameters: [accept],
    serializer: serializer$B
};
const createOrUpdateOperationSpec$f = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/workloadGroups/{workloadGroupName}/workloadClassifiers/{workloadClassifierName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: WorkloadClassifier
        },
        201: {
            bodyMapper: WorkloadClassifier
        },
        202: {
            bodyMapper: WorkloadClassifier
        },
        204: {
            bodyMapper: WorkloadClassifier
        },
        default: {}
    },
    requestBody: parameters16,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName,
        workloadGroupName,
        workloadClassifierName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$B
};
const deleteOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/workloadGroups/{workloadGroupName}/workloadClassifiers/{workloadClassifierName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName,
        workloadGroupName,
        workloadClassifierName
    ],
    serializer: serializer$B
};
const listOperationSpec$i = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlPools/{sqlPoolName}/workloadGroups/{workloadGroupName}/workloadClassifiers",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkloadClassifierListResult
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName,
        workloadGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$B
};
const listNextOperationSpec$g = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkloadClassifierListResult
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        nextLink,
        sqlPoolName,
        workloadGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$B
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing WorkspaceManagedSqlServerBlobAuditingPolicies operations. */
class WorkspaceManagedSqlServerBlobAuditingPoliciesImpl {
    /**
     * Initialize a new instance of the class WorkspaceManagedSqlServerBlobAuditingPolicies class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List workspace managed sql server's blob auditing policies.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param options The options parameters.
     */
    listByWorkspace(resourceGroupName, workspaceName, options) {
        const iter = this.listByWorkspacePagingAll(resourceGroupName, workspaceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByWorkspacePagingPage(resourceGroupName, workspaceName, options);
            }
        };
    }
    listByWorkspacePagingPage(resourceGroupName, workspaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByWorkspacePagingPage_1() {
            let result = yield tslib.__await(this._listByWorkspace(resourceGroupName, workspaceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByWorkspaceNext(resourceGroupName, workspaceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByWorkspacePagingAll(resourceGroupName, workspaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByWorkspacePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByWorkspacePagingPage(resourceGroupName, workspaceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get a workspace managed sql server's blob auditing policy.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param blobAuditingPolicyName The name of the blob auditing policy.
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, blobAuditingPolicyName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, blobAuditingPolicyName, options }, getOperationSpec$v);
    }
    /**
     * Create or Update a workspace managed sql server's blob auditing policy.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param blobAuditingPolicyName The name of the blob auditing policy.
     * @param parameters Properties of extended blob auditing policy.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, workspaceName, blobAuditingPolicyName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                workspaceName,
                blobAuditingPolicyName,
                parameters,
                options
            }, createOrUpdateOperationSpec$g);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Create or Update a workspace managed sql server's blob auditing policy.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param blobAuditingPolicyName The name of the blob auditing policy.
     * @param parameters Properties of extended blob auditing policy.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, workspaceName, blobAuditingPolicyName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, workspaceName, blobAuditingPolicyName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * List workspace managed sql server's blob auditing policies.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param options The options parameters.
     */
    _listByWorkspace(resourceGroupName, workspaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, options }, listByWorkspaceOperationSpec$3);
    }
    /**
     * ListByWorkspaceNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param nextLink The nextLink from the previous successful call to the ListByWorkspace method.
     * @param options The options parameters.
     */
    _listByWorkspaceNext(resourceGroupName, workspaceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, nextLink, options }, listByWorkspaceNextOperationSpec$3);
    }
}
// Operation Specifications
const serializer$C = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$v = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/auditingSettings/{blobAuditingPolicyName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServerBlobAuditingPolicy
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        blobAuditingPolicyName1
    ],
    headerParameters: [accept],
    serializer: serializer$C
};
const createOrUpdateOperationSpec$g = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/auditingSettings/{blobAuditingPolicyName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ServerBlobAuditingPolicy
        },
        201: {
            bodyMapper: ServerBlobAuditingPolicy
        },
        202: {
            bodyMapper: ServerBlobAuditingPolicy
        },
        204: {
            bodyMapper: ServerBlobAuditingPolicy
        },
        default: {}
    },
    requestBody: parameters17,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        blobAuditingPolicyName1
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$C
};
const listByWorkspaceOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/auditingSettings",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServerBlobAuditingPolicyListResult
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$C
};
const listByWorkspaceNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServerBlobAuditingPolicyListResult
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$C
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing WorkspaceManagedSqlServerExtendedBlobAuditingPolicies operations. */
class WorkspaceManagedSqlServerExtendedBlobAuditingPoliciesImpl {
    /**
     * Initialize a new instance of the class WorkspaceManagedSqlServerExtendedBlobAuditingPolicies class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List workspace managed sql server's extended blob auditing policies.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param options The options parameters.
     */
    listByWorkspace(resourceGroupName, workspaceName, options) {
        const iter = this.listByWorkspacePagingAll(resourceGroupName, workspaceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByWorkspacePagingPage(resourceGroupName, workspaceName, options);
            }
        };
    }
    listByWorkspacePagingPage(resourceGroupName, workspaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByWorkspacePagingPage_1() {
            let result = yield tslib.__await(this._listByWorkspace(resourceGroupName, workspaceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByWorkspaceNext(resourceGroupName, workspaceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByWorkspacePagingAll(resourceGroupName, workspaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByWorkspacePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByWorkspacePagingPage(resourceGroupName, workspaceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get a workspace SQL server's extended blob auditing policy.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param blobAuditingPolicyName The name of the blob auditing policy.
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, blobAuditingPolicyName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, blobAuditingPolicyName, options }, getOperationSpec$w);
    }
    /**
     * Create or Update a workspace managed sql server's extended blob auditing policy.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param blobAuditingPolicyName The name of the blob auditing policy.
     * @param parameters Properties of extended blob auditing policy.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, workspaceName, blobAuditingPolicyName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                workspaceName,
                blobAuditingPolicyName,
                parameters,
                options
            }, createOrUpdateOperationSpec$h);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Create or Update a workspace managed sql server's extended blob auditing policy.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param blobAuditingPolicyName The name of the blob auditing policy.
     * @param parameters Properties of extended blob auditing policy.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, workspaceName, blobAuditingPolicyName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, workspaceName, blobAuditingPolicyName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * List workspace managed sql server's extended blob auditing policies.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param options The options parameters.
     */
    _listByWorkspace(resourceGroupName, workspaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, options }, listByWorkspaceOperationSpec$4);
    }
    /**
     * ListByWorkspaceNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param nextLink The nextLink from the previous successful call to the ListByWorkspace method.
     * @param options The options parameters.
     */
    _listByWorkspaceNext(resourceGroupName, workspaceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, nextLink, options }, listByWorkspaceNextOperationSpec$4);
    }
}
// Operation Specifications
const serializer$D = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$w = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/extendedAuditingSettings/{blobAuditingPolicyName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExtendedServerBlobAuditingPolicy
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        blobAuditingPolicyName1
    ],
    headerParameters: [accept],
    serializer: serializer$D
};
const createOrUpdateOperationSpec$h = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/extendedAuditingSettings/{blobAuditingPolicyName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ExtendedServerBlobAuditingPolicy
        },
        201: {
            bodyMapper: ExtendedServerBlobAuditingPolicy
        },
        202: {
            bodyMapper: ExtendedServerBlobAuditingPolicy
        },
        204: {
            bodyMapper: ExtendedServerBlobAuditingPolicy
        },
        default: {}
    },
    requestBody: parameters18,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        blobAuditingPolicyName1
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$D
};
const listByWorkspaceOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/extendedAuditingSettings",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExtendedServerBlobAuditingPolicyListResult
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$D
};
const listByWorkspaceNextOperationSpec$4 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExtendedServerBlobAuditingPolicyListResult
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$D
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing WorkspaceManagedSqlServerSecurityAlertPolicy operations. */
class WorkspaceManagedSqlServerSecurityAlertPolicyImpl {
    /**
     * Initialize a new instance of the class WorkspaceManagedSqlServerSecurityAlertPolicy class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get workspace managed sql server's threat detection policies.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param options The options parameters.
     */
    list(resourceGroupName, workspaceName, options) {
        const iter = this.listPagingAll(resourceGroupName, workspaceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, workspaceName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, workspaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, workspaceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, workspaceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, workspaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, workspaceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get a workspace managed sql server's security alert policy.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param securityAlertPolicyName The name of the security alert policy.
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, securityAlertPolicyName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, securityAlertPolicyName, options }, getOperationSpec$x);
    }
    /**
     * Create or Update a workspace managed sql server's threat detection policy.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param securityAlertPolicyName The name of the security alert policy.
     * @param parameters The workspace managed sql server security alert policy.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, workspaceName, securityAlertPolicyName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                workspaceName,
                securityAlertPolicyName,
                parameters,
                options
            }, createOrUpdateOperationSpec$i);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Create or Update a workspace managed sql server's threat detection policy.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param securityAlertPolicyName The name of the security alert policy.
     * @param parameters The workspace managed sql server security alert policy.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, workspaceName, securityAlertPolicyName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, workspaceName, securityAlertPolicyName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Get workspace managed sql server's threat detection policies.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param options The options parameters.
     */
    _list(resourceGroupName, workspaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, options }, listOperationSpec$j);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, workspaceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, nextLink, options }, listNextOperationSpec$h);
    }
}
// Operation Specifications
const serializer$E = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$x = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/securityAlertPolicies/{securityAlertPolicyName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServerSecurityAlertPolicy
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        securityAlertPolicyName1
    ],
    headerParameters: [accept],
    serializer: serializer$E
};
const createOrUpdateOperationSpec$i = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/securityAlertPolicies/{securityAlertPolicyName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ServerSecurityAlertPolicy
        },
        201: {
            bodyMapper: ServerSecurityAlertPolicy
        },
        202: {
            bodyMapper: ServerSecurityAlertPolicy
        },
        204: {
            bodyMapper: ServerSecurityAlertPolicy
        },
        default: {}
    },
    requestBody: parameters19,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        securityAlertPolicyName1
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$E
};
const listOperationSpec$j = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/securityAlertPolicies",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServerSecurityAlertPolicyListResult
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$E
};
const listNextOperationSpec$h = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServerSecurityAlertPolicyListResult
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$E
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing WorkspaceManagedSqlServerVulnerabilityAssessments operations. */
class WorkspaceManagedSqlServerVulnerabilityAssessmentsImpl {
    /**
     * Initialize a new instance of the class WorkspaceManagedSqlServerVulnerabilityAssessments class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists the vulnerability assessment policies associated with a workspace managed sql server.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param options The options parameters.
     */
    list(resourceGroupName, workspaceName, options) {
        const iter = this.listPagingAll(resourceGroupName, workspaceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, workspaceName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, workspaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, workspaceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, workspaceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, workspaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, workspaceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get workspace managed sql server's vulnerability assessment.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param vulnerabilityAssessmentName The name of the vulnerability assessment.
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, vulnerabilityAssessmentName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workspaceName,
            vulnerabilityAssessmentName,
            options
        }, getOperationSpec$y);
    }
    /**
     * Create or Update workspace managed sql server's vulnerability assessment.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param vulnerabilityAssessmentName The name of the vulnerability assessment.
     * @param parameters Properties for vulnerability assessment.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, workspaceName, vulnerabilityAssessmentName, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workspaceName,
            vulnerabilityAssessmentName,
            parameters,
            options
        }, createOrUpdateOperationSpec$j);
    }
    /**
     * Remove workspace managed sql server's vulnerability assessment.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param vulnerabilityAssessmentName The name of the vulnerability assessment.
     * @param options The options parameters.
     */
    delete(resourceGroupName, workspaceName, vulnerabilityAssessmentName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workspaceName,
            vulnerabilityAssessmentName,
            options
        }, deleteOperationSpec$b);
    }
    /**
     * Lists the vulnerability assessment policies associated with a workspace managed sql server.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param options The options parameters.
     */
    _list(resourceGroupName, workspaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, options }, listOperationSpec$k);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, workspaceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, nextLink, options }, listNextOperationSpec$i);
    }
}
// Operation Specifications
const serializer$F = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$y = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/vulnerabilityAssessments/{vulnerabilityAssessmentName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServerVulnerabilityAssessment
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        vulnerabilityAssessmentName
    ],
    headerParameters: [accept],
    serializer: serializer$F
};
const createOrUpdateOperationSpec$j = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/vulnerabilityAssessments/{vulnerabilityAssessmentName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ServerVulnerabilityAssessment
        },
        201: {
            bodyMapper: ServerVulnerabilityAssessment
        },
        default: {}
    },
    requestBody: parameters20,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        vulnerabilityAssessmentName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$F
};
const deleteOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/vulnerabilityAssessments/{vulnerabilityAssessmentName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 204: {}, default: {} },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        vulnerabilityAssessmentName
    ],
    serializer: serializer$F
};
const listOperationSpec$k = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/vulnerabilityAssessments",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServerVulnerabilityAssessmentListResult
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$F
};
const listNextOperationSpec$i = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServerVulnerabilityAssessmentListResult
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$F
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing WorkspaceManagedSqlServerEncryptionProtector operations. */
class WorkspaceManagedSqlServerEncryptionProtectorImpl {
    /**
     * Initialize a new instance of the class WorkspaceManagedSqlServerEncryptionProtector class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get list of encryption protectors for workspace managed sql server.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param options The options parameters.
     */
    list(resourceGroupName, workspaceName, options) {
        const iter = this.listPagingAll(resourceGroupName, workspaceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, workspaceName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, workspaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, workspaceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, workspaceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, workspaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, workspaceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get workspace managed sql server's encryption protector.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param encryptionProtectorName The name of the encryption protector.
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, encryptionProtectorName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, encryptionProtectorName, options }, getOperationSpec$z);
    }
    /**
     * Updates workspace managed sql server's encryption protector.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param encryptionProtectorName The name of the encryption protector.
     * @param parameters The requested encryption protector resource state.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, workspaceName, encryptionProtectorName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                workspaceName,
                encryptionProtectorName,
                parameters,
                options
            }, createOrUpdateOperationSpec$k);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Updates workspace managed sql server's encryption protector.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param encryptionProtectorName The name of the encryption protector.
     * @param parameters The requested encryption protector resource state.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, workspaceName, encryptionProtectorName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, workspaceName, encryptionProtectorName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Get list of encryption protectors for workspace managed sql server.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param options The options parameters.
     */
    _list(resourceGroupName, workspaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, options }, listOperationSpec$l);
    }
    /**
     * Revalidates workspace managed sql server's existing encryption protector.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param encryptionProtectorName The name of the encryption protector.
     * @param options The options parameters.
     */
    beginRevalidate(resourceGroupName, workspaceName, encryptionProtectorName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, workspaceName, encryptionProtectorName, options }, revalidateOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Revalidates workspace managed sql server's existing encryption protector.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param encryptionProtectorName The name of the encryption protector.
     * @param options The options parameters.
     */
    beginRevalidateAndWait(resourceGroupName, workspaceName, encryptionProtectorName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRevalidate(resourceGroupName, workspaceName, encryptionProtectorName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, workspaceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, nextLink, options }, listNextOperationSpec$j);
    }
}
// Operation Specifications
const serializer$G = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$z = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/encryptionProtector/{encryptionProtectorName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EncryptionProtector
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        encryptionProtectorName
    ],
    headerParameters: [accept],
    serializer: serializer$G
};
const createOrUpdateOperationSpec$k = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/encryptionProtector/{encryptionProtectorName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: EncryptionProtector
        },
        201: {
            bodyMapper: EncryptionProtector
        },
        202: {
            bodyMapper: EncryptionProtector
        },
        204: {
            bodyMapper: EncryptionProtector
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters21,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        encryptionProtectorName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$G
};
const listOperationSpec$l = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/encryptionProtector",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EncryptionProtectorListResult
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$G
};
const revalidateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/encryptionProtector/{encryptionProtectorName}/revalidate",
    httpMethod: "POST",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        encryptionProtectorName
    ],
    serializer: serializer$G
};
const listNextOperationSpec$j = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EncryptionProtectorListResult
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$G
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing WorkspaceManagedSqlServerUsages operations. */
class WorkspaceManagedSqlServerUsagesImpl {
    /**
     * Initialize a new instance of the class WorkspaceManagedSqlServerUsages class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get list of server usages metric for workspace managed sql server.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param options The options parameters.
     */
    list(resourceGroupName, workspaceName, options) {
        const iter = this.listPagingAll(resourceGroupName, workspaceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, workspaceName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, workspaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, workspaceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, workspaceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, workspaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, workspaceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get list of server usages metric for workspace managed sql server.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param options The options parameters.
     */
    _list(resourceGroupName, workspaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, options }, listOperationSpec$m);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, workspaceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, nextLink, options }, listNextOperationSpec$k);
    }
}
// Operation Specifications
const serializer$H = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$m = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlUsages",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServerUsageListResult
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$H
};
const listNextOperationSpec$k = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServerUsageListResult
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$H
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing WorkspaceManagedSqlServerRecoverableSqlPools operations. */
class WorkspaceManagedSqlServerRecoverableSqlPoolsImpl {
    /**
     * Initialize a new instance of the class WorkspaceManagedSqlServerRecoverableSqlPools class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get list of recoverable sql pools for workspace managed sql server.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param options The options parameters.
     */
    list(resourceGroupName, workspaceName, options) {
        const iter = this.listPagingAll(resourceGroupName, workspaceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, workspaceName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, workspaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, workspaceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, workspaceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, workspaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, workspaceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get list of recoverable sql pools for workspace managed sql server.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param options The options parameters.
     */
    _list(resourceGroupName, workspaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, options }, listOperationSpec$n);
    }
    /**
     * Get recoverable sql pools for workspace managed sql server.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param sqlPoolName The name of the sql pool
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, sqlPoolName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, sqlPoolName, options }, getOperationSpec$A);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, workspaceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, nextLink, options }, listNextOperationSpec$l);
    }
}
// Operation Specifications
const serializer$I = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$n = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/recoverableSqlPools",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RecoverableSqlPoolListResult
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$I
};
const getOperationSpec$A = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/recoverableSqlPools/{sqlPoolName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RecoverableSqlPool
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sqlPoolName
    ],
    headerParameters: [accept],
    serializer: serializer$I
};
const listNextOperationSpec$l = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RecoverableSqlPoolListResult
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$I
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Workspaces operations. */
class WorkspacesImpl {
    /**
     * Initialize a new instance of the class Workspaces class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Returns a list of workspaces in a resource group
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupPagingPage(resourceGroupName, options);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Returns a list of workspaces in a subscription
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Returns a list of workspaces in a resource group
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$1);
    }
    /**
     * Gets a workspace
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, options }, getOperationSpec$B);
    }
    /**
     * Updates a workspace
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param workspacePatchInfo Workspace patch request properties
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, workspaceName, workspacePatchInfo, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, workspaceName, workspacePatchInfo, options }, updateOperationSpec$4);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Updates a workspace
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param workspacePatchInfo Workspace patch request properties
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, workspaceName, workspacePatchInfo, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, workspaceName, workspacePatchInfo, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Creates or updates a workspace
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param workspaceInfo Workspace create or update request properties
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, workspaceName, workspaceInfo, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, workspaceName, workspaceInfo, options }, createOrUpdateOperationSpec$l);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Creates or updates a workspace
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param workspaceInfo Workspace create or update request properties
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, workspaceName, workspaceInfo, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, workspaceName, workspaceInfo, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes a workspace
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, workspaceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, workspaceName, options }, deleteOperationSpec$c);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes a workspace
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, workspaceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, workspaceName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Returns a list of workspaces in a subscription
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$o);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$1);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$m);
    }
}
// Operation Specifications
const serializer$J = coreClient.createSerializer(Mappers, /* isXml */ false);
const listByResourceGroupOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkspaceInfoListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$J
};
const getOperationSpec$B = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Workspace
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$J
};
const updateOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Workspace
        },
        201: {
            bodyMapper: Workspace
        },
        202: {
            bodyMapper: Workspace
        },
        204: {
            bodyMapper: Workspace
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: workspacePatchInfo,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$J
};
const createOrUpdateOperationSpec$l = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Workspace
        },
        201: {
            bodyMapper: Workspace
        },
        202: {
            bodyMapper: Workspace
        },
        204: {
            bodyMapper: Workspace
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: workspaceInfo,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$J
};
const deleteOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}",
    httpMethod: "DELETE",
    responses: {
        200: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } }
            }
        },
        201: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } }
            }
        },
        202: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } }
            }
        },
        204: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } }
            }
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$J
};
const listOperationSpec$o = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Synapse/workspaces",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkspaceInfoListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$J
};
const listByResourceGroupNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkspaceInfoListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$J
};
const listNextOperationSpec$m = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkspaceInfoListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$J
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing WorkspaceAadAdmins operations. */
class WorkspaceAadAdminsImpl {
    /**
     * Initialize a new instance of the class WorkspaceAadAdmins class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a workspace active directory admin
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, options }, getOperationSpec$C);
    }
    /**
     * Creates or updates a workspace active directory admin
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param aadAdminInfo Workspace active directory administrator properties
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, workspaceName, aadAdminInfo, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, workspaceName, aadAdminInfo, options }, createOrUpdateOperationSpec$m);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Creates or updates a workspace active directory admin
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param aadAdminInfo Workspace active directory administrator properties
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, workspaceName, aadAdminInfo, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, workspaceName, aadAdminInfo, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes a workspace active directory admin
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, workspaceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, workspaceName, options }, deleteOperationSpec$d);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes a workspace active directory admin
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, workspaceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, workspaceName, options);
            return poller.pollUntilDone();
        });
    }
}
// Operation Specifications
const serializer$K = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$C = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/administrators/activeDirectory",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkspaceAadAdminInfo
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$K
};
const createOrUpdateOperationSpec$m = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/administrators/activeDirectory",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: WorkspaceAadAdminInfo
        },
        201: {
            bodyMapper: WorkspaceAadAdminInfo
        },
        202: {
            bodyMapper: WorkspaceAadAdminInfo
        },
        204: {
            bodyMapper: WorkspaceAadAdminInfo
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: aadAdminInfo,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$K
};
const deleteOperationSpec$d = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/administrators/activeDirectory",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$K
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing WorkspaceSqlAadAdmins operations. */
class WorkspaceSqlAadAdminsImpl {
    /**
     * Initialize a new instance of the class WorkspaceSqlAadAdmins class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a workspace SQL active directory admin
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, options }, getOperationSpec$D);
    }
    /**
     * Creates or updates a workspace SQL active directory admin
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param aadAdminInfo Workspace active directory administrator properties
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, workspaceName, aadAdminInfo, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, workspaceName, aadAdminInfo, options }, createOrUpdateOperationSpec$n);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Creates or updates a workspace SQL active directory admin
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param aadAdminInfo Workspace active directory administrator properties
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, workspaceName, aadAdminInfo, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, workspaceName, aadAdminInfo, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes a workspace SQL active directory admin
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, workspaceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, workspaceName, options }, deleteOperationSpec$e);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Deletes a workspace SQL active directory admin
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, workspaceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, workspaceName, options);
            return poller.pollUntilDone();
        });
    }
}
// Operation Specifications
const serializer$L = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$D = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlAdministrators/activeDirectory",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkspaceAadAdminInfo
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$L
};
const createOrUpdateOperationSpec$n = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlAdministrators/activeDirectory",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: WorkspaceAadAdminInfo
        },
        201: {
            bodyMapper: WorkspaceAadAdminInfo
        },
        202: {
            bodyMapper: WorkspaceAadAdminInfo
        },
        204: {
            bodyMapper: WorkspaceAadAdminInfo
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: aadAdminInfo,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$L
};
const deleteOperationSpec$e = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sqlAdministrators/activeDirectory",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$L
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing WorkspaceManagedIdentitySqlControlSettings operations. */
class WorkspaceManagedIdentitySqlControlSettingsImpl {
    /**
     * Initialize a new instance of the class WorkspaceManagedIdentitySqlControlSettings class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get Managed Identity Sql Control Settings
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, options }, getOperationSpec$E);
    }
    /**
     * Create or update Managed Identity Sql Control Settings
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param managedIdentitySqlControlSettings Managed Identity Sql Control Settings
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, workspaceName, managedIdentitySqlControlSettings, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                workspaceName,
                managedIdentitySqlControlSettings,
                options
            }, createOrUpdateOperationSpec$o);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Create or update Managed Identity Sql Control Settings
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param managedIdentitySqlControlSettings Managed Identity Sql Control Settings
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, workspaceName, managedIdentitySqlControlSettings, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, workspaceName, managedIdentitySqlControlSettings, options);
            return poller.pollUntilDone();
        });
    }
}
// Operation Specifications
const serializer$M = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$E = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/managedIdentitySqlControlSettings/default",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedIdentitySqlControlSettingsModel
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$M
};
const createOrUpdateOperationSpec$o = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/managedIdentitySqlControlSettings/default",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ManagedIdentitySqlControlSettingsModel
        },
        201: {
            bodyMapper: ManagedIdentitySqlControlSettingsModel
        },
        202: {
            bodyMapper: ManagedIdentitySqlControlSettingsModel
        },
        204: {
            bodyMapper: ManagedIdentitySqlControlSettingsModel
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: managedIdentitySqlControlSettings,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$M
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing RestorableDroppedSqlPools operations. */
class RestorableDroppedSqlPoolsImpl {
    /**
     * Initialize a new instance of the class RestorableDroppedSqlPools class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of deleted Sql pools that can be restored
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param options The options parameters.
     */
    listByWorkspace(resourceGroupName, workspaceName, options) {
        const iter = this.listByWorkspacePagingAll(resourceGroupName, workspaceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByWorkspacePagingPage(resourceGroupName, workspaceName, options);
            }
        };
    }
    listByWorkspacePagingPage(resourceGroupName, workspaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByWorkspacePagingPage_1() {
            let result = yield tslib.__await(this._listByWorkspace(resourceGroupName, workspaceName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listByWorkspacePagingAll(resourceGroupName, workspaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByWorkspacePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByWorkspacePagingPage(resourceGroupName, workspaceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a deleted sql pool that can be restored
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param restorableDroppedSqlPoolId The id of the deleted Sql Pool in the form of
     *                                   sqlPoolName,deletionTimeInFileTimeFormat
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, restorableDroppedSqlPoolId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, restorableDroppedSqlPoolId, options }, getOperationSpec$F);
    }
    /**
     * Gets a list of deleted Sql pools that can be restored
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param options The options parameters.
     */
    _listByWorkspace(resourceGroupName, workspaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, options }, listByWorkspaceOperationSpec$5);
    }
}
// Operation Specifications
const serializer$N = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$F = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/restorableDroppedSqlPools/{restorableDroppedSqlPoolId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RestorableDroppedSqlPool
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        restorableDroppedSqlPoolId
    ],
    headerParameters: [accept],
    serializer: serializer$N
};
const listByWorkspaceOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/restorableDroppedSqlPools",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RestorableDroppedSqlPoolListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$N
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing BigDataPools operations. */
class BigDataPoolsImpl {
    /**
     * Initialize a new instance of the class BigDataPools class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List Big Data pools in a workspace.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param options The options parameters.
     */
    listByWorkspace(resourceGroupName, workspaceName, options) {
        const iter = this.listByWorkspacePagingAll(resourceGroupName, workspaceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByWorkspacePagingPage(resourceGroupName, workspaceName, options);
            }
        };
    }
    listByWorkspacePagingPage(resourceGroupName, workspaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByWorkspacePagingPage_1() {
            let result = yield tslib.__await(this._listByWorkspace(resourceGroupName, workspaceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByWorkspaceNext(resourceGroupName, workspaceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByWorkspacePagingAll(resourceGroupName, workspaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByWorkspacePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByWorkspacePagingPage(resourceGroupName, workspaceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get a Big Data pool.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param bigDataPoolName Big Data pool name
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, bigDataPoolName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, bigDataPoolName, options }, getOperationSpec$G);
    }
    /**
     * Patch a Big Data pool.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param bigDataPoolName Big Data pool name
     * @param bigDataPoolPatchInfo The updated Big Data pool properties
     * @param options The options parameters.
     */
    update(resourceGroupName, workspaceName, bigDataPoolName, bigDataPoolPatchInfo, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workspaceName,
            bigDataPoolName,
            bigDataPoolPatchInfo,
            options
        }, updateOperationSpec$5);
    }
    /**
     * Create a new Big Data pool.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param bigDataPoolName Big Data pool name
     * @param bigDataPoolInfo The Big Data pool to create.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, workspaceName, bigDataPoolName, bigDataPoolInfo, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                workspaceName,
                bigDataPoolName,
                bigDataPoolInfo,
                options
            }, createOrUpdateOperationSpec$p);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Create a new Big Data pool.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param bigDataPoolName Big Data pool name
     * @param bigDataPoolInfo The Big Data pool to create.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, workspaceName, bigDataPoolName, bigDataPoolInfo, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, workspaceName, bigDataPoolName, bigDataPoolInfo, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete a Big Data pool from the workspace.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param bigDataPoolName Big Data pool name
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, workspaceName, bigDataPoolName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, workspaceName, bigDataPoolName, options }, deleteOperationSpec$f);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Delete a Big Data pool from the workspace.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param bigDataPoolName Big Data pool name
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, workspaceName, bigDataPoolName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, workspaceName, bigDataPoolName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * List Big Data pools in a workspace.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param options The options parameters.
     */
    _listByWorkspace(resourceGroupName, workspaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, options }, listByWorkspaceOperationSpec$6);
    }
    /**
     * ListByWorkspaceNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param nextLink The nextLink from the previous successful call to the ListByWorkspace method.
     * @param options The options parameters.
     */
    _listByWorkspaceNext(resourceGroupName, workspaceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, nextLink, options }, listByWorkspaceNextOperationSpec$5);
    }
}
// Operation Specifications
const serializer$O = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$G = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/bigDataPools/{bigDataPoolName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BigDataPoolResourceInfo
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        bigDataPoolName
    ],
    headerParameters: [accept],
    serializer: serializer$O
};
const updateOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/bigDataPools/{bigDataPoolName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: BigDataPoolResourceInfo
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: bigDataPoolPatchInfo,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        bigDataPoolName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$O
};
const createOrUpdateOperationSpec$p = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/bigDataPools/{bigDataPoolName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: BigDataPoolResourceInfo
        },
        201: {
            bodyMapper: BigDataPoolResourceInfo
        },
        202: {
            bodyMapper: BigDataPoolResourceInfo
        },
        204: {
            bodyMapper: BigDataPoolResourceInfo
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: bigDataPoolInfo,
    queryParameters: [apiVersion1, force],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        bigDataPoolName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$O
};
const deleteOperationSpec$f = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/bigDataPools/{bigDataPoolName}",
    httpMethod: "DELETE",
    responses: {
        200: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } }
            }
        },
        201: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } }
            }
        },
        202: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } }
            }
        },
        204: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } }
            }
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        bigDataPoolName
    ],
    headerParameters: [accept],
    serializer: serializer$O
};
const listByWorkspaceOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/bigDataPools",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BigDataPoolResourceInfoListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$O
};
const listByWorkspaceNextOperationSpec$5 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BigDataPoolResourceInfoListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$O
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing Library operations. */
class LibraryImpl {
    /**
     * Initialize a new instance of the class Library class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get library by name in a workspace.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param libraryName Library name
     * @param workspaceName The name of the workspace.
     * @param options The options parameters.
     */
    get(resourceGroupName, libraryName, workspaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, libraryName, workspaceName, options }, getOperationSpec$H);
    }
}
// Operation Specifications
const serializer$P = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$H = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/libraries/{libraryName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LibraryResource
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        libraryName
    ],
    headerParameters: [accept],
    serializer: serializer$P
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Libraries operations. */
class LibrariesImpl {
    /**
     * Initialize a new instance of the class Libraries class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List libraries in a workspace.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param options The options parameters.
     */
    listByWorkspace(resourceGroupName, workspaceName, options) {
        const iter = this.listByWorkspacePagingAll(resourceGroupName, workspaceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByWorkspacePagingPage(resourceGroupName, workspaceName, options);
            }
        };
    }
    listByWorkspacePagingPage(resourceGroupName, workspaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByWorkspacePagingPage_1() {
            let result = yield tslib.__await(this._listByWorkspace(resourceGroupName, workspaceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByWorkspaceNext(resourceGroupName, workspaceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByWorkspacePagingAll(resourceGroupName, workspaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByWorkspacePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByWorkspacePagingPage(resourceGroupName, workspaceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List libraries in a workspace.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param options The options parameters.
     */
    _listByWorkspace(resourceGroupName, workspaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, options }, listByWorkspaceOperationSpec$7);
    }
    /**
     * ListByWorkspaceNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param nextLink The nextLink from the previous successful call to the ListByWorkspace method.
     * @param options The options parameters.
     */
    _listByWorkspaceNext(resourceGroupName, workspaceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, nextLink, options }, listByWorkspaceNextOperationSpec$6);
    }
}
// Operation Specifications
const serializer$Q = coreClient.createSerializer(Mappers, /* isXml */ false);
const listByWorkspaceOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/libraries",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LibraryListResponse
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$Q
};
const listByWorkspaceNextOperationSpec$6 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LibraryListResponse
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$Q
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing IntegrationRuntimes operations. */
class IntegrationRuntimesImpl {
    /**
     * Initialize a new instance of the class IntegrationRuntimes class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List all integration runtimes
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param options The options parameters.
     */
    listByWorkspace(resourceGroupName, workspaceName, options) {
        const iter = this.listByWorkspacePagingAll(resourceGroupName, workspaceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByWorkspacePagingPage(resourceGroupName, workspaceName, options);
            }
        };
    }
    listByWorkspacePagingPage(resourceGroupName, workspaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByWorkspacePagingPage_1() {
            let result = yield tslib.__await(this._listByWorkspace(resourceGroupName, workspaceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByWorkspaceNext(resourceGroupName, workspaceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByWorkspacePagingAll(resourceGroupName, workspaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByWorkspacePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByWorkspacePagingPage(resourceGroupName, workspaceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Update an integration runtime
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param integrationRuntimeName Integration runtime name
     * @param updateIntegrationRuntimeRequest The parameters for updating an integration runtime.
     * @param options The options parameters.
     */
    update(resourceGroupName, workspaceName, integrationRuntimeName, updateIntegrationRuntimeRequest, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workspaceName,
            integrationRuntimeName,
            updateIntegrationRuntimeRequest,
            options
        }, updateOperationSpec$6);
    }
    /**
     * Get an integration runtime
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param integrationRuntimeName Integration runtime name
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, integrationRuntimeName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, integrationRuntimeName, options }, getOperationSpec$I);
    }
    /**
     * Create an integration runtime
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param integrationRuntimeName Integration runtime name
     * @param integrationRuntime Integration runtime resource definition.
     * @param options The options parameters.
     */
    beginCreate(resourceGroupName, workspaceName, integrationRuntimeName, integrationRuntime, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                workspaceName,
                integrationRuntimeName,
                integrationRuntime,
                options
            }, createOperationSpec$5);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Create an integration runtime
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param integrationRuntimeName Integration runtime name
     * @param integrationRuntime Integration runtime resource definition.
     * @param options The options parameters.
     */
    beginCreateAndWait(resourceGroupName, workspaceName, integrationRuntimeName, integrationRuntime, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreate(resourceGroupName, workspaceName, integrationRuntimeName, integrationRuntime, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete an integration runtime
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param integrationRuntimeName Integration runtime name
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, workspaceName, integrationRuntimeName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, workspaceName, integrationRuntimeName, options }, deleteOperationSpec$g);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Delete an integration runtime
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param integrationRuntimeName Integration runtime name
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, workspaceName, integrationRuntimeName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, workspaceName, integrationRuntimeName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Upgrade an integration runtime
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param integrationRuntimeName Integration runtime name
     * @param options The options parameters.
     */
    upgrade(resourceGroupName, workspaceName, integrationRuntimeName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, integrationRuntimeName, options }, upgradeOperationSpec);
    }
    /**
     * List all integration runtimes
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param options The options parameters.
     */
    _listByWorkspace(resourceGroupName, workspaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, options }, listByWorkspaceOperationSpec$8);
    }
    /**
     * Start an integration runtime
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param integrationRuntimeName Integration runtime name
     * @param options The options parameters.
     */
    beginStart(resourceGroupName, workspaceName, integrationRuntimeName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, workspaceName, integrationRuntimeName, options }, startOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Start an integration runtime
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param integrationRuntimeName Integration runtime name
     * @param options The options parameters.
     */
    beginStartAndWait(resourceGroupName, workspaceName, integrationRuntimeName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStart(resourceGroupName, workspaceName, integrationRuntimeName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Stop an integration runtime
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param integrationRuntimeName Integration runtime name
     * @param options The options parameters.
     */
    beginStop(resourceGroupName, workspaceName, integrationRuntimeName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, workspaceName, integrationRuntimeName, options }, stopOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Stop an integration runtime
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param integrationRuntimeName Integration runtime name
     * @param options The options parameters.
     */
    beginStopAndWait(resourceGroupName, workspaceName, integrationRuntimeName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStop(resourceGroupName, workspaceName, integrationRuntimeName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the list of outbound network dependencies for a given Azure-SSIS integration runtime.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param integrationRuntimeName Integration runtime name
     * @param options The options parameters.
     */
    listOutboundNetworkDependenciesEndpoints(resourceGroupName, workspaceName, integrationRuntimeName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, integrationRuntimeName, options }, listOutboundNetworkDependenciesEndpointsOperationSpec);
    }
    /**
     * Enable interactive query in integration runtime
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param integrationRuntimeName Integration runtime name
     * @param options The options parameters.
     */
    beginEnableInteractiveQuery(resourceGroupName, workspaceName, integrationRuntimeName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, workspaceName, integrationRuntimeName, options }, enableInteractiveQueryOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Enable interactive query in integration runtime
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param integrationRuntimeName Integration runtime name
     * @param options The options parameters.
     */
    beginEnableInteractiveQueryAndWait(resourceGroupName, workspaceName, integrationRuntimeName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginEnableInteractiveQuery(resourceGroupName, workspaceName, integrationRuntimeName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Disable interactive query in integration runtime
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param integrationRuntimeName Integration runtime name
     * @param options The options parameters.
     */
    beginDisableInteractiveQuery(resourceGroupName, workspaceName, integrationRuntimeName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, workspaceName, integrationRuntimeName, options }, disableInteractiveQueryOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Disable interactive query in integration runtime
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param integrationRuntimeName Integration runtime name
     * @param options The options parameters.
     */
    beginDisableInteractiveQueryAndWait(resourceGroupName, workspaceName, integrationRuntimeName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDisableInteractiveQuery(resourceGroupName, workspaceName, integrationRuntimeName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListByWorkspaceNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param nextLink The nextLink from the previous successful call to the ListByWorkspace method.
     * @param options The options parameters.
     */
    _listByWorkspaceNext(resourceGroupName, workspaceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, nextLink, options }, listByWorkspaceNextOperationSpec$7);
    }
}
// Operation Specifications
const serializer$R = coreClient.createSerializer(Mappers, /* isXml */ false);
const updateOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/integrationRuntimes/{integrationRuntimeName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: IntegrationRuntimeResource
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: updateIntegrationRuntimeRequest,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        integrationRuntimeName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$R
};
const getOperationSpec$I = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/integrationRuntimes/{integrationRuntimeName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IntegrationRuntimeResource
        },
        304: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        integrationRuntimeName
    ],
    headerParameters: [accept, ifNoneMatch],
    serializer: serializer$R
};
const createOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/integrationRuntimes/{integrationRuntimeName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: IntegrationRuntimeResource
        },
        201: {
            bodyMapper: IntegrationRuntimeResource
        },
        202: {
            bodyMapper: IntegrationRuntimeResource
        },
        204: {
            bodyMapper: IntegrationRuntimeResource
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: integrationRuntime,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        integrationRuntimeName
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch
    ],
    mediaType: "json",
    serializer: serializer$R
};
const deleteOperationSpec$g = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/integrationRuntimes/{integrationRuntimeName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        integrationRuntimeName
    ],
    headerParameters: [accept],
    serializer: serializer$R
};
const upgradeOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/integrationRuntimes/{integrationRuntimeName}/upgrade",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        integrationRuntimeName
    ],
    headerParameters: [accept],
    serializer: serializer$R
};
const listByWorkspaceOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/integrationRuntimes",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IntegrationRuntimeListResponse
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$R
};
const startOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/integrationRuntimes/{integrationRuntimeName}/start",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: IntegrationRuntimeStatusResponse
        },
        201: {
            bodyMapper: IntegrationRuntimeStatusResponse
        },
        202: {
            bodyMapper: IntegrationRuntimeStatusResponse
        },
        204: {
            bodyMapper: IntegrationRuntimeStatusResponse
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        integrationRuntimeName
    ],
    headerParameters: [accept],
    serializer: serializer$R
};
const stopOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/integrationRuntimes/{integrationRuntimeName}/stop",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        integrationRuntimeName
    ],
    headerParameters: [accept],
    serializer: serializer$R
};
const listOutboundNetworkDependenciesEndpointsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/integrationRuntimes/{integrationRuntimeName}/outboundNetworkDependenciesEndpoints",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IntegrationRuntimeOutboundNetworkDependenciesEndpointsResponse
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        integrationRuntimeName
    ],
    headerParameters: [accept],
    serializer: serializer$R
};
const enableInteractiveQueryOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/integrationRuntimes/{integrationRuntimeName}/enableInteractiveQuery",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        integrationRuntimeName
    ],
    headerParameters: [accept],
    serializer: serializer$R
};
const disableInteractiveQueryOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/integrationRuntimes/{integrationRuntimeName}/disableInteractiveQuery",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        integrationRuntimeName
    ],
    headerParameters: [accept],
    serializer: serializer$R
};
const listByWorkspaceNextOperationSpec$7 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IntegrationRuntimeListResponse
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$R
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing IntegrationRuntimeNodeIpAddressOperations operations. */
class IntegrationRuntimeNodeIpAddressOperationsImpl {
    /**
     * Initialize a new instance of the class IntegrationRuntimeNodeIpAddressOperations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get the IP address of an integration runtime node
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param integrationRuntimeName Integration runtime name
     * @param nodeName Integration runtime node name
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, integrationRuntimeName, nodeName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workspaceName,
            integrationRuntimeName,
            nodeName,
            options
        }, getOperationSpec$J);
    }
}
// Operation Specifications
const serializer$S = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$J = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/integrationRuntimes/{integrationRuntimeName}/nodes/{nodeName}/ipAddress",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: IntegrationRuntimeNodeIpAddress
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        integrationRuntimeName,
        nodeName
    ],
    headerParameters: [accept],
    serializer: serializer$S
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing IntegrationRuntimeObjectMetadata operations. */
class IntegrationRuntimeObjectMetadataImpl {
    /**
     * Initialize a new instance of the class IntegrationRuntimeObjectMetadata class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get object metadata from an integration runtime
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param integrationRuntimeName Integration runtime name
     * @param options The options parameters.
     */
    list(resourceGroupName, workspaceName, integrationRuntimeName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, integrationRuntimeName, options }, listOperationSpec$p);
    }
    /**
     * Refresh the object metadata in an integration runtime
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param integrationRuntimeName Integration runtime name
     * @param options The options parameters.
     */
    beginRefresh(resourceGroupName, workspaceName, integrationRuntimeName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, workspaceName, integrationRuntimeName, options }, refreshOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Refresh the object metadata in an integration runtime
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param integrationRuntimeName Integration runtime name
     * @param options The options parameters.
     */
    beginRefreshAndWait(resourceGroupName, workspaceName, integrationRuntimeName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRefresh(resourceGroupName, workspaceName, integrationRuntimeName, options);
            return poller.pollUntilDone();
        });
    }
}
// Operation Specifications
const serializer$T = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$p = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/integrationRuntimes/{integrationRuntimeName}/getObjectMetadata",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: SsisObjectMetadataListResponse
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: getMetadataRequest,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        integrationRuntimeName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$T
};
const refreshOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/integrationRuntimes/{integrationRuntimeName}/refreshObjectMetadata",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: SsisObjectMetadataStatusResponse
        },
        201: {
            bodyMapper: SsisObjectMetadataStatusResponse
        },
        202: {
            bodyMapper: SsisObjectMetadataStatusResponse
        },
        204: {
            bodyMapper: SsisObjectMetadataStatusResponse
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        integrationRuntimeName
    ],
    headerParameters: [accept],
    serializer: serializer$T
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing IntegrationRuntimeNodes operations. */
class IntegrationRuntimeNodesImpl {
    /**
     * Initialize a new instance of the class IntegrationRuntimeNodes class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get an integration runtime node
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param integrationRuntimeName Integration runtime name
     * @param nodeName Integration runtime node name
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, integrationRuntimeName, nodeName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workspaceName,
            integrationRuntimeName,
            nodeName,
            options
        }, getOperationSpec$K);
    }
    /**
     * Create an integration runtime node
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param integrationRuntimeName Integration runtime name
     * @param nodeName Integration runtime node name
     * @param updateIntegrationRuntimeNodeRequest The parameters for updating an integration runtime node.
     * @param options The options parameters.
     */
    update(resourceGroupName, workspaceName, integrationRuntimeName, nodeName, updateIntegrationRuntimeNodeRequest, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workspaceName,
            integrationRuntimeName,
            nodeName,
            updateIntegrationRuntimeNodeRequest,
            options
        }, updateOperationSpec$7);
    }
    /**
     * Delete an integration runtime node
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param integrationRuntimeName Integration runtime name
     * @param nodeName Integration runtime node name
     * @param options The options parameters.
     */
    delete(resourceGroupName, workspaceName, integrationRuntimeName, nodeName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workspaceName,
            integrationRuntimeName,
            nodeName,
            options
        }, deleteOperationSpec$h);
    }
}
// Operation Specifications
const serializer$U = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$K = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/integrationRuntimes/{integrationRuntimeName}/nodes/{nodeName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SelfHostedIntegrationRuntimeNode
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        integrationRuntimeName,
        nodeName
    ],
    headerParameters: [accept],
    serializer: serializer$U
};
const updateOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/integrationRuntimes/{integrationRuntimeName}/nodes/{nodeName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: SelfHostedIntegrationRuntimeNode
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: updateIntegrationRuntimeNodeRequest,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        integrationRuntimeName,
        nodeName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$U
};
const deleteOperationSpec$h = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/integrationRuntimes/{integrationRuntimeName}/nodes/{nodeName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        integrationRuntimeName,
        nodeName
    ],
    headerParameters: [accept],
    serializer: serializer$U
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing IntegrationRuntimeCredentials operations. */
class IntegrationRuntimeCredentialsImpl {
    /**
     * Initialize a new instance of the class IntegrationRuntimeCredentials class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Force the integration runtime to synchronize credentials across integration runtime nodes, and this
     * will override the credentials across all worker nodes with those available on the dispatcher node.
     * If you already have the latest credential backup file, you should manually import it (preferred) on
     * any self-hosted integration runtime node than using this API directly.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param integrationRuntimeName Integration runtime name
     * @param options The options parameters.
     */
    sync(resourceGroupName, workspaceName, integrationRuntimeName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, integrationRuntimeName, options }, syncOperationSpec);
    }
}
// Operation Specifications
const serializer$V = coreClient.createSerializer(Mappers, /* isXml */ false);
const syncOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/integrationRuntimes/{integrationRuntimeName}/syncCredentials",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        integrationRuntimeName
    ],
    headerParameters: [accept],
    serializer: serializer$V
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing IntegrationRuntimeConnectionInfos operations. */
class IntegrationRuntimeConnectionInfosImpl {
    /**
     * Initialize a new instance of the class IntegrationRuntimeConnectionInfos class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get connection info for an integration runtime
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param integrationRuntimeName Integration runtime name
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, integrationRuntimeName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, integrationRuntimeName, options }, getOperationSpec$L);
    }
}
// Operation Specifications
const serializer$W = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$L = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/integrationRuntimes/{integrationRuntimeName}/getConnectionInfo",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: IntegrationRuntimeConnectionInfo
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        integrationRuntimeName
    ],
    headerParameters: [accept],
    serializer: serializer$W
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing IntegrationRuntimeAuthKeysOperations operations. */
class IntegrationRuntimeAuthKeysOperationsImpl {
    /**
     * Initialize a new instance of the class IntegrationRuntimeAuthKeysOperations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Regenerate the authentication key for an integration runtime
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param integrationRuntimeName Integration runtime name
     * @param regenerateKeyParameters The parameters for regenerating integration runtime authentication
     *                                key.
     * @param options The options parameters.
     */
    regenerate(resourceGroupName, workspaceName, integrationRuntimeName, regenerateKeyParameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workspaceName,
            integrationRuntimeName,
            regenerateKeyParameters,
            options
        }, regenerateOperationSpec);
    }
    /**
     * List authentication keys in an integration runtime
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param integrationRuntimeName Integration runtime name
     * @param options The options parameters.
     */
    list(resourceGroupName, workspaceName, integrationRuntimeName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, integrationRuntimeName, options }, listOperationSpec$q);
    }
}
// Operation Specifications
const serializer$X = coreClient.createSerializer(Mappers, /* isXml */ false);
const regenerateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/integrationRuntimes/{integrationRuntimeName}/regenerateAuthKey",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: IntegrationRuntimeAuthKeys
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: regenerateKeyParameters,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        integrationRuntimeName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$X
};
const listOperationSpec$q = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/integrationRuntimes/{integrationRuntimeName}/listAuthKeys",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: IntegrationRuntimeAuthKeys
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        integrationRuntimeName
    ],
    headerParameters: [accept],
    serializer: serializer$X
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing IntegrationRuntimeMonitoringDataOperations operations. */
class IntegrationRuntimeMonitoringDataOperationsImpl {
    /**
     * Initialize a new instance of the class IntegrationRuntimeMonitoringDataOperations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get monitoring data for an integration runtime
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param integrationRuntimeName Integration runtime name
     * @param options The options parameters.
     */
    list(resourceGroupName, workspaceName, integrationRuntimeName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, integrationRuntimeName, options }, listOperationSpec$r);
    }
}
// Operation Specifications
const serializer$Y = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$r = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/integrationRuntimes/{integrationRuntimeName}/monitoringData",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: IntegrationRuntimeMonitoringData
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        integrationRuntimeName
    ],
    headerParameters: [accept],
    serializer: serializer$Y
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing IntegrationRuntimeStatusOperations operations. */
class IntegrationRuntimeStatusOperationsImpl {
    /**
     * Initialize a new instance of the class IntegrationRuntimeStatusOperations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get the integration runtime status
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param integrationRuntimeName Integration runtime name
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, integrationRuntimeName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, integrationRuntimeName, options }, getOperationSpec$M);
    }
}
// Operation Specifications
const serializer$Z = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$M = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/integrationRuntimes/{integrationRuntimeName}/getStatus",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: IntegrationRuntimeStatusResponse
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        integrationRuntimeName
    ],
    headerParameters: [accept],
    serializer: serializer$Z
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing SparkConfiguration operations. */
class SparkConfigurationImpl {
    /**
     * Initialize a new instance of the class SparkConfiguration class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get SparkConfiguration by name in a workspace.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param sparkConfigurationName SparkConfiguration name
     * @param workspaceName The name of the workspace.
     * @param options The options parameters.
     */
    get(resourceGroupName, sparkConfigurationName, workspaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, sparkConfigurationName, workspaceName, options }, getOperationSpec$N);
    }
}
// Operation Specifications
const serializer$_ = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$N = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sparkconfigurations/{sparkConfigurationName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SparkConfigurationResource
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        sparkConfigurationName
    ],
    headerParameters: [accept],
    serializer: serializer$_
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing SparkConfigurations operations. */
class SparkConfigurationsImpl {
    /**
     * Initialize a new instance of the class SparkConfigurations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List sparkConfigurations in a workspace.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param options The options parameters.
     */
    listByWorkspace(resourceGroupName, workspaceName, options) {
        const iter = this.listByWorkspacePagingAll(resourceGroupName, workspaceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByWorkspacePagingPage(resourceGroupName, workspaceName, options);
            }
        };
    }
    listByWorkspacePagingPage(resourceGroupName, workspaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByWorkspacePagingPage_1() {
            let result = yield tslib.__await(this._listByWorkspace(resourceGroupName, workspaceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByWorkspaceNext(resourceGroupName, workspaceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByWorkspacePagingAll(resourceGroupName, workspaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByWorkspacePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByWorkspacePagingPage(resourceGroupName, workspaceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List sparkConfigurations in a workspace.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param options The options parameters.
     */
    _listByWorkspace(resourceGroupName, workspaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, options }, listByWorkspaceOperationSpec$9);
    }
    /**
     * ListByWorkspaceNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param nextLink The nextLink from the previous successful call to the ListByWorkspace method.
     * @param options The options parameters.
     */
    _listByWorkspaceNext(resourceGroupName, workspaceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, nextLink, options }, listByWorkspaceNextOperationSpec$8);
    }
}
// Operation Specifications
const serializer$$ = coreClient.createSerializer(Mappers, /* isXml */ false);
const listByWorkspaceOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/sparkconfigurations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SparkConfigurationListResponse
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$$
};
const listByWorkspaceNextOperationSpec$8 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SparkConfigurationListResponse
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$$
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing KustoOperations operations. */
class KustoOperationsImpl {
    /**
     * Initialize a new instance of the class KustoOperations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists available operations for the Kusto sub-resources inside Microsoft.Synapse provider.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists available operations for the Kusto sub-resources inside Microsoft.Synapse provider.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$s);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$n);
    }
}
// Operation Specifications
const serializer$10 = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$s = {
    path: "/providers/Microsoft.Synapse/kustooperations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer: serializer$10
};
const listNextOperationSpec$n = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [$host, nextLink],
    headerParameters: [accept],
    serializer: serializer$10
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing KustoPools operations. */
class KustoPoolsImpl {
    /**
     * Initialize a new instance of the class KustoPools class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists eligible SKUs for Kusto Pool resource.
     * @param options The options parameters.
     */
    listSkus(options) {
        const iter = this.listSkusPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listSkusPagingPage(options);
            }
        };
    }
    listSkusPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listSkusPagingPage_1() {
            let result = yield tslib.__await(this._listSkus(options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listSkusPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listSkusPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listSkusPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Returns the SKUs available for the provided resource.
     * @param workspaceName The name of the workspace.
     * @param kustoPoolName The name of the Kusto pool.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    listSkusByResource(workspaceName, kustoPoolName, resourceGroupName, options) {
        const iter = this.listSkusByResourcePagingAll(workspaceName, kustoPoolName, resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listSkusByResourcePagingPage(workspaceName, kustoPoolName, resourceGroupName, options);
            }
        };
    }
    listSkusByResourcePagingPage(workspaceName, kustoPoolName, resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSkusByResourcePagingPage_1() {
            let result = yield tslib.__await(this._listSkusByResource(workspaceName, kustoPoolName, resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listSkusByResourcePagingAll(workspaceName, kustoPoolName, resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSkusByResourcePagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listSkusByResourcePagingPage(workspaceName, kustoPoolName, resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Returns a list of language extensions that can run within KQL queries.
     * @param workspaceName The name of the workspace.
     * @param kustoPoolName The name of the Kusto pool.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    listLanguageExtensions(workspaceName, kustoPoolName, resourceGroupName, options) {
        const iter = this.listLanguageExtensionsPagingAll(workspaceName, kustoPoolName, resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listLanguageExtensionsPagingPage(workspaceName, kustoPoolName, resourceGroupName, options);
            }
        };
    }
    listLanguageExtensionsPagingPage(workspaceName, kustoPoolName, resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listLanguageExtensionsPagingPage_1() {
            let result = yield tslib.__await(this._listLanguageExtensions(workspaceName, kustoPoolName, resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listLanguageExtensionsPagingAll(workspaceName, kustoPoolName, resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listLanguageExtensionsPagingAll_1() {
            var e_3, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listLanguageExtensionsPagingPage(workspaceName, kustoPoolName, resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Returns a list of databases that are owned by this Kusto Pool and were followed by another Kusto
     * Pool.
     * @param workspaceName The name of the workspace.
     * @param kustoPoolName The name of the Kusto pool.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    listFollowerDatabases(workspaceName, kustoPoolName, resourceGroupName, options) {
        const iter = this.listFollowerDatabasesPagingAll(workspaceName, kustoPoolName, resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listFollowerDatabasesPagingPage(workspaceName, kustoPoolName, resourceGroupName, options);
            }
        };
    }
    listFollowerDatabasesPagingPage(workspaceName, kustoPoolName, resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listFollowerDatabasesPagingPage_1() {
            let result = yield tslib.__await(this._listFollowerDatabases(workspaceName, kustoPoolName, resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listFollowerDatabasesPagingAll(workspaceName, kustoPoolName, resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listFollowerDatabasesPagingAll_1() {
            var e_4, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listFollowerDatabasesPagingPage(workspaceName, kustoPoolName, resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * Lists eligible SKUs for Kusto Pool resource.
     * @param options The options parameters.
     */
    _listSkus(options) {
        return this.client.sendOperationRequest({ options }, listSkusOperationSpec);
    }
    /**
     * Checks that the kusto pool name is valid and is not already in use.
     * @param location The name of Azure region.
     * @param kustoPoolName The name of the cluster.
     * @param options The options parameters.
     */
    checkNameAvailability(location, kustoPoolName, options) {
        return this.client.sendOperationRequest({ location, kustoPoolName, options }, checkNameAvailabilityOperationSpec$1);
    }
    /**
     * List all Kusto pools
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param options The options parameters.
     */
    listByWorkspace(resourceGroupName, workspaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, options }, listByWorkspaceOperationSpec$a);
    }
    /**
     * Gets a Kusto pool.
     * @param workspaceName The name of the workspace.
     * @param kustoPoolName The name of the Kusto pool.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    get(workspaceName, kustoPoolName, resourceGroupName, options) {
        return this.client.sendOperationRequest({ workspaceName, kustoPoolName, resourceGroupName, options }, getOperationSpec$O);
    }
    /**
     * Create or update a Kusto pool.
     * @param workspaceName The name of the workspace.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param kustoPoolName The name of the Kusto pool.
     * @param parameters The Kusto pool parameters supplied to the CreateOrUpdate operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(workspaceName, resourceGroupName, kustoPoolName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { workspaceName, resourceGroupName, kustoPoolName, parameters, options }, createOrUpdateOperationSpec$q);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Create or update a Kusto pool.
     * @param workspaceName The name of the workspace.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param kustoPoolName The name of the Kusto pool.
     * @param parameters The Kusto pool parameters supplied to the CreateOrUpdate operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(workspaceName, resourceGroupName, kustoPoolName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(workspaceName, resourceGroupName, kustoPoolName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Update a Kusto Kusto Pool.
     * @param workspaceName The name of the workspace.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param kustoPoolName The name of the Kusto pool.
     * @param parameters The Kusto pool parameters supplied to the Update operation.
     * @param options The options parameters.
     */
    beginUpdate(workspaceName, resourceGroupName, kustoPoolName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { workspaceName, resourceGroupName, kustoPoolName, parameters, options }, updateOperationSpec$8);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Update a Kusto Kusto Pool.
     * @param workspaceName The name of the workspace.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param kustoPoolName The name of the Kusto pool.
     * @param parameters The Kusto pool parameters supplied to the Update operation.
     * @param options The options parameters.
     */
    beginUpdateAndWait(workspaceName, resourceGroupName, kustoPoolName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(workspaceName, resourceGroupName, kustoPoolName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes a Kusto pool.
     * @param workspaceName The name of the workspace.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param kustoPoolName The name of the Kusto pool.
     * @param options The options parameters.
     */
    beginDelete(workspaceName, resourceGroupName, kustoPoolName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { workspaceName, resourceGroupName, kustoPoolName, options }, deleteOperationSpec$i);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Deletes a Kusto pool.
     * @param workspaceName The name of the workspace.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param kustoPoolName The name of the Kusto pool.
     * @param options The options parameters.
     */
    beginDeleteAndWait(workspaceName, resourceGroupName, kustoPoolName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(workspaceName, resourceGroupName, kustoPoolName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Stops a Kusto pool.
     * @param workspaceName The name of the workspace.
     * @param kustoPoolName The name of the Kusto pool.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    beginStop(workspaceName, kustoPoolName, resourceGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { workspaceName, kustoPoolName, resourceGroupName, options }, stopOperationSpec$1);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Stops a Kusto pool.
     * @param workspaceName The name of the workspace.
     * @param kustoPoolName The name of the Kusto pool.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    beginStopAndWait(workspaceName, kustoPoolName, resourceGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStop(workspaceName, kustoPoolName, resourceGroupName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Starts a Kusto pool.
     * @param workspaceName The name of the workspace.
     * @param kustoPoolName The name of the Kusto pool.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    beginStart(workspaceName, kustoPoolName, resourceGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { workspaceName, kustoPoolName, resourceGroupName, options }, startOperationSpec$1);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Starts a Kusto pool.
     * @param workspaceName The name of the workspace.
     * @param kustoPoolName The name of the Kusto pool.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    beginStartAndWait(workspaceName, kustoPoolName, resourceGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStart(workspaceName, kustoPoolName, resourceGroupName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Returns the SKUs available for the provided resource.
     * @param workspaceName The name of the workspace.
     * @param kustoPoolName The name of the Kusto pool.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    _listSkusByResource(workspaceName, kustoPoolName, resourceGroupName, options) {
        return this.client.sendOperationRequest({ workspaceName, kustoPoolName, resourceGroupName, options }, listSkusByResourceOperationSpec);
    }
    /**
     * Returns a list of language extensions that can run within KQL queries.
     * @param workspaceName The name of the workspace.
     * @param kustoPoolName The name of the Kusto pool.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    _listLanguageExtensions(workspaceName, kustoPoolName, resourceGroupName, options) {
        return this.client.sendOperationRequest({ workspaceName, kustoPoolName, resourceGroupName, options }, listLanguageExtensionsOperationSpec);
    }
    /**
     * Add a list of language extensions that can run within KQL queries.
     * @param workspaceName The name of the workspace.
     * @param kustoPoolName The name of the Kusto pool.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param languageExtensionsToAdd The language extensions to add.
     * @param options The options parameters.
     */
    beginAddLanguageExtensions(workspaceName, kustoPoolName, resourceGroupName, languageExtensionsToAdd, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                workspaceName,
                kustoPoolName,
                resourceGroupName,
                languageExtensionsToAdd,
                options
            }, addLanguageExtensionsOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Add a list of language extensions that can run within KQL queries.
     * @param workspaceName The name of the workspace.
     * @param kustoPoolName The name of the Kusto pool.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param languageExtensionsToAdd The language extensions to add.
     * @param options The options parameters.
     */
    beginAddLanguageExtensionsAndWait(workspaceName, kustoPoolName, resourceGroupName, languageExtensionsToAdd, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginAddLanguageExtensions(workspaceName, kustoPoolName, resourceGroupName, languageExtensionsToAdd, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Remove a list of language extensions that can run within KQL queries.
     * @param workspaceName The name of the workspace.
     * @param kustoPoolName The name of the Kusto pool.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param languageExtensionsToRemove The language extensions to remove.
     * @param options The options parameters.
     */
    beginRemoveLanguageExtensions(workspaceName, kustoPoolName, resourceGroupName, languageExtensionsToRemove, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                workspaceName,
                kustoPoolName,
                resourceGroupName,
                languageExtensionsToRemove,
                options
            }, removeLanguageExtensionsOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Remove a list of language extensions that can run within KQL queries.
     * @param workspaceName The name of the workspace.
     * @param kustoPoolName The name of the Kusto pool.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param languageExtensionsToRemove The language extensions to remove.
     * @param options The options parameters.
     */
    beginRemoveLanguageExtensionsAndWait(workspaceName, kustoPoolName, resourceGroupName, languageExtensionsToRemove, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRemoveLanguageExtensions(workspaceName, kustoPoolName, resourceGroupName, languageExtensionsToRemove, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Returns a list of databases that are owned by this Kusto Pool and were followed by another Kusto
     * Pool.
     * @param workspaceName The name of the workspace.
     * @param kustoPoolName The name of the Kusto pool.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    _listFollowerDatabases(workspaceName, kustoPoolName, resourceGroupName, options) {
        return this.client.sendOperationRequest({ workspaceName, kustoPoolName, resourceGroupName, options }, listFollowerDatabasesOperationSpec);
    }
    /**
     * Detaches all followers of a database owned by this Kusto Pool.
     * @param workspaceName The name of the workspace.
     * @param kustoPoolName The name of the Kusto pool.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param followerDatabaseToRemove The follower databases properties to remove.
     * @param options The options parameters.
     */
    beginDetachFollowerDatabases(workspaceName, kustoPoolName, resourceGroupName, followerDatabaseToRemove, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                workspaceName,
                kustoPoolName,
                resourceGroupName,
                followerDatabaseToRemove,
                options
            }, detachFollowerDatabasesOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Detaches all followers of a database owned by this Kusto Pool.
     * @param workspaceName The name of the workspace.
     * @param kustoPoolName The name of the Kusto pool.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param followerDatabaseToRemove The follower databases properties to remove.
     * @param options The options parameters.
     */
    beginDetachFollowerDatabasesAndWait(workspaceName, kustoPoolName, resourceGroupName, followerDatabaseToRemove, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDetachFollowerDatabases(workspaceName, kustoPoolName, resourceGroupName, followerDatabaseToRemove, options);
            return poller.pollUntilDone();
        });
    }
}
// Operation Specifications
const serializer$11 = coreClient.createSerializer(Mappers, /* isXml */ false);
const listSkusOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Synapse/skus",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SkuDescriptionList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$11
};
const checkNameAvailabilityOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Synapse/locations/{location}/kustoPoolCheckNameAvailability",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: CheckNameResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: kustoPoolName,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        location
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$11
};
const listByWorkspaceOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/kustoPools",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: KustoPoolListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$11
};
const getOperationSpec$O = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/kustoPools/{kustoPoolName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: KustoPool
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        kustoPoolName1
    ],
    headerParameters: [accept],
    serializer: serializer$11
};
const createOrUpdateOperationSpec$q = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/kustoPools/{kustoPoolName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: KustoPool
        },
        201: {
            bodyMapper: KustoPool
        },
        202: {
            bodyMapper: KustoPool
        },
        204: {
            bodyMapper: KustoPool
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters22,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        kustoPoolName1
    ],
    headerParameters: [
        accept,
        contentType,
        ifNoneMatch,
        ifMatch
    ],
    mediaType: "json",
    serializer: serializer$11
};
const updateOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/kustoPools/{kustoPoolName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: KustoPool
        },
        201: {
            bodyMapper: KustoPool
        },
        202: {
            bodyMapper: KustoPool
        },
        204: {
            bodyMapper: KustoPool
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters23,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        kustoPoolName1
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch
    ],
    mediaType: "json",
    serializer: serializer$11
};
const deleteOperationSpec$i = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/kustoPools/{kustoPoolName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        kustoPoolName1
    ],
    headerParameters: [accept],
    serializer: serializer$11
};
const stopOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/kustoPools/{kustoPoolName}/stop",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        kustoPoolName1
    ],
    headerParameters: [accept],
    serializer: serializer$11
};
const startOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/kustoPools/{kustoPoolName}/start",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        kustoPoolName1
    ],
    headerParameters: [accept],
    serializer: serializer$11
};
const listSkusByResourceOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/kustoPools/{kustoPoolName}/skus",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListResourceSkusResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        kustoPoolName1
    ],
    headerParameters: [accept],
    serializer: serializer$11
};
const listLanguageExtensionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/kustoPools/{kustoPoolName}/listLanguageExtensions",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: LanguageExtensionsList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        kustoPoolName1
    ],
    headerParameters: [accept],
    serializer: serializer$11
};
const addLanguageExtensionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/kustoPools/{kustoPoolName}/addLanguageExtensions",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: languageExtensionsToAdd,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        kustoPoolName1
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$11
};
const removeLanguageExtensionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/kustoPools/{kustoPoolName}/removeLanguageExtensions",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: languageExtensionsToRemove,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        kustoPoolName1
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$11
};
const listFollowerDatabasesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/kustoPools/{kustoPoolName}/listFollowerDatabases",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: FollowerDatabaseListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        kustoPoolName1
    ],
    headerParameters: [accept],
    serializer: serializer$11
};
const detachFollowerDatabasesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/kustoPools/{kustoPoolName}/detachFollowerDatabases",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: followerDatabaseToRemove,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        kustoPoolName1
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$11
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing KustoPoolChildResource operations. */
class KustoPoolChildResourceImpl {
    /**
     * Initialize a new instance of the class KustoPoolChildResource class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Checks that the Kusto Pool child resource name is valid and is not already in use.
     * @param workspaceName The name of the workspace.
     * @param kustoPoolName The name of the Kusto pool.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the Kusto Pool child resource.
     * @param options The options parameters.
     */
    checkNameAvailability(workspaceName, kustoPoolName, resourceGroupName, resourceName, options) {
        return this.client.sendOperationRequest({
            workspaceName,
            kustoPoolName,
            resourceGroupName,
            resourceName,
            options
        }, checkNameAvailabilityOperationSpec$2);
    }
}
// Operation Specifications
const serializer$12 = coreClient.createSerializer(Mappers, /* isXml */ false);
const checkNameAvailabilityOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/kustoPools/{kustoPoolName}/checkNameAvailability",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: CheckNameResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: resourceName,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        kustoPoolName1
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$12
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing KustoPoolAttachedDatabaseConfigurations operations. */
class KustoPoolAttachedDatabaseConfigurationsImpl {
    /**
     * Initialize a new instance of the class KustoPoolAttachedDatabaseConfigurations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Returns the list of attached database configurations of the given Kusto Pool.
     * @param workspaceName The name of the workspace.
     * @param kustoPoolName The name of the Kusto pool.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    listByKustoPool(workspaceName, kustoPoolName, resourceGroupName, options) {
        const iter = this.listByKustoPoolPagingAll(workspaceName, kustoPoolName, resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByKustoPoolPagingPage(workspaceName, kustoPoolName, resourceGroupName, options);
            }
        };
    }
    listByKustoPoolPagingPage(workspaceName, kustoPoolName, resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByKustoPoolPagingPage_1() {
            let result = yield tslib.__await(this._listByKustoPool(workspaceName, kustoPoolName, resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listByKustoPoolPagingAll(workspaceName, kustoPoolName, resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByKustoPoolPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByKustoPoolPagingPage(workspaceName, kustoPoolName, resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Returns the list of attached database configurations of the given Kusto Pool.
     * @param workspaceName The name of the workspace.
     * @param kustoPoolName The name of the Kusto pool.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    _listByKustoPool(workspaceName, kustoPoolName, resourceGroupName, options) {
        return this.client.sendOperationRequest({ workspaceName, kustoPoolName, resourceGroupName, options }, listByKustoPoolOperationSpec);
    }
    /**
     * Returns an attached database configuration.
     * @param workspaceName The name of the workspace.
     * @param kustoPoolName The name of the Kusto pool.
     * @param attachedDatabaseConfigurationName The name of the attached database configuration.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    get(workspaceName, kustoPoolName, attachedDatabaseConfigurationName, resourceGroupName, options) {
        return this.client.sendOperationRequest({
            workspaceName,
            kustoPoolName,
            attachedDatabaseConfigurationName,
            resourceGroupName,
            options
        }, getOperationSpec$P);
    }
    /**
     * Creates or updates an attached database configuration.
     * @param workspaceName The name of the workspace.
     * @param kustoPoolName The name of the Kusto pool.
     * @param attachedDatabaseConfigurationName The name of the attached database configuration.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param parameters The database parameters supplied to the CreateOrUpdate operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(workspaceName, kustoPoolName, attachedDatabaseConfigurationName, resourceGroupName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                workspaceName,
                kustoPoolName,
                attachedDatabaseConfigurationName,
                resourceGroupName,
                parameters,
                options
            }, createOrUpdateOperationSpec$r);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Creates or updates an attached database configuration.
     * @param workspaceName The name of the workspace.
     * @param kustoPoolName The name of the Kusto pool.
     * @param attachedDatabaseConfigurationName The name of the attached database configuration.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param parameters The database parameters supplied to the CreateOrUpdate operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(workspaceName, kustoPoolName, attachedDatabaseConfigurationName, resourceGroupName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(workspaceName, kustoPoolName, attachedDatabaseConfigurationName, resourceGroupName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes the attached database configuration with the given name.
     * @param workspaceName The name of the workspace.
     * @param kustoPoolName The name of the Kusto pool.
     * @param attachedDatabaseConfigurationName The name of the attached database configuration.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    beginDelete(workspaceName, kustoPoolName, attachedDatabaseConfigurationName, resourceGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                workspaceName,
                kustoPoolName,
                attachedDatabaseConfigurationName,
                resourceGroupName,
                options
            }, deleteOperationSpec$j);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Deletes the attached database configuration with the given name.
     * @param workspaceName The name of the workspace.
     * @param kustoPoolName The name of the Kusto pool.
     * @param attachedDatabaseConfigurationName The name of the attached database configuration.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    beginDeleteAndWait(workspaceName, kustoPoolName, attachedDatabaseConfigurationName, resourceGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(workspaceName, kustoPoolName, attachedDatabaseConfigurationName, resourceGroupName, options);
            return poller.pollUntilDone();
        });
    }
}
// Operation Specifications
const serializer$13 = coreClient.createSerializer(Mappers, /* isXml */ false);
const listByKustoPoolOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/kustoPools/{kustoPoolName}/attachedDatabaseConfigurations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AttachedDatabaseConfigurationListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        kustoPoolName1
    ],
    headerParameters: [accept],
    serializer: serializer$13
};
const getOperationSpec$P = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/kustoPools/{kustoPoolName}/attachedDatabaseConfigurations/{attachedDatabaseConfigurationName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AttachedDatabaseConfiguration
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        kustoPoolName1,
        attachedDatabaseConfigurationName
    ],
    headerParameters: [accept],
    serializer: serializer$13
};
const createOrUpdateOperationSpec$r = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/kustoPools/{kustoPoolName}/attachedDatabaseConfigurations/{attachedDatabaseConfigurationName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: AttachedDatabaseConfiguration
        },
        201: {
            bodyMapper: AttachedDatabaseConfiguration
        },
        202: {
            bodyMapper: AttachedDatabaseConfiguration
        },
        204: {
            bodyMapper: AttachedDatabaseConfiguration
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters24,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        kustoPoolName1,
        attachedDatabaseConfigurationName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$13
};
const deleteOperationSpec$j = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/kustoPools/{kustoPoolName}/attachedDatabaseConfigurations/{attachedDatabaseConfigurationName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        kustoPoolName1,
        attachedDatabaseConfigurationName
    ],
    headerParameters: [accept],
    serializer: serializer$13
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing KustoPoolDatabases operations. */
class KustoPoolDatabasesImpl {
    /**
     * Initialize a new instance of the class KustoPoolDatabases class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Returns the list of databases of the given Kusto pool.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param kustoPoolName The name of the Kusto pool.
     * @param options The options parameters.
     */
    listByKustoPool(resourceGroupName, workspaceName, kustoPoolName, options) {
        const iter = this.listByKustoPoolPagingAll(resourceGroupName, workspaceName, kustoPoolName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByKustoPoolPagingPage(resourceGroupName, workspaceName, kustoPoolName, options);
            }
        };
    }
    listByKustoPoolPagingPage(resourceGroupName, workspaceName, kustoPoolName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByKustoPoolPagingPage_1() {
            let result = yield tslib.__await(this._listByKustoPool(resourceGroupName, workspaceName, kustoPoolName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listByKustoPoolPagingAll(resourceGroupName, workspaceName, kustoPoolName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByKustoPoolPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByKustoPoolPagingPage(resourceGroupName, workspaceName, kustoPoolName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Returns the list of databases of the given Kusto pool.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param kustoPoolName The name of the Kusto pool.
     * @param options The options parameters.
     */
    _listByKustoPool(resourceGroupName, workspaceName, kustoPoolName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, kustoPoolName, options }, listByKustoPoolOperationSpec$1);
    }
    /**
     * Returns a database.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param kustoPoolName The name of the Kusto pool.
     * @param databaseName The name of the database in the Kusto pool.
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, kustoPoolName, databaseName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workspaceName,
            kustoPoolName,
            databaseName,
            options
        }, getOperationSpec$Q);
    }
    /**
     * Creates or updates a database.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param kustoPoolName The name of the Kusto pool.
     * @param databaseName The name of the database in the Kusto pool.
     * @param parameters The database parameters supplied to the CreateOrUpdate operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, workspaceName, kustoPoolName, databaseName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                workspaceName,
                kustoPoolName,
                databaseName,
                parameters,
                options
            }, createOrUpdateOperationSpec$s);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Creates or updates a database.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param kustoPoolName The name of the Kusto pool.
     * @param databaseName The name of the database in the Kusto pool.
     * @param parameters The database parameters supplied to the CreateOrUpdate operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, workspaceName, kustoPoolName, databaseName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, workspaceName, kustoPoolName, databaseName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates a database.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param kustoPoolName The name of the Kusto pool.
     * @param databaseName The name of the database in the Kusto pool.
     * @param parameters The database parameters supplied to the Update operation.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, workspaceName, kustoPoolName, databaseName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                workspaceName,
                kustoPoolName,
                databaseName,
                parameters,
                options
            }, updateOperationSpec$9);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Updates a database.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param kustoPoolName The name of the Kusto pool.
     * @param databaseName The name of the database in the Kusto pool.
     * @param parameters The database parameters supplied to the Update operation.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, workspaceName, kustoPoolName, databaseName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, workspaceName, kustoPoolName, databaseName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes the database with the given name.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param kustoPoolName The name of the Kusto pool.
     * @param databaseName The name of the database in the Kusto pool.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, workspaceName, kustoPoolName, databaseName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                workspaceName,
                kustoPoolName,
                databaseName,
                options
            }, deleteOperationSpec$k);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Deletes the database with the given name.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param kustoPoolName The name of the Kusto pool.
     * @param databaseName The name of the database in the Kusto pool.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, workspaceName, kustoPoolName, databaseName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, workspaceName, kustoPoolName, databaseName, options);
            return poller.pollUntilDone();
        });
    }
}
// Operation Specifications
const serializer$14 = coreClient.createSerializer(Mappers, /* isXml */ false);
const listByKustoPoolOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/kustoPools/{kustoPoolName}/databases",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DatabaseListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        kustoPoolName1
    ],
    headerParameters: [accept],
    serializer: serializer$14
};
const getOperationSpec$Q = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/kustoPools/{kustoPoolName}/databases/{databaseName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Database
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        kustoPoolName1,
        databaseName
    ],
    headerParameters: [accept],
    serializer: serializer$14
};
const createOrUpdateOperationSpec$s = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/kustoPools/{kustoPoolName}/databases/{databaseName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Database
        },
        201: {
            bodyMapper: Database
        },
        202: {
            bodyMapper: Database
        },
        204: {
            bodyMapper: Database
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters25,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        kustoPoolName1,
        databaseName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$14
};
const updateOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/kustoPools/{kustoPoolName}/databases/{databaseName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Database
        },
        201: {
            bodyMapper: Database
        },
        202: {
            bodyMapper: Database
        },
        204: {
            bodyMapper: Database
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters25,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        kustoPoolName1,
        databaseName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$14
};
const deleteOperationSpec$k = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/kustoPools/{kustoPoolName}/databases/{databaseName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        kustoPoolName1,
        databaseName
    ],
    headerParameters: [accept],
    serializer: serializer$14
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing KustoPoolDataConnections operations. */
class KustoPoolDataConnectionsImpl {
    /**
     * Initialize a new instance of the class KustoPoolDataConnections class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Returns the list of data connections of the given Kusto pool database.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param kustoPoolName The name of the Kusto pool.
     * @param databaseName The name of the database in the Kusto pool.
     * @param options The options parameters.
     */
    listByDatabase(resourceGroupName, workspaceName, kustoPoolName, databaseName, options) {
        const iter = this.listByDatabasePagingAll(resourceGroupName, workspaceName, kustoPoolName, databaseName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByDatabasePagingPage(resourceGroupName, workspaceName, kustoPoolName, databaseName, options);
            }
        };
    }
    listByDatabasePagingPage(resourceGroupName, workspaceName, kustoPoolName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabasePagingPage_1() {
            let result = yield tslib.__await(this._listByDatabase(resourceGroupName, workspaceName, kustoPoolName, databaseName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listByDatabasePagingAll(resourceGroupName, workspaceName, kustoPoolName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabasePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByDatabasePagingPage(resourceGroupName, workspaceName, kustoPoolName, databaseName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Checks that the data connection name is valid and is not already in use.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param kustoPoolName The name of the Kusto pool.
     * @param databaseName The name of the database in the Kusto pool.
     * @param dataConnectionName The name of the data connection.
     * @param options The options parameters.
     */
    checkNameAvailability(resourceGroupName, workspaceName, kustoPoolName, databaseName, dataConnectionName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workspaceName,
            kustoPoolName,
            databaseName,
            dataConnectionName,
            options
        }, checkNameAvailabilityOperationSpec$3);
    }
    /**
     * Checks that the data connection parameters are valid.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param kustoPoolName The name of the Kusto pool.
     * @param databaseName The name of the database in the Kusto pool.
     * @param parameters The data connection parameters supplied to the CreateOrUpdate operation.
     * @param options The options parameters.
     */
    beginDataConnectionValidation(resourceGroupName, workspaceName, kustoPoolName, databaseName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                workspaceName,
                kustoPoolName,
                databaseName,
                parameters,
                options
            }, dataConnectionValidationOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Checks that the data connection parameters are valid.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param kustoPoolName The name of the Kusto pool.
     * @param databaseName The name of the database in the Kusto pool.
     * @param parameters The data connection parameters supplied to the CreateOrUpdate operation.
     * @param options The options parameters.
     */
    beginDataConnectionValidationAndWait(resourceGroupName, workspaceName, kustoPoolName, databaseName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDataConnectionValidation(resourceGroupName, workspaceName, kustoPoolName, databaseName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Returns the list of data connections of the given Kusto pool database.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param kustoPoolName The name of the Kusto pool.
     * @param databaseName The name of the database in the Kusto pool.
     * @param options The options parameters.
     */
    _listByDatabase(resourceGroupName, workspaceName, kustoPoolName, databaseName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workspaceName,
            kustoPoolName,
            databaseName,
            options
        }, listByDatabaseOperationSpec);
    }
    /**
     * Returns a data connection.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param kustoPoolName The name of the Kusto pool.
     * @param databaseName The name of the database in the Kusto pool.
     * @param dataConnectionName The name of the data connection.
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, kustoPoolName, databaseName, dataConnectionName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workspaceName,
            kustoPoolName,
            databaseName,
            dataConnectionName,
            options
        }, getOperationSpec$R);
    }
    /**
     * Creates or updates a data connection.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param kustoPoolName The name of the Kusto pool.
     * @param databaseName The name of the database in the Kusto pool.
     * @param dataConnectionName The name of the data connection.
     * @param parameters The data connection parameters supplied to the CreateOrUpdate operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, workspaceName, kustoPoolName, databaseName, dataConnectionName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                workspaceName,
                kustoPoolName,
                databaseName,
                dataConnectionName,
                parameters,
                options
            }, createOrUpdateOperationSpec$t);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Creates or updates a data connection.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param kustoPoolName The name of the Kusto pool.
     * @param databaseName The name of the database in the Kusto pool.
     * @param dataConnectionName The name of the data connection.
     * @param parameters The data connection parameters supplied to the CreateOrUpdate operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, workspaceName, kustoPoolName, databaseName, dataConnectionName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, workspaceName, kustoPoolName, databaseName, dataConnectionName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates a data connection.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param kustoPoolName The name of the Kusto pool.
     * @param databaseName The name of the database in the Kusto pool.
     * @param dataConnectionName The name of the data connection.
     * @param parameters The data connection parameters supplied to the Update operation.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, workspaceName, kustoPoolName, databaseName, dataConnectionName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                workspaceName,
                kustoPoolName,
                databaseName,
                dataConnectionName,
                parameters,
                options
            }, updateOperationSpec$a);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Updates a data connection.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param kustoPoolName The name of the Kusto pool.
     * @param databaseName The name of the database in the Kusto pool.
     * @param dataConnectionName The name of the data connection.
     * @param parameters The data connection parameters supplied to the Update operation.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, workspaceName, kustoPoolName, databaseName, dataConnectionName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, workspaceName, kustoPoolName, databaseName, dataConnectionName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes the data connection with the given name.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param kustoPoolName The name of the Kusto pool.
     * @param databaseName The name of the database in the Kusto pool.
     * @param dataConnectionName The name of the data connection.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, workspaceName, kustoPoolName, databaseName, dataConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                workspaceName,
                kustoPoolName,
                databaseName,
                dataConnectionName,
                options
            }, deleteOperationSpec$l);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Deletes the data connection with the given name.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param kustoPoolName The name of the Kusto pool.
     * @param databaseName The name of the database in the Kusto pool.
     * @param dataConnectionName The name of the data connection.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, workspaceName, kustoPoolName, databaseName, dataConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, workspaceName, kustoPoolName, databaseName, dataConnectionName, options);
            return poller.pollUntilDone();
        });
    }
}
// Operation Specifications
const serializer$15 = coreClient.createSerializer(Mappers, /* isXml */ false);
const checkNameAvailabilityOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/kustoPools/{kustoPoolName}/databases/{databaseName}/checkNameAvailability",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: CheckNameResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: dataConnectionName,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        kustoPoolName1,
        databaseName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$15
};
const dataConnectionValidationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/kustoPools/{kustoPoolName}/databases/{databaseName}/dataConnectionValidation",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: DataConnectionValidationListResult
        },
        201: {
            bodyMapper: DataConnectionValidationListResult
        },
        202: {
            bodyMapper: DataConnectionValidationListResult
        },
        204: {
            bodyMapper: DataConnectionValidationListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters26,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        kustoPoolName1,
        databaseName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$15
};
const listByDatabaseOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/kustoPools/{kustoPoolName}/databases/{databaseName}/dataConnections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DataConnectionListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        kustoPoolName1,
        databaseName
    ],
    headerParameters: [accept],
    serializer: serializer$15
};
const getOperationSpec$R = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/kustoPools/{kustoPoolName}/databases/{databaseName}/dataConnections/{dataConnectionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DataConnection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        kustoPoolName1,
        databaseName,
        dataConnectionName1
    ],
    headerParameters: [accept],
    serializer: serializer$15
};
const createOrUpdateOperationSpec$t = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/kustoPools/{kustoPoolName}/databases/{databaseName}/dataConnections/{dataConnectionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: DataConnection
        },
        201: {
            bodyMapper: DataConnection
        },
        202: {
            bodyMapper: DataConnection
        },
        204: {
            bodyMapper: DataConnection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters27,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        kustoPoolName1,
        databaseName,
        dataConnectionName1
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$15
};
const updateOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/kustoPools/{kustoPoolName}/databases/{databaseName}/dataConnections/{dataConnectionName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: DataConnection
        },
        201: {
            bodyMapper: DataConnection
        },
        202: {
            bodyMapper: DataConnection
        },
        204: {
            bodyMapper: DataConnection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters27,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        kustoPoolName1,
        databaseName,
        dataConnectionName1
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$15
};
const deleteOperationSpec$l = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/kustoPools/{kustoPoolName}/databases/{databaseName}/dataConnections/{dataConnectionName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        kustoPoolName1,
        databaseName,
        dataConnectionName1
    ],
    headerParameters: [accept],
    serializer: serializer$15
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing KustoPoolPrincipalAssignments operations. */
class KustoPoolPrincipalAssignmentsImpl {
    /**
     * Initialize a new instance of the class KustoPoolPrincipalAssignments class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all Kusto pool principalAssignments.
     * @param workspaceName The name of the workspace.
     * @param kustoPoolName The name of the Kusto pool.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    list(workspaceName, kustoPoolName, resourceGroupName, options) {
        const iter = this.listPagingAll(workspaceName, kustoPoolName, resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(workspaceName, kustoPoolName, resourceGroupName, options);
            }
        };
    }
    listPagingPage(workspaceName, kustoPoolName, resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(workspaceName, kustoPoolName, resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listPagingAll(workspaceName, kustoPoolName, resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(workspaceName, kustoPoolName, resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Checks that the principal assignment name is valid and is not already in use.
     * @param workspaceName The name of the workspace.
     * @param kustoPoolName The name of the Kusto pool.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param principalAssignmentName The name of the principal assignment.
     * @param options The options parameters.
     */
    checkNameAvailability(workspaceName, kustoPoolName, resourceGroupName, principalAssignmentName, options) {
        return this.client.sendOperationRequest({
            workspaceName,
            kustoPoolName,
            resourceGroupName,
            principalAssignmentName,
            options
        }, checkNameAvailabilityOperationSpec$4);
    }
    /**
     * Lists all Kusto pool principalAssignments.
     * @param workspaceName The name of the workspace.
     * @param kustoPoolName The name of the Kusto pool.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    _list(workspaceName, kustoPoolName, resourceGroupName, options) {
        return this.client.sendOperationRequest({ workspaceName, kustoPoolName, resourceGroupName, options }, listOperationSpec$t);
    }
    /**
     * Gets a Kusto pool principalAssignment.
     * @param workspaceName The name of the workspace.
     * @param kustoPoolName The name of the Kusto pool.
     * @param principalAssignmentName The name of the Kusto principalAssignment.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    get(workspaceName, kustoPoolName, principalAssignmentName, resourceGroupName, options) {
        return this.client.sendOperationRequest({
            workspaceName,
            kustoPoolName,
            principalAssignmentName,
            resourceGroupName,
            options
        }, getOperationSpec$S);
    }
    /**
     * Create a Kusto pool principalAssignment.
     * @param workspaceName The name of the workspace.
     * @param kustoPoolName The name of the Kusto pool.
     * @param principalAssignmentName The name of the Kusto principalAssignment.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param parameters The Kusto pool principalAssignment's parameters supplied for the operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(workspaceName, kustoPoolName, principalAssignmentName, resourceGroupName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                workspaceName,
                kustoPoolName,
                principalAssignmentName,
                resourceGroupName,
                parameters,
                options
            }, createOrUpdateOperationSpec$u);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Create a Kusto pool principalAssignment.
     * @param workspaceName The name of the workspace.
     * @param kustoPoolName The name of the Kusto pool.
     * @param principalAssignmentName The name of the Kusto principalAssignment.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param parameters The Kusto pool principalAssignment's parameters supplied for the operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(workspaceName, kustoPoolName, principalAssignmentName, resourceGroupName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(workspaceName, kustoPoolName, principalAssignmentName, resourceGroupName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes a Kusto pool principalAssignment.
     * @param workspaceName The name of the workspace.
     * @param kustoPoolName The name of the Kusto pool.
     * @param principalAssignmentName The name of the Kusto principalAssignment.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    beginDelete(workspaceName, kustoPoolName, principalAssignmentName, resourceGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                workspaceName,
                kustoPoolName,
                principalAssignmentName,
                resourceGroupName,
                options
            }, deleteOperationSpec$m);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Deletes a Kusto pool principalAssignment.
     * @param workspaceName The name of the workspace.
     * @param kustoPoolName The name of the Kusto pool.
     * @param principalAssignmentName The name of the Kusto principalAssignment.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    beginDeleteAndWait(workspaceName, kustoPoolName, principalAssignmentName, resourceGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(workspaceName, kustoPoolName, principalAssignmentName, resourceGroupName, options);
            return poller.pollUntilDone();
        });
    }
}
// Operation Specifications
const serializer$16 = coreClient.createSerializer(Mappers, /* isXml */ false);
const checkNameAvailabilityOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/kustoPools/{kustoPoolName}/checkPrincipalAssignmentNameAvailability",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: CheckNameResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: principalAssignmentName,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        kustoPoolName1
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$16
};
const listOperationSpec$t = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/kustoPools/{kustoPoolName}/principalAssignments",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ClusterPrincipalAssignmentListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        kustoPoolName1
    ],
    headerParameters: [accept],
    serializer: serializer$16
};
const getOperationSpec$S = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/kustoPools/{kustoPoolName}/principalAssignments/{principalAssignmentName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ClusterPrincipalAssignment
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        kustoPoolName1,
        principalAssignmentName1
    ],
    headerParameters: [accept],
    serializer: serializer$16
};
const createOrUpdateOperationSpec$u = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/kustoPools/{kustoPoolName}/principalAssignments/{principalAssignmentName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ClusterPrincipalAssignment
        },
        201: {
            bodyMapper: ClusterPrincipalAssignment
        },
        202: {
            bodyMapper: ClusterPrincipalAssignment
        },
        204: {
            bodyMapper: ClusterPrincipalAssignment
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters28,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        kustoPoolName1,
        principalAssignmentName1
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$16
};
const deleteOperationSpec$m = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/kustoPools/{kustoPoolName}/principalAssignments/{principalAssignmentName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        kustoPoolName1,
        principalAssignmentName1
    ],
    headerParameters: [accept],
    serializer: serializer$16
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing KustoPoolDatabasePrincipalAssignments operations. */
class KustoPoolDatabasePrincipalAssignmentsImpl {
    /**
     * Initialize a new instance of the class KustoPoolDatabasePrincipalAssignments class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all Kusto pool database principalAssignments.
     * @param workspaceName The name of the workspace.
     * @param kustoPoolName The name of the Kusto pool.
     * @param databaseName The name of the database in the Kusto pool.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    list(workspaceName, kustoPoolName, databaseName, resourceGroupName, options) {
        const iter = this.listPagingAll(workspaceName, kustoPoolName, databaseName, resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(workspaceName, kustoPoolName, databaseName, resourceGroupName, options);
            }
        };
    }
    listPagingPage(workspaceName, kustoPoolName, databaseName, resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(workspaceName, kustoPoolName, databaseName, resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listPagingAll(workspaceName, kustoPoolName, databaseName, resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(workspaceName, kustoPoolName, databaseName, resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Checks that the database principal assignment is valid and is not already in use.
     * @param workspaceName The name of the workspace.
     * @param kustoPoolName The name of the Kusto pool.
     * @param databaseName The name of the database in the Kusto pool.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param principalAssignmentName The name of the resource.
     * @param options The options parameters.
     */
    checkNameAvailability(workspaceName, kustoPoolName, databaseName, resourceGroupName, principalAssignmentName, options) {
        return this.client.sendOperationRequest({
            workspaceName,
            kustoPoolName,
            databaseName,
            resourceGroupName,
            principalAssignmentName,
            options
        }, checkNameAvailabilityOperationSpec$5);
    }
    /**
     * Lists all Kusto pool database principalAssignments.
     * @param workspaceName The name of the workspace.
     * @param kustoPoolName The name of the Kusto pool.
     * @param databaseName The name of the database in the Kusto pool.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    _list(workspaceName, kustoPoolName, databaseName, resourceGroupName, options) {
        return this.client.sendOperationRequest({
            workspaceName,
            kustoPoolName,
            databaseName,
            resourceGroupName,
            options
        }, listOperationSpec$u);
    }
    /**
     * Gets a Kusto pool database principalAssignment.
     * @param workspaceName The name of the workspace.
     * @param kustoPoolName The name of the Kusto pool.
     * @param databaseName The name of the database in the Kusto pool.
     * @param principalAssignmentName The name of the Kusto principalAssignment.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    get(workspaceName, kustoPoolName, databaseName, principalAssignmentName, resourceGroupName, options) {
        return this.client.sendOperationRequest({
            workspaceName,
            kustoPoolName,
            databaseName,
            principalAssignmentName,
            resourceGroupName,
            options
        }, getOperationSpec$T);
    }
    /**
     * Creates a Kusto pool database principalAssignment.
     * @param workspaceName The name of the workspace.
     * @param kustoPoolName The name of the Kusto pool.
     * @param databaseName The name of the database in the Kusto pool.
     * @param principalAssignmentName The name of the Kusto principalAssignment.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param parameters The Kusto principalAssignments parameters supplied for the operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(workspaceName, kustoPoolName, databaseName, principalAssignmentName, resourceGroupName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                workspaceName,
                kustoPoolName,
                databaseName,
                principalAssignmentName,
                resourceGroupName,
                parameters,
                options
            }, createOrUpdateOperationSpec$v);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Creates a Kusto pool database principalAssignment.
     * @param workspaceName The name of the workspace.
     * @param kustoPoolName The name of the Kusto pool.
     * @param databaseName The name of the database in the Kusto pool.
     * @param principalAssignmentName The name of the Kusto principalAssignment.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param parameters The Kusto principalAssignments parameters supplied for the operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(workspaceName, kustoPoolName, databaseName, principalAssignmentName, resourceGroupName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(workspaceName, kustoPoolName, databaseName, principalAssignmentName, resourceGroupName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes a Kusto pool principalAssignment.
     * @param workspaceName The name of the workspace.
     * @param kustoPoolName The name of the Kusto pool.
     * @param databaseName The name of the database in the Kusto pool.
     * @param principalAssignmentName The name of the Kusto principalAssignment.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    beginDelete(workspaceName, kustoPoolName, databaseName, principalAssignmentName, resourceGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                workspaceName,
                kustoPoolName,
                databaseName,
                principalAssignmentName,
                resourceGroupName,
                options
            }, deleteOperationSpec$n);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Deletes a Kusto pool principalAssignment.
     * @param workspaceName The name of the workspace.
     * @param kustoPoolName The name of the Kusto pool.
     * @param databaseName The name of the database in the Kusto pool.
     * @param principalAssignmentName The name of the Kusto principalAssignment.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    beginDeleteAndWait(workspaceName, kustoPoolName, databaseName, principalAssignmentName, resourceGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(workspaceName, kustoPoolName, databaseName, principalAssignmentName, resourceGroupName, options);
            return poller.pollUntilDone();
        });
    }
}
// Operation Specifications
const serializer$17 = coreClient.createSerializer(Mappers, /* isXml */ false);
const checkNameAvailabilityOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/kustoPools/{kustoPoolName}/databases/{databaseName}/checkPrincipalAssignmentNameAvailability",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: CheckNameResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: principalAssignmentName2,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        kustoPoolName1,
        databaseName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$17
};
const listOperationSpec$u = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/kustoPools/{kustoPoolName}/databases/{databaseName}/principalAssignments",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DatabasePrincipalAssignmentListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        kustoPoolName1,
        databaseName
    ],
    headerParameters: [accept],
    serializer: serializer$17
};
const getOperationSpec$T = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/kustoPools/{kustoPoolName}/databases/{databaseName}/principalAssignments/{principalAssignmentName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DatabasePrincipalAssignment
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        kustoPoolName1,
        databaseName,
        principalAssignmentName1
    ],
    headerParameters: [accept],
    serializer: serializer$17
};
const createOrUpdateOperationSpec$v = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/kustoPools/{kustoPoolName}/databases/{databaseName}/principalAssignments/{principalAssignmentName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: DatabasePrincipalAssignment
        },
        201: {
            bodyMapper: DatabasePrincipalAssignment
        },
        202: {
            bodyMapper: DatabasePrincipalAssignment
        },
        204: {
            bodyMapper: DatabasePrincipalAssignment
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters29,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        kustoPoolName1,
        databaseName,
        principalAssignmentName1
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$17
};
const deleteOperationSpec$n = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Synapse/workspaces/{workspaceName}/kustoPools/{kustoPoolName}/databases/{databaseName}/principalAssignments/{principalAssignmentName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        kustoPoolName1,
        databaseName,
        principalAssignmentName1
    ],
    headerParameters: [accept],
    serializer: serializer$17
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class SynapseManagementClient extends coreClient.ServiceClient {
    /**
     * Initializes a new instance of the SynapseManagementClient class.
     * @param credentials Subscription credentials which uniquely identify client subscription.
     * @param subscriptionId The ID of the target subscription.
     * @param options The parameter options
     */
    constructor(credentials, subscriptionId, options) {
        if (credentials === undefined) {
            throw new Error("'credentials' cannot be null");
        }
        if (subscriptionId === undefined) {
            throw new Error("'subscriptionId' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8",
            credential: credentials
        };
        const packageDetails = `azsdk-js-arm-synapse/8.0.0`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        if (!options.credentialScopes) {
            options.credentialScopes = ["https://management.azure.com/.default"];
        }
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix
            }, baseUri: options.endpoint || "https://management.azure.com" });
        super(optionsWithDefaults);
        // Parameter assignments
        this.subscriptionId = subscriptionId;
        // Assigning values to Constant parameters
        this.$host = options.$host || "https://management.azure.com";
        this.azureADOnlyAuthentications = new AzureADOnlyAuthenticationsImpl(this);
        this.operations = new OperationsImpl(this);
        this.ipFirewallRules = new IpFirewallRulesImpl(this);
        this.keys = new KeysImpl(this);
        this.privateEndpointConnections = new PrivateEndpointConnectionsImpl(this);
        this.privateLinkResources = new PrivateLinkResourcesImpl(this);
        this.privateLinkHubPrivateLinkResources = new PrivateLinkHubPrivateLinkResourcesImpl(this);
        this.privateLinkHubs = new PrivateLinkHubsImpl(this);
        this.privateEndpointConnectionsPrivateLinkHub = new PrivateEndpointConnectionsPrivateLinkHubImpl(this);
        this.sqlPools = new SqlPoolsImpl(this);
        this.sqlPoolMetadataSyncConfigs = new SqlPoolMetadataSyncConfigsImpl(this);
        this.sqlPoolOperationResults = new SqlPoolOperationResultsImpl(this);
        this.sqlPoolGeoBackupPolicies = new SqlPoolGeoBackupPoliciesImpl(this);
        this.sqlPoolDataWarehouseUserActivities = new SqlPoolDataWarehouseUserActivitiesImpl(this);
        this.sqlPoolRestorePoints = new SqlPoolRestorePointsImpl(this);
        this.sqlPoolReplicationLinks = new SqlPoolReplicationLinksImpl(this);
        this.sqlPoolMaintenanceWindows = new SqlPoolMaintenanceWindowsImpl(this);
        this.sqlPoolMaintenanceWindowOptions = new SqlPoolMaintenanceWindowOptionsImpl(this);
        this.sqlPoolTransparentDataEncryptions = new SqlPoolTransparentDataEncryptionsImpl(this);
        this.sqlPoolBlobAuditingPolicies = new SqlPoolBlobAuditingPoliciesImpl(this);
        this.sqlPoolOperations = new SqlPoolOperationsImpl(this);
        this.sqlPoolUsages = new SqlPoolUsagesImpl(this);
        this.sqlPoolSensitivityLabels = new SqlPoolSensitivityLabelsImpl(this);
        this.sqlPoolRecommendedSensitivityLabels = new SqlPoolRecommendedSensitivityLabelsImpl(this);
        this.sqlPoolSchemas = new SqlPoolSchemasImpl(this);
        this.sqlPoolTables = new SqlPoolTablesImpl(this);
        this.sqlPoolTableColumns = new SqlPoolTableColumnsImpl(this);
        this.sqlPoolConnectionPolicies = new SqlPoolConnectionPoliciesImpl(this);
        this.sqlPoolVulnerabilityAssessments = new SqlPoolVulnerabilityAssessmentsImpl(this);
        this.sqlPoolVulnerabilityAssessmentScans = new SqlPoolVulnerabilityAssessmentScansImpl(this);
        this.sqlPoolSecurityAlertPolicies = new SqlPoolSecurityAlertPoliciesImpl(this);
        this.sqlPoolVulnerabilityAssessmentRuleBaselines = new SqlPoolVulnerabilityAssessmentRuleBaselinesImpl(this);
        this.extendedSqlPoolBlobAuditingPolicies = new ExtendedSqlPoolBlobAuditingPoliciesImpl(this);
        this.dataMaskingPolicies = new DataMaskingPoliciesImpl(this);
        this.dataMaskingRules = new DataMaskingRulesImpl(this);
        this.sqlPoolColumns = new SqlPoolColumnsImpl(this);
        this.sqlPoolWorkloadGroup = new SqlPoolWorkloadGroupImpl(this);
        this.sqlPoolWorkloadClassifier = new SqlPoolWorkloadClassifierImpl(this);
        this.workspaceManagedSqlServerBlobAuditingPolicies = new WorkspaceManagedSqlServerBlobAuditingPoliciesImpl(this);
        this.workspaceManagedSqlServerExtendedBlobAuditingPolicies = new WorkspaceManagedSqlServerExtendedBlobAuditingPoliciesImpl(this);
        this.workspaceManagedSqlServerSecurityAlertPolicy = new WorkspaceManagedSqlServerSecurityAlertPolicyImpl(this);
        this.workspaceManagedSqlServerVulnerabilityAssessments = new WorkspaceManagedSqlServerVulnerabilityAssessmentsImpl(this);
        this.workspaceManagedSqlServerEncryptionProtector = new WorkspaceManagedSqlServerEncryptionProtectorImpl(this);
        this.workspaceManagedSqlServerUsages = new WorkspaceManagedSqlServerUsagesImpl(this);
        this.workspaceManagedSqlServerRecoverableSqlPools = new WorkspaceManagedSqlServerRecoverableSqlPoolsImpl(this);
        this.workspaces = new WorkspacesImpl(this);
        this.workspaceAadAdmins = new WorkspaceAadAdminsImpl(this);
        this.workspaceSqlAadAdmins = new WorkspaceSqlAadAdminsImpl(this);
        this.workspaceManagedIdentitySqlControlSettings = new WorkspaceManagedIdentitySqlControlSettingsImpl(this);
        this.restorableDroppedSqlPools = new RestorableDroppedSqlPoolsImpl(this);
        this.bigDataPools = new BigDataPoolsImpl(this);
        this.library = new LibraryImpl(this);
        this.libraries = new LibrariesImpl(this);
        this.integrationRuntimes = new IntegrationRuntimesImpl(this);
        this.integrationRuntimeNodeIpAddressOperations = new IntegrationRuntimeNodeIpAddressOperationsImpl(this);
        this.integrationRuntimeObjectMetadata = new IntegrationRuntimeObjectMetadataImpl(this);
        this.integrationRuntimeNodes = new IntegrationRuntimeNodesImpl(this);
        this.integrationRuntimeCredentials = new IntegrationRuntimeCredentialsImpl(this);
        this.integrationRuntimeConnectionInfos = new IntegrationRuntimeConnectionInfosImpl(this);
        this.integrationRuntimeAuthKeysOperations = new IntegrationRuntimeAuthKeysOperationsImpl(this);
        this.integrationRuntimeMonitoringDataOperations = new IntegrationRuntimeMonitoringDataOperationsImpl(this);
        this.integrationRuntimeStatusOperations = new IntegrationRuntimeStatusOperationsImpl(this);
        this.sparkConfiguration = new SparkConfigurationImpl(this);
        this.sparkConfigurations = new SparkConfigurationsImpl(this);
        this.kustoOperations = new KustoOperationsImpl(this);
        this.kustoPools = new KustoPoolsImpl(this);
        this.kustoPoolChildResource = new KustoPoolChildResourceImpl(this);
        this.kustoPoolAttachedDatabaseConfigurations = new KustoPoolAttachedDatabaseConfigurationsImpl(this);
        this.kustoPoolDatabases = new KustoPoolDatabasesImpl(this);
        this.kustoPoolDataConnections = new KustoPoolDataConnectionsImpl(this);
        this.kustoPoolPrincipalAssignments = new KustoPoolPrincipalAssignmentsImpl(this);
        this.kustoPoolDatabasePrincipalAssignments = new KustoPoolDatabasePrincipalAssignmentsImpl(this);
    }
}

exports.SynapseManagementClient = SynapseManagementClient;
//# sourceMappingURL=index.js.map
